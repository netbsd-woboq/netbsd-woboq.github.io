<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>pax.h source code [netbsd/bin/pax/pax.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="oplist,pattern "/>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/bin/pax/pax.h'; var root_path = '../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../..'>netbsd</a>/<a href='..'>bin</a>/<a href='./'>pax</a>/<a href='pax.h.html'>pax.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*	$NetBSD: pax.h,v 1.31 2012/08/09 08:09:21 christos Exp $	*/</i></td></tr>
<tr><th id="2">2</th><td></td></tr>
<tr><th id="3">3</th><td><i>/*-</i></td></tr>
<tr><th id="4">4</th><td><i> * Copyright (c) 1992 Keith Muller.</i></td></tr>
<tr><th id="5">5</th><td><i> * Copyright (c) 1992, 1993</i></td></tr>
<tr><th id="6">6</th><td><i> *	The Regents of the University of California.  All rights reserved.</i></td></tr>
<tr><th id="7">7</th><td><i> *</i></td></tr>
<tr><th id="8">8</th><td><i> * This code is derived from software contributed to Berkeley by</i></td></tr>
<tr><th id="9">9</th><td><i> * Keith Muller of the University of California, San Diego.</i></td></tr>
<tr><th id="10">10</th><td><i> *</i></td></tr>
<tr><th id="11">11</th><td><i> * Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="12">12</th><td><i> * modification, are permitted provided that the following conditions</i></td></tr>
<tr><th id="13">13</th><td><i> * are met:</i></td></tr>
<tr><th id="14">14</th><td><i> * 1. Redistributions of source code must retain the above copyright</i></td></tr>
<tr><th id="15">15</th><td><i> *    notice, this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="16">16</th><td><i> * 2. Redistributions in binary form must reproduce the above copyright</i></td></tr>
<tr><th id="17">17</th><td><i> *    notice, this list of conditions and the following disclaimer in the</i></td></tr>
<tr><th id="18">18</th><td><i> *    documentation and/or other materials provided with the distribution.</i></td></tr>
<tr><th id="19">19</th><td><i> * 3. Neither the name of the University nor the names of its contributors</i></td></tr>
<tr><th id="20">20</th><td><i> *    may be used to endorse or promote products derived from this software</i></td></tr>
<tr><th id="21">21</th><td><i> *    without specific prior written permission.</i></td></tr>
<tr><th id="22">22</th><td><i> *</i></td></tr>
<tr><th id="23">23</th><td><i> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</i></td></tr>
<tr><th id="24">24</th><td><i> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</i></td></tr>
<tr><th id="25">25</th><td><i> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</i></td></tr>
<tr><th id="26">26</th><td><i> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</i></td></tr>
<tr><th id="27">27</th><td><i> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</i></td></tr>
<tr><th id="28">28</th><td><i> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</i></td></tr>
<tr><th id="29">29</th><td><i> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</i></td></tr>
<tr><th id="30">30</th><td><i> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</i></td></tr>
<tr><th id="31">31</th><td><i> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</i></td></tr>
<tr><th id="32">32</th><td><i> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</i></td></tr>
<tr><th id="33">33</th><td><i> * SUCH DAMAGE.</i></td></tr>
<tr><th id="34">34</th><td><i> *</i></td></tr>
<tr><th id="35">35</th><td><i> *	@(#)pax.h	8.2 (Berkeley) 4/18/94</i></td></tr>
<tr><th id="36">36</th><td><i> */</i></td></tr>
<tr><th id="37">37</th><td></td></tr>
<tr><th id="38">38</th><td><u>#<span data-ppcond="38">if</span> ! HAVE_NBTOOL_CONFIG_H</u></td></tr>
<tr><th id="39">39</th><td><u>#define <dfn class="macro" id="_M/HAVE_LUTIMES" data-ref="_M/HAVE_LUTIMES">HAVE_LUTIMES</dfn> 1</u></td></tr>
<tr><th id="40">40</th><td><u>#define <dfn class="macro" id="_M/HAVE_STRUCT_STAT_ST_FLAGS" data-ref="_M/HAVE_STRUCT_STAT_ST_FLAGS">HAVE_STRUCT_STAT_ST_FLAGS</dfn> 1</u></td></tr>
<tr><th id="41">41</th><td><u>#<span data-ppcond="38">endif</span></u></td></tr>
<tr><th id="42">42</th><td></td></tr>
<tr><th id="43">43</th><td><i>/*</i></td></tr>
<tr><th id="44">44</th><td><i> * BSD PAX global data structures and constants.</i></td></tr>
<tr><th id="45">45</th><td><i> */</i></td></tr>
<tr><th id="46">46</th><td></td></tr>
<tr><th id="47">47</th><td><u>#define	<dfn class="macro" id="_M/MAXBLK" data-ref="_M/MAXBLK">MAXBLK</dfn>		32256	/* MAX blocksize supported (posix SPEC) */</u></td></tr>
<tr><th id="48">48</th><td>				<i>/* WARNING: increasing MAXBLK past 32256 */</i></td></tr>
<tr><th id="49">49</th><td>				<i>/* will violate posix spec. */</i></td></tr>
<tr><th id="50">50</th><td><u>#define <dfn class="macro" id="_M/BLKMULT" data-ref="_M/BLKMULT">BLKMULT</dfn>		512	/* blocksize must be even mult of 512 bytes */</u></td></tr>
<tr><th id="51">51</th><td>				<i>/* Don't even think of changing this */</i></td></tr>
<tr><th id="52">52</th><td><u>#define <dfn class="macro" id="_M/DEVBLK" data-ref="_M/DEVBLK">DEVBLK</dfn>		8192	/* default read blksize for devices */</u></td></tr>
<tr><th id="53">53</th><td><u>#define <dfn class="macro" id="_M/FILEBLK" data-ref="_M/FILEBLK">FILEBLK</dfn>		10240	/* default read blksize for files */</u></td></tr>
<tr><th id="54">54</th><td><u>#define <dfn class="macro" id="_M/PAXPATHLEN" data-ref="_M/PAXPATHLEN">PAXPATHLEN</dfn>	3072	/* maximum path length for pax. MUST be */</u></td></tr>
<tr><th id="55">55</th><td>				<i>/* longer than the system MAXPATHLEN */</i></td></tr>
<tr><th id="56">56</th><td></td></tr>
<tr><th id="57">57</th><td><i>/*</i></td></tr>
<tr><th id="58">58</th><td><i> * Pax modes of operation</i></td></tr>
<tr><th id="59">59</th><td><i> */</i></td></tr>
<tr><th id="60">60</th><td><u>#define <dfn class="macro" id="_M/ERROR" data-ref="_M/ERROR">ERROR</dfn>		-1	/* nothing selected */</u></td></tr>
<tr><th id="61">61</th><td><u>#define	<dfn class="macro" id="_M/LIST" data-ref="_M/LIST">LIST</dfn>		0	/* List the file in an archive */</u></td></tr>
<tr><th id="62">62</th><td><u>#define	<dfn class="macro" id="_M/EXTRACT" data-ref="_M/EXTRACT">EXTRACT</dfn>		1	/* extract the files in an archive */</u></td></tr>
<tr><th id="63">63</th><td><u>#define <dfn class="macro" id="_M/ARCHIVE" data-ref="_M/ARCHIVE">ARCHIVE</dfn>		2	/* write a new archive */</u></td></tr>
<tr><th id="64">64</th><td><u>#define <dfn class="macro" id="_M/APPND" data-ref="_M/APPND">APPND</dfn>		3	/* append to the end of an archive */</u></td></tr>
<tr><th id="65">65</th><td><u>#define	<dfn class="macro" id="_M/COPY" data-ref="_M/COPY">COPY</dfn>		4	/* copy files to destination dir */</u></td></tr>
<tr><th id="66">66</th><td></td></tr>
<tr><th id="67">67</th><td><i>/*</i></td></tr>
<tr><th id="68">68</th><td><i> * Device type of the current archive volume</i></td></tr>
<tr><th id="69">69</th><td><i> */</i></td></tr>
<tr><th id="70">70</th><td><u>#define <dfn class="macro" id="_M/ISREG" data-ref="_M/ISREG">ISREG</dfn>		0	/* regular file */</u></td></tr>
<tr><th id="71">71</th><td><u>#define <dfn class="macro" id="_M/ISCHR" data-ref="_M/ISCHR">ISCHR</dfn>		1	/* character device */</u></td></tr>
<tr><th id="72">72</th><td><u>#define <dfn class="macro" id="_M/ISBLK" data-ref="_M/ISBLK">ISBLK</dfn>		2	/* block device */</u></td></tr>
<tr><th id="73">73</th><td><u>#define <dfn class="macro" id="_M/ISTAPE" data-ref="_M/ISTAPE">ISTAPE</dfn>		3	/* tape drive */</u></td></tr>
<tr><th id="74">74</th><td><u>#define <dfn class="macro" id="_M/ISPIPE" data-ref="_M/ISPIPE">ISPIPE</dfn>		4	/* pipe/socket */</u></td></tr>
<tr><th id="75">75</th><td><u>#<span data-ppcond="75">ifdef</span> <span class="macro" data-ref="_M/SUPPORT_RMT">SUPPORT_RMT</span></u></td></tr>
<tr><th id="76">76</th><td><u>#define	<dfn class="macro" id="_M/ISRMT" data-ref="_M/ISRMT">ISRMT</dfn>		5	/* rmt */</u></td></tr>
<tr><th id="77">77</th><td><u>#<span data-ppcond="75">endif</span></u></td></tr>
<tr><th id="78">78</th><td></td></tr>
<tr><th id="79">79</th><td><i>/*</i></td></tr>
<tr><th id="80">80</th><td><i> * Pattern matching structure</i></td></tr>
<tr><th id="81">81</th><td><i> *</i></td></tr>
<tr><th id="82">82</th><td><i> * Used to store command line patterns</i></td></tr>
<tr><th id="83">83</th><td><i> */</i></td></tr>
<tr><th id="84">84</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="pattern" title='pattern' data-ref="pattern" data-ref-filename="pattern"><a class="type" href="#pattern" title='pattern' data-ref="pattern" data-ref-filename="pattern">pattern</a></dfn> {</td></tr>
<tr><th id="85">85</th><td>	<em>char</em>		*<dfn class="decl field" id="pattern::pstr" title='pattern::pstr' data-ref="pattern::pstr" data-ref-filename="pattern..pstr">pstr</dfn>;		<i>/* pattern to match, user supplied */</i></td></tr>
<tr><th id="86">86</th><td>	<em>char</em>		*<dfn class="decl field" id="pattern::pend" title='pattern::pend' data-ref="pattern::pend" data-ref-filename="pattern..pend">pend</dfn>;		<i>/* end of a prefix match */</i></td></tr>
<tr><th id="87">87</th><td>	<em>char</em>		*<dfn class="decl field" id="pattern::chdname" title='pattern::chdname' data-ref="pattern::chdname" data-ref-filename="pattern..chdname">chdname</dfn>;	<i>/* the dir to change to if not NULL. */</i></td></tr>
<tr><th id="88">88</th><td>	<em>int</em>		<dfn class="decl field" id="pattern::plen" title='pattern::plen' data-ref="pattern::plen" data-ref-filename="pattern..plen">plen</dfn>;		<i>/* length of pstr */</i></td></tr>
<tr><th id="89">89</th><td>	<em>int</em>		<dfn class="decl field" id="pattern::flgs" title='pattern::flgs' data-ref="pattern::flgs" data-ref-filename="pattern..flgs">flgs</dfn>;		<i>/* processing/state flags */</i></td></tr>
<tr><th id="90">90</th><td><u>#define <dfn class="macro" id="_M/MTCH" data-ref="_M/MTCH">MTCH</dfn>		0x1		/* pattern has been matched */</u></td></tr>
<tr><th id="91">91</th><td><u>#define <dfn class="macro" id="_M/DIR_MTCH" data-ref="_M/DIR_MTCH">DIR_MTCH</dfn>	0x2		/* pattern matched a directory */</u></td></tr>
<tr><th id="92">92</th><td><u>#define <dfn class="macro" id="_M/NOGLOB_MTCH" data-ref="_M/NOGLOB_MTCH">NOGLOB_MTCH</dfn>	0x4		/* non-globbing match */</u></td></tr>
<tr><th id="93">93</th><td>	<b>struct</b> <a class="type" href="#pattern" title='pattern' data-ref="pattern" data-ref-filename="pattern">pattern</a>	*<dfn class="decl field" id="pattern::fow" title='pattern::fow' data-ref="pattern::fow" data-ref-filename="pattern..fow">fow</dfn>;		<i>/* next pattern */</i></td></tr>
<tr><th id="94">94</th><td>} <dfn class="typedef" id="PATTERN" title='PATTERN' data-type='struct pattern' data-ref="PATTERN" data-ref-filename="PATTERN">PATTERN</dfn>;</td></tr>
<tr><th id="95">95</th><td></td></tr>
<tr><th id="96">96</th><td><i>/*</i></td></tr>
<tr><th id="97">97</th><td><i> * General Archive Structure (used internal to pax)</i></td></tr>
<tr><th id="98">98</th><td><i> *</i></td></tr>
<tr><th id="99">99</th><td><i> * This structure is used to pass information about archive members between</i></td></tr>
<tr><th id="100">100</th><td><i> * the format independent routines and the format specific routines. When</i></td></tr>
<tr><th id="101">101</th><td><i> * new archive formats are added, they must accept requests and supply info</i></td></tr>
<tr><th id="102">102</th><td><i> * encoded in a structure of this type. The name fields are declared statically</i></td></tr>
<tr><th id="103">103</th><td><i> * here, as there is only ONE of these floating around, size is not a major</i></td></tr>
<tr><th id="104">104</th><td><i> * consideration. Eventually converting the name fields to a dynamic length</i></td></tr>
<tr><th id="105">105</th><td><i> * may be required if and when the supporting operating system removes all</i></td></tr>
<tr><th id="106">106</th><td><i> * restrictions on the length of pathnames it will resolve.</i></td></tr>
<tr><th id="107">107</th><td><i> */</i></td></tr>
<tr><th id="108">108</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="109">109</th><td>	<em>int</em> <dfn class="decl field" id="(anonymous)::nlen" title='(anonymous struct)::nlen' data-ref="(anonymous)::nlen" data-ref-filename="(anonymous)..nlen">nlen</dfn>;			<i>/* file name length */</i></td></tr>
<tr><th id="110">110</th><td>	<em>char</em> <dfn class="decl field" id="(anonymous)::name" title='(anonymous struct)::name' data-ref="(anonymous)::name" data-ref-filename="(anonymous)..name">name</dfn>[<a class="macro" href="#54" title="3072" data-ref="_M/PAXPATHLEN">PAXPATHLEN</a>+<var>1</var>];	<i>/* file name */</i></td></tr>
<tr><th id="111">111</th><td>	<em>int</em> <dfn class="decl field" id="(anonymous)::ln_nlen" title='(anonymous struct)::ln_nlen' data-ref="(anonymous)::ln_nlen" data-ref-filename="(anonymous)..ln_nlen">ln_nlen</dfn>;			<i>/* link name length */</i></td></tr>
<tr><th id="112">112</th><td>	<em>char</em> <dfn class="decl field" id="(anonymous)::ln_name" title='(anonymous struct)::ln_name' data-ref="(anonymous)::ln_name" data-ref-filename="(anonymous)..ln_name">ln_name</dfn>[<a class="macro" href="#54" title="3072" data-ref="_M/PAXPATHLEN">PAXPATHLEN</a>+<var>1</var>];	<i>/* name to link to (if any) */</i></td></tr>
<tr><th id="113">113</th><td>	<em>char</em> *<dfn class="decl field" id="(anonymous)::org_name" title='(anonymous struct)::org_name' data-ref="(anonymous)::org_name" data-ref-filename="(anonymous)..org_name">org_name</dfn>;			<i>/* orig name in file system */</i></td></tr>
<tr><th id="114">114</th><td>	<em>char</em> <dfn class="decl field" id="(anonymous)::fts_name" title='(anonymous struct)::fts_name' data-ref="(anonymous)::fts_name" data-ref-filename="(anonymous)..fts_name">fts_name</dfn>[<a class="macro" href="#54" title="3072" data-ref="_M/PAXPATHLEN">PAXPATHLEN</a>+<var>1</var>];	<i>/* name from fts (for *org_name) */</i></td></tr>
<tr><th id="115">115</th><td>	<em>char</em> *<dfn class="decl field" id="(anonymous)::tmp_name" title='(anonymous struct)::tmp_name' data-ref="(anonymous)::tmp_name" data-ref-filename="(anonymous)..tmp_name">tmp_name</dfn>;			<i>/* tmp name used to restore */</i></td></tr>
<tr><th id="116">116</th><td>	<a class="typedef" href="#PATTERN" title='PATTERN' data-type='struct pattern' data-ref="PATTERN" data-ref-filename="PATTERN">PATTERN</a> *<dfn class="decl field" id="(anonymous)::pat" title='(anonymous struct)::pat' data-ref="(anonymous)::pat" data-ref-filename="(anonymous)..pat">pat</dfn>;			<i>/* ptr to pattern match (if any) */</i></td></tr>
<tr><th id="117">117</th><td>	<b>struct</b> <a class="type" href="../../objdir.amd64/destdir.amd64/usr/include/sys/stat.h.html#stat" title='stat' data-ref="stat" data-ref-filename="stat">stat</a> <dfn class="decl field" id="(anonymous)::sb" title='(anonymous struct)::sb' data-ref="(anonymous)::sb" data-ref-filename="(anonymous)..sb">sb</dfn>;			<i>/* stat buffer see stat(2) */</i></td></tr>
<tr><th id="118">118</th><td>	<a class="macro" href="../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#178" title="__off_t" data-ref="_M/off_t">off_t</a> <dfn class="decl field" id="(anonymous)::pad" title='(anonymous struct)::pad' data-ref="(anonymous)::pad" data-ref-filename="(anonymous)..pad">pad</dfn>;			<i>/* bytes of padding after file xfer */</i></td></tr>
<tr><th id="119">119</th><td>	<a class="macro" href="../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#178" title="__off_t" data-ref="_M/off_t">off_t</a> <dfn class="decl field" id="(anonymous)::skip" title='(anonymous struct)::skip' data-ref="(anonymous)::skip" data-ref-filename="(anonymous)..skip">skip</dfn>;			<i>/* bytes of real data after header */</i></td></tr>
<tr><th id="120">120</th><td>					<i>/* IMPORTANT. The st_size field does */</i></td></tr>
<tr><th id="121">121</th><td>					<i>/* not always indicate the amount of */</i></td></tr>
<tr><th id="122">122</th><td>					<i>/* data following the header. */</i></td></tr>
<tr><th id="123">123</th><td>	<a class="typedef" href="../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_long" title='u_long' data-type='unsigned long' data-ref="u_long" data-ref-filename="u_long">u_long</a> <dfn class="decl field" id="(anonymous)::crc" title='(anonymous struct)::crc' data-ref="(anonymous)::crc" data-ref-filename="(anonymous)..crc">crc</dfn>;			<i>/* file crc */</i></td></tr>
<tr><th id="124">124</th><td>	<em>int</em> <dfn class="decl field" id="(anonymous)::type" title='(anonymous struct)::type' data-ref="(anonymous)::type" data-ref-filename="(anonymous)..type">type</dfn>;			<i>/* type of file node */</i></td></tr>
<tr><th id="125">125</th><td><u>#define <dfn class="macro" id="_M/PAX_DIR" data-ref="_M/PAX_DIR">PAX_DIR</dfn>		1		/* directory */</u></td></tr>
<tr><th id="126">126</th><td><u>#define <dfn class="macro" id="_M/PAX_CHR" data-ref="_M/PAX_CHR">PAX_CHR</dfn>		2		/* character device */</u></td></tr>
<tr><th id="127">127</th><td><u>#define <dfn class="macro" id="_M/PAX_BLK" data-ref="_M/PAX_BLK">PAX_BLK</dfn>		3		/* block device */</u></td></tr>
<tr><th id="128">128</th><td><u>#define <dfn class="macro" id="_M/PAX_REG" data-ref="_M/PAX_REG">PAX_REG</dfn>		4		/* regular file */</u></td></tr>
<tr><th id="129">129</th><td><u>#define <dfn class="macro" id="_M/PAX_SLK" data-ref="_M/PAX_SLK">PAX_SLK</dfn>		5		/* symbolic link */</u></td></tr>
<tr><th id="130">130</th><td><u>#define <dfn class="macro" id="_M/PAX_SCK" data-ref="_M/PAX_SCK">PAX_SCK</dfn>		6		/* socket */</u></td></tr>
<tr><th id="131">131</th><td><u>#define <dfn class="macro" id="_M/PAX_FIF" data-ref="_M/PAX_FIF">PAX_FIF</dfn>		7		/* fifo */</u></td></tr>
<tr><th id="132">132</th><td><u>#define <dfn class="macro" id="_M/PAX_HLK" data-ref="_M/PAX_HLK">PAX_HLK</dfn>		8		/* hard link */</u></td></tr>
<tr><th id="133">133</th><td><u>#define <dfn class="macro" id="_M/PAX_HRG" data-ref="_M/PAX_HRG">PAX_HRG</dfn>		9		/* hard link to a regular file */</u></td></tr>
<tr><th id="134">134</th><td><u>#define <dfn class="macro" id="_M/PAX_CTG" data-ref="_M/PAX_CTG">PAX_CTG</dfn>		10		/* high performance file */</u></td></tr>
<tr><th id="135">135</th><td><u>#define <dfn class="macro" id="_M/PAX_GLL" data-ref="_M/PAX_GLL">PAX_GLL</dfn>		11		/* GNU long symlink */</u></td></tr>
<tr><th id="136">136</th><td><u>#define <dfn class="macro" id="_M/PAX_GLF" data-ref="_M/PAX_GLF">PAX_GLF</dfn>		12		/* GNU long file */</u></td></tr>
<tr><th id="137">137</th><td>} <dfn class="typedef" id="ARCHD" title='ARCHD' data-type='struct ARCHD' data-ref="ARCHD" data-ref-filename="ARCHD">ARCHD</dfn>;</td></tr>
<tr><th id="138">138</th><td></td></tr>
<tr><th id="139">139</th><td><i>/*</i></td></tr>
<tr><th id="140">140</th><td><i> * Format Specific Routine Table</i></td></tr>
<tr><th id="141">141</th><td><i> *</i></td></tr>
<tr><th id="142">142</th><td><i> * The format specific routine table allows new archive formats to be quickly</i></td></tr>
<tr><th id="143">143</th><td><i> * added. Overall pax operation is independent of the actual format used to</i></td></tr>
<tr><th id="144">144</th><td><i> * form the archive. Only those routines which deal directly with the archive</i></td></tr>
<tr><th id="145">145</th><td><i> * are tailored to the oddities of the specific format. All other routines are</i></td></tr>
<tr><th id="146">146</th><td><i> * independent of the archive format. Data flow in and out of the format</i></td></tr>
<tr><th id="147">147</th><td><i> * dependent routines pass pointers to ARCHD structure (described below).</i></td></tr>
<tr><th id="148">148</th><td><i> */</i></td></tr>
<tr><th id="149">149</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="150">150</th><td>	<em>const</em> <em>char</em> *<dfn class="decl field" id="(anonymous)::name" title='(anonymous struct)::name' data-ref="(anonymous)::name" data-ref-filename="(anonymous)..name">name</dfn>;	<i>/* name of format, this is the name the user */</i></td></tr>
<tr><th id="151">151</th><td>				<i>/* gives to -x option to select it. */</i></td></tr>
<tr><th id="152">152</th><td>	<em>int</em> <dfn class="decl field" id="(anonymous)::bsz" title='(anonymous struct)::bsz' data-ref="(anonymous)::bsz" data-ref-filename="(anonymous)..bsz">bsz</dfn>;		<i>/* default block size. used when the user */</i></td></tr>
<tr><th id="153">153</th><td>				<i>/* does not specify a blocksize for writing */</i></td></tr>
<tr><th id="154">154</th><td>				<i>/* Appends continue to with the blocksize */</i></td></tr>
<tr><th id="155">155</th><td>				<i>/* the archive is currently using.*/</i></td></tr>
<tr><th id="156">156</th><td>	<em>int</em> <dfn class="decl field" id="(anonymous)::hsz" title='(anonymous struct)::hsz' data-ref="(anonymous)::hsz" data-ref-filename="(anonymous)..hsz">hsz</dfn>;		<i>/* Header size in bytes. this is the size of */</i></td></tr>
<tr><th id="157">157</th><td>				<i>/* the smallest header this format supports. */</i></td></tr>
<tr><th id="158">158</th><td>				<i>/* Headers are assumed to fit in a BLKMULT. */</i></td></tr>
<tr><th id="159">159</th><td>				<i>/* If they are bigger, get_head() and */</i></td></tr>
<tr><th id="160">160</th><td>				<i>/* get_arc() must be adjusted */</i></td></tr>
<tr><th id="161">161</th><td>	<em>int</em> <dfn class="decl field" id="(anonymous)::udev" title='(anonymous struct)::udev' data-ref="(anonymous)::udev" data-ref-filename="(anonymous)..udev">udev</dfn>;		<i>/* does append require unique dev/ino? some */</i></td></tr>
<tr><th id="162">162</th><td>				<i>/* formats use the device and inode fields */</i></td></tr>
<tr><th id="163">163</th><td>				<i>/* to specify hard links. when members in */</i></td></tr>
<tr><th id="164">164</th><td>				<i>/* the archive have the same inode/dev they */</i></td></tr>
<tr><th id="165">165</th><td>				<i>/* are assumed to be hard links. During */</i></td></tr>
<tr><th id="166">166</th><td>				<i>/* append we may have to generate unique ids */</i></td></tr>
<tr><th id="167">167</th><td>				<i>/* to avoid creating incorrect hard links */</i></td></tr>
<tr><th id="168">168</th><td>	<em>int</em> <dfn class="decl field" id="(anonymous)::hlk" title='(anonymous struct)::hlk' data-ref="(anonymous)::hlk" data-ref-filename="(anonymous)..hlk">hlk</dfn>;		<i>/* does archive store hard links info? if */</i></td></tr>
<tr><th id="169">169</th><td>				<i>/* not, we do not bother to look for them */</i></td></tr>
<tr><th id="170">170</th><td>				<i>/* during archive write operations */</i></td></tr>
<tr><th id="171">171</th><td>	<em>int</em> <dfn class="decl field" id="(anonymous)::blkalgn" title='(anonymous struct)::blkalgn' data-ref="(anonymous)::blkalgn" data-ref-filename="(anonymous)..blkalgn">blkalgn</dfn>;		<i>/* writes must be aligned to blkalgn boundary */</i></td></tr>
<tr><th id="172">172</th><td>	<em>int</em> <dfn class="decl field" id="(anonymous)::inhead" title='(anonymous struct)::inhead' data-ref="(anonymous)::inhead" data-ref-filename="(anonymous)..inhead">inhead</dfn>;		<i>/* is the trailer encoded in a valid header? */</i></td></tr>
<tr><th id="173">173</th><td>				<i>/* if not, trailers are assumed to be found */</i></td></tr>
<tr><th id="174">174</th><td>				<i>/* in invalid headers (i.e like tar) */</i></td></tr>
<tr><th id="175">175</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::id" title='(anonymous struct)::id' data-ref="(anonymous)::id" data-ref-filename="(anonymous)..id">id</dfn>)(<em>char</em> *, <em>int</em>);	<i>/* checks if a buffer is a valid header */</i></td></tr>
<tr><th id="176">176</th><td>				<i>/* returns 1 if it is, o.w. returns a 0 */</i></td></tr>
<tr><th id="177">177</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::st_rd" title='(anonymous struct)::st_rd' data-ref="(anonymous)::st_rd" data-ref-filename="(anonymous)..st_rd">st_rd</dfn>)(<em>void</em>);	<i>/* initialize routine for read. so format */</i></td></tr>
<tr><th id="178">178</th><td>				<i>/* can set up tables etc before it starts */</i></td></tr>
<tr><th id="179">179</th><td>				<i>/* reading an archive */</i></td></tr>
<tr><th id="180">180</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::rd" title='(anonymous struct)::rd' data-ref="(anonymous)::rd" data-ref-filename="(anonymous)..rd">rd</dfn>)		<i>/* read header routine. passed a pointer to */</i></td></tr>
<tr><th id="181">181</th><td>		(<a class="typedef" href="#ARCHD" title='ARCHD' data-type='struct ARCHD' data-ref="ARCHD" data-ref-filename="ARCHD">ARCHD</a> *, <em>char</em> *); <i>/* ARCHD. It must extract the info */</i></td></tr>
<tr><th id="182">182</th><td>				<i>/* from the format and store it in the  ARCHD */</i></td></tr>
<tr><th id="183">183</th><td>				<i>/* struct. This routine is expected to fill */</i></td></tr>
<tr><th id="184">184</th><td>				<i>/* all the fields in the ARCHD (including */</i></td></tr>
<tr><th id="185">185</th><td>				<i>/* stat buf). 0 is returned when a valid */</i></td></tr>
<tr><th id="186">186</th><td>				<i>/* header is found. -1 when not valid. This */</i></td></tr>
<tr><th id="187">187</th><td>				<i>/* routine set the skip and pad fields so the */</i></td></tr>
<tr><th id="188">188</th><td>				<i>/* format independent routines know the */</i></td></tr>
<tr><th id="189">189</th><td>				<i>/* amount of padding and the number of bytes */</i></td></tr>
<tr><th id="190">190</th><td>				<i>/* of data which follow the header. This info */</i></td></tr>
<tr><th id="191">191</th><td>				<i>/* is used to skip to the next file header */</i></td></tr>
<tr><th id="192">192</th><td>	<a class="macro" href="../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#178" title="__off_t" data-ref="_M/off_t">off_t</a> (*<dfn class="decl field" id="(anonymous)::end_rd" title='(anonymous struct)::end_rd' data-ref="(anonymous)::end_rd" data-ref-filename="(anonymous)..end_rd">end_rd</dfn>)(<em>void</em>);	<i>/* read cleanup. Allows format to clean up */</i></td></tr>
<tr><th id="193">193</th><td>				<i>/* and MUST RETURN THE LENGTH OF THE TRAILER */</i></td></tr>
<tr><th id="194">194</th><td>				<i>/* RECORD (so append knows how many bytes */</i></td></tr>
<tr><th id="195">195</th><td>				<i>/* to move back to rewrite the trailer) */</i></td></tr>
<tr><th id="196">196</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::st_wr" title='(anonymous struct)::st_wr' data-ref="(anonymous)::st_wr" data-ref-filename="(anonymous)..st_wr">st_wr</dfn>)(<em>void</em>);	<i>/* initialize routine for write operations */</i></td></tr>
<tr><th id="197">197</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::wr" title='(anonymous struct)::wr' data-ref="(anonymous)::wr" data-ref-filename="(anonymous)..wr">wr</dfn>)(<a class="typedef" href="#ARCHD" title='ARCHD' data-type='struct ARCHD' data-ref="ARCHD" data-ref-filename="ARCHD">ARCHD</a> *);	<i>/* write archive header. Passed an ARCHD */</i></td></tr>
<tr><th id="198">198</th><td>				<i>/* filled with the specs on the next file to */</i></td></tr>
<tr><th id="199">199</th><td>				<i>/* archived. Returns a 1 if no file data is */</i></td></tr>
<tr><th id="200">200</th><td>				<i>/* is to be stored; 0 if file data is to be */</i></td></tr>
<tr><th id="201">201</th><td>				<i>/* added. A -1 is returned if a write */</i></td></tr>
<tr><th id="202">202</th><td>				<i>/* operation to the archive failed. this */</i></td></tr>
<tr><th id="203">203</th><td>				<i>/* function sets the skip and pad fields so */</i></td></tr>
<tr><th id="204">204</th><td>				<i>/* the proper padding can be added after */</i></td></tr>
<tr><th id="205">205</th><td>				<i>/* file data. This routine must NEVER write */</i></td></tr>
<tr><th id="206">206</th><td>				<i>/* a flawed archive header. */</i></td></tr>
<tr><th id="207">207</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::end_wr" title='(anonymous struct)::end_wr' data-ref="(anonymous)::end_wr" data-ref-filename="(anonymous)..end_wr">end_wr</dfn>)(<em>void</em>);	<i>/* end write. write the trailer and do any */</i></td></tr>
<tr><th id="208">208</th><td>				<i>/* other format specific functions needed */</i></td></tr>
<tr><th id="209">209</th><td>				<i>/* at the end of an archive write */</i></td></tr>
<tr><th id="210">210</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::trail" title='(anonymous struct)::trail' data-ref="(anonymous)::trail" data-ref-filename="(anonymous)..trail">trail</dfn>)		<i>/* returns 0 if a valid trailer, -1 if not */</i></td></tr>
<tr><th id="211">211</th><td>		(<em>char</em> *, <em>int</em>, <em>int</em> *); <i>/* For formats which encode the */</i></td></tr>
<tr><th id="212">212</th><td>				<i>/* trailer outside of a valid header, a */</i></td></tr>
<tr><th id="213">213</th><td>				<i>/* return value of 1 indicates that the block */</i></td></tr>
<tr><th id="214">214</th><td>				<i>/* passed to it can never contain a valid */</i></td></tr>
<tr><th id="215">215</th><td>				<i>/* header (skip this block, no point in */</i></td></tr>
<tr><th id="216">216</th><td>				<i>/* looking at it) */</i></td></tr>
<tr><th id="217">217</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::subtrail" title='(anonymous struct)::subtrail' data-ref="(anonymous)::subtrail" data-ref-filename="(anonymous)..subtrail">subtrail</dfn>)		<i>/* read/process file data from the archive */</i></td></tr>
<tr><th id="218">218</th><td>		(<a class="typedef" href="#ARCHD" title='ARCHD' data-type='struct ARCHD' data-ref="ARCHD" data-ref-filename="ARCHD">ARCHD</a> *);	<i>/* this function is called for trailers */</i></td></tr>
<tr><th id="219">219</th><td>				<i>/* inside headers. */</i></td></tr>
<tr><th id="220">220</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::rd_data" title='(anonymous struct)::rd_data' data-ref="(anonymous)::rd_data" data-ref-filename="(anonymous)..rd_data">rd_data</dfn>)		<i>/* read/process file data from the archive */</i></td></tr>
<tr><th id="221">221</th><td>		(<a class="typedef" href="#ARCHD" title='ARCHD' data-type='struct ARCHD' data-ref="ARCHD" data-ref-filename="ARCHD">ARCHD</a> *, <em>int</em>, <a class="macro" href="../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#178" title="__off_t" data-ref="_M/off_t">off_t</a> *);</td></tr>
<tr><th id="222">222</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::wr_data" title='(anonymous struct)::wr_data' data-ref="(anonymous)::wr_data" data-ref-filename="(anonymous)..wr_data">wr_data</dfn>)		<i>/* write/process file data to the archive */</i></td></tr>
<tr><th id="223">223</th><td>		(<a class="typedef" href="#ARCHD" title='ARCHD' data-type='struct ARCHD' data-ref="ARCHD" data-ref-filename="ARCHD">ARCHD</a> *, <em>int</em>, <a class="macro" href="../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#178" title="__off_t" data-ref="_M/off_t">off_t</a> *);</td></tr>
<tr><th id="224">224</th><td>	<em>int</em> (*<dfn class="decl field" id="(anonymous)::options" title='(anonymous struct)::options' data-ref="(anonymous)::options" data-ref-filename="(anonymous)..options">options</dfn>)(<em>void</em>);	<i>/* process format specific options (-o) */</i></td></tr>
<tr><th id="225">225</th><td>} <dfn class="typedef" id="FSUB" title='FSUB' data-type='struct FSUB' data-ref="FSUB" data-ref-filename="FSUB">FSUB</dfn>;</td></tr>
<tr><th id="226">226</th><td></td></tr>
<tr><th id="227">227</th><td><i>/*</i></td></tr>
<tr><th id="228">228</th><td><i> * Format Specific Options List</i></td></tr>
<tr><th id="229">229</th><td><i> *</i></td></tr>
<tr><th id="230">230</th><td><i> * Used to pass format options to the format options handler</i></td></tr>
<tr><th id="231">231</th><td><i> */</i></td></tr>
<tr><th id="232">232</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="oplist" title='oplist' data-ref="oplist" data-ref-filename="oplist"><a class="type" href="#oplist" title='oplist' data-ref="oplist" data-ref-filename="oplist">oplist</a></dfn> {</td></tr>
<tr><th id="233">233</th><td>	<em>char</em>		*<dfn class="decl field" id="oplist::name" title='oplist::name' data-ref="oplist::name" data-ref-filename="oplist..name">name</dfn>;		<i>/* option variable name e.g. name= */</i></td></tr>
<tr><th id="234">234</th><td>	<em>char</em>		*<dfn class="decl field" id="oplist::value" title='oplist::value' data-ref="oplist::value" data-ref-filename="oplist..value">value</dfn>;		<i>/* value for option variable */</i></td></tr>
<tr><th id="235">235</th><td>	<b>struct</b> <a class="type" href="#oplist" title='oplist' data-ref="oplist" data-ref-filename="oplist">oplist</a>	*<dfn class="decl field" id="oplist::fow" title='oplist::fow' data-ref="oplist::fow" data-ref-filename="oplist..fow">fow</dfn>;		<i>/* next option */</i></td></tr>
<tr><th id="236">236</th><td>} <dfn class="typedef" id="OPLIST" title='OPLIST' data-type='struct oplist' data-ref="OPLIST" data-ref-filename="OPLIST">OPLIST</dfn>;</td></tr>
<tr><th id="237">237</th><td></td></tr>
<tr><th id="238">238</th><td><i>/*</i></td></tr>
<tr><th id="239">239</th><td><i> * General Macros</i></td></tr>
<tr><th id="240">240</th><td><i> */</i></td></tr>
<tr><th id="241">241</th><td><u>#<span data-ppcond="241">ifndef</span> <a class="macro" href="../../objdir.amd64/destdir.amd64/usr/include/sys/param.h.html#138" data-ref="_M/MIN">MIN</a></u></td></tr>
<tr><th id="242">242</th><td><u>#define        MIN(a,b) (((a)&lt;(b))?(a):(b))</u></td></tr>
<tr><th id="243">243</th><td><u>#<span data-ppcond="241">endif</span></u></td></tr>
<tr><th id="244">244</th><td></td></tr>
<tr><th id="245">245</th><td><u>#<span data-ppcond="245">ifdef</span> <span class="macro" data-ref="_M/HOSTPROG">HOSTPROG</span></u></td></tr>
<tr><th id="246">246</th><td><u># include "pack_dev.h"			/* explicitly use NetBSD's macros */</u></td></tr>
<tr><th id="247">247</th><td><u># define MAJOR(x)	major_netbsd(x)</u></td></tr>
<tr><th id="248">248</th><td><u># define MINOR(x)	minor_netbsd(x)</u></td></tr>
<tr><th id="249">249</th><td><u># define TODEV(x, y)	makedev_netbsd((x), (y))</u></td></tr>
<tr><th id="250">250</th><td><u>#<span data-ppcond="245">else</span></u></td></tr>
<tr><th id="251">251</th><td><u># define <dfn class="macro" id="_M/MAJOR" data-ref="_M/MAJOR">MAJOR</dfn>(x)	major(x)</u></td></tr>
<tr><th id="252">252</th><td><u># define <dfn class="macro" id="_M/MINOR" data-ref="_M/MINOR">MINOR</dfn>(x)	minor(x)</u></td></tr>
<tr><th id="253">253</th><td><u># define <dfn class="macro" id="_M/TODEV" data-ref="_M/TODEV">TODEV</dfn>(x, y)	makedev((x), (y))</u></td></tr>
<tr><th id="254">254</th><td><u>#<span data-ppcond="245">endif</span></u></td></tr>
<tr><th id="255">255</th><td></td></tr>
<tr><th id="256">256</th><td><i>/*</i></td></tr>
<tr><th id="257">257</th><td><i> * General Defines</i></td></tr>
<tr><th id="258">258</th><td><i> */</i></td></tr>
<tr><th id="259">259</th><td><u>#define <dfn class="macro" id="_M/HEX" data-ref="_M/HEX">HEX</dfn>	16</u></td></tr>
<tr><th id="260">260</th><td><u>#define <dfn class="macro" id="_M/OCT" data-ref="_M/OCT">OCT</dfn>	8</u></td></tr>
<tr><th id="261">261</th><td><u>#define <dfn class="macro" id="_M/_PAX_" data-ref="_M/_PAX_">_PAX_</dfn>	1</u></td></tr>
<tr><th id="262">262</th><td></td></tr>
<tr><th id="263">263</th><td><i>/*</i></td></tr>
<tr><th id="264">264</th><td><i> * Pathname base component of the temporary file template, to be created in</i></td></tr>
<tr><th id="265">265</th><td><i> * ${TMPDIR} or, as a fall-back, _PATH_TMP.</i></td></tr>
<tr><th id="266">266</th><td><i> */</i></td></tr>
<tr><th id="267">267</th><td><u>#define <dfn class="macro" id="_M/_TFILE_BASE" data-ref="_M/_TFILE_BASE">_TFILE_BASE</dfn>	"paxXXXXXXXXXX"</u></td></tr>
<tr><th id="268">268</th><td></td></tr>
<tr><th id="269">269</th><td><i>/*</i></td></tr>
<tr><th id="270">270</th><td><i> * Macros to manipulate off_t as uintmax_t</i></td></tr>
<tr><th id="271">271</th><td><i> */</i></td></tr>
<tr><th id="272">272</th><td><u>#define	<dfn class="macro" id="_M/OFFT_F" data-ref="_M/OFFT_F">OFFT_F</dfn>			"%" PRIuMAX</u></td></tr>
<tr><th id="273">273</th><td><u>#define	<dfn class="macro" id="_M/OFFT_FP" data-ref="_M/OFFT_FP">OFFT_FP</dfn>(x)		"%" x PRIuMAX</u></td></tr>
<tr><th id="274">274</th><td><u>#define	<dfn class="macro" id="_M/OFFT_T" data-ref="_M/OFFT_T">OFFT_T</dfn>			uintmax_t</u></td></tr>
<tr><th id="275">275</th><td><u>#define	<dfn class="macro" id="_M/ASC_OFFT" data-ref="_M/ASC_OFFT">ASC_OFFT</dfn>(x,y,z)		asc_umax(x,y,z)</u></td></tr>
<tr><th id="276">276</th><td><u>#define	<dfn class="macro" id="_M/OFFT_ASC" data-ref="_M/OFFT_ASC">OFFT_ASC</dfn>(w,x,y,z)	umax_asc((uintmax_t)w,x,y,z)</u></td></tr>
<tr><th id="277">277</th><td><u>#define	<dfn class="macro" id="_M/OFFT_OCT" data-ref="_M/OFFT_OCT">OFFT_OCT</dfn>(w,x,y,z)	umax_oct((uintmax_t)w,x,y,z)</u></td></tr>
<tr><th id="278">278</th><td><u>#define	<dfn class="macro" id="_M/STRTOOFFT" data-ref="_M/STRTOOFFT">STRTOOFFT</dfn>(x,y,z)	strtoimax(x,y,z)</u></td></tr>
<tr><th id="279">279</th><td><u>#define	<dfn class="macro" id="_M/OFFT_MAX" data-ref="_M/OFFT_MAX">OFFT_MAX</dfn>		INTMAX_MAX</u></td></tr>
<tr><th id="280">280</th><td></td></tr>
<tr><th id="281">281</th><td><u>#define <dfn class="macro" id="_M/TOP_HALF" data-ref="_M/TOP_HALF">TOP_HALF</dfn>	0xffffffff00000000ULL</u></td></tr>
<tr><th id="282">282</th><td><u>#define <dfn class="macro" id="_M/BOTTOM_HALF" data-ref="_M/BOTTOM_HALF">BOTTOM_HALF</dfn>	0x00000000ffffffffULL</u></td></tr>
<tr><th id="283">283</th><td></td></tr>
<tr><th id="284">284</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='ar_io.c.html'>netbsd/bin/pax/ar_io.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
