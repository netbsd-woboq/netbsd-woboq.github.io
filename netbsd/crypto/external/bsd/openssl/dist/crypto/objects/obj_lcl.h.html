<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>obj_lcl.h source code [netbsd/crypto/external/bsd/openssl/dist/crypto/objects/obj_lcl.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/crypto/external/bsd/openssl/dist/crypto/objects/obj_lcl.h'; var root_path = '../../../../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../../../..'>netbsd</a>/<a href='../../../../../..'>crypto</a>/<a href='../../../../..'>external</a>/<a href='../../../..'>bsd</a>/<a href='../../..'>openssl</a>/<a href='../..'>dist</a>/<a href='..'>crypto</a>/<a href='./'>objects</a>/<a href='obj_lcl.h.html'>obj_lcl.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*</i></td></tr>
<tr><th id="2">2</th><td><i> * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.</i></td></tr>
<tr><th id="3">3</th><td><i> *</i></td></tr>
<tr><th id="4">4</th><td><i> * Licensed under the OpenSSL license (the "License").  You may not use</i></td></tr>
<tr><th id="5">5</th><td><i> * this file except in compliance with the License.  You can obtain a copy</i></td></tr>
<tr><th id="6">6</th><td><i> * in the file LICENSE in the source distribution or at</i></td></tr>
<tr><th id="7">7</th><td><i> * <a href="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</a></i></td></tr>
<tr><th id="8">8</th><td><i> */</i></td></tr>
<tr><th id="9">9</th><td></td></tr>
<tr><th id="10">10</th><td><b>typedef</b> <b>struct</b> <a class="type" href="o_names.c.html#name_funcs_st" title='name_funcs_st' data-ref="name_funcs_st" data-ref-filename="name_funcs_st" id="name_funcs_st"><a class="type" href="o_names.c.html#name_funcs_st" title='name_funcs_st' data-ref="name_funcs_st" data-ref-filename="name_funcs_st">name_funcs_st</a></a> <dfn class="typedef" id="NAME_FUNCS" title='NAME_FUNCS' data-type='struct name_funcs_st' data-ref="NAME_FUNCS" data-ref-filename="NAME_FUNCS">NAME_FUNCS</dfn>;</td></tr>
<tr><th id="11">11</th><td><a class="macro" href="../../include/openssl/safestack.h.html#130" title="struct stack_st_NAME_FUNCS; typedef int (*sk_NAME_FUNCS_compfunc)(const NAME_FUNCS * const *a, const NAME_FUNCS *const *b); typedef void (*sk_NAME_FUNCS_freefunc)(NAME_FUNCS *a); typedef NAME_FUNCS * (*sk_NAME_FUNCS_copyfunc)(const NAME_FUNCS *a); static __attribute__((unused)) inline int sk_NAME_FUNCS_num(const struct stack_st_NAME_FUNCS *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)(const void *)sk); } static __attribute__((unused)) inline NAME_FUNCS *sk_NAME_FUNCS_value(const struct stack_st_NAME_FUNCS *sk, int idx) { return (NAME_FUNCS *)(void *)OPENSSL_sk_value((const OPENSSL_STACK *)(const void *)sk, idx); } static __attribute__((unused)) inline struct stack_st_NAME_FUNCS *sk_NAME_FUNCS_new(sk_NAME_FUNCS_compfunc compare) { return (struct stack_st_NAME_FUNCS *)(void *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); } static __attribute__((unused)) inline struct stack_st_NAME_FUNCS *sk_NAME_FUNCS_new_null(void) { return (struct stack_st_NAME_FUNCS *)(void *)OPENSSL_sk_new_null(); } static __attribute__((unused)) inline struct stack_st_NAME_FUNCS *sk_NAME_FUNCS_new_reserve(sk_NAME_FUNCS_compfunc compare, int n) { return (struct stack_st_NAME_FUNCS *)(void *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); } static __attribute__((unused)) inline int sk_NAME_FUNCS_reserve(struct stack_st_NAME_FUNCS *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)(void *)sk, n); } static __attribute__((unused)) inline void sk_NAME_FUNCS_free(struct stack_st_NAME_FUNCS *sk) { OPENSSL_sk_free((OPENSSL_STACK *)(void *)sk); } static __attribute__((unused)) inline void sk_NAME_FUNCS_zero(struct stack_st_NAME_FUNCS *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)(void *)sk); } static __attribute__((unused)) inline NAME_FUNCS *sk_NAME_FUNCS_delete(struct stack_st_NAME_FUNCS *sk, int i) { return (NAME_FUNCS *)(void *)OPENSSL_sk_delete((OPENSSL_STACK *)(void *)sk, i); } static __attribute__((unused)) inline NAME_FUNCS *sk_NAME_FUNCS_delete_ptr(struct stack_st_NAME_FUNCS *sk, NAME_FUNCS *ptr) { return (NAME_FUNCS *)(void *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)(void *)sk, (const void *)ptr); } static __attribute__((unused)) inline int sk_NAME_FUNCS_push(struct stack_st_NAME_FUNCS *sk, NAME_FUNCS *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)(void *)sk, (const void *)ptr); } static __attribute__((unused)) inline int sk_NAME_FUNCS_unshift(struct stack_st_NAME_FUNCS *sk, NAME_FUNCS *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)(void *)sk, (const void *)ptr); } static __attribute__((unused)) inline NAME_FUNCS *sk_NAME_FUNCS_pop(struct stack_st_NAME_FUNCS *sk) { return (NAME_FUNCS *)(void *)OPENSSL_sk_pop((OPENSSL_STACK *)(void *)sk); } static __attribute__((unused)) inline NAME_FUNCS *sk_NAME_FUNCS_shift(struct stack_st_NAME_FUNCS *sk) { return (NAME_FUNCS *)(void *)OPENSSL_sk_shift((OPENSSL_STACK *)(void *)sk); } static __attribute__((unused)) inline void sk_NAME_FUNCS_pop_free(struct stack_st_NAME_FUNCS *sk, sk_NAME_FUNCS_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)(void *)sk, (OPENSSL_sk_freefunc)freefunc); } static __attribute__((unused)) inline int sk_NAME_FUNCS_insert(struct stack_st_NAME_FUNCS *sk, NAME_FUNCS *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)(void *)sk, (const void *)ptr, idx); } static __attribute__((unused)) inline NAME_FUNCS *sk_NAME_FUNCS_set(struct stack_st_NAME_FUNCS *sk, int idx, NAME_FUNCS *ptr) { return (NAME_FUNCS *)(void *)OPENSSL_sk_set((OPENSSL_STACK *)(void *)sk, idx, (const void *)ptr); } static __attribute__((unused)) inline int sk_NAME_FUNCS_find(struct stack_st_NAME_FUNCS *sk, NAME_FUNCS *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)(void *)sk, (const void *)ptr); } static __attribute__((unused)) inline int sk_NAME_FUNCS_find_ex(struct stack_st_NAME_FUNCS *sk, NAME_FUNCS *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)(void *)sk, (const void *)ptr); } static __attribute__((unused)) inline void sk_NAME_FUNCS_sort(struct stack_st_NAME_FUNCS *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)(void *)sk); } static __attribute__((unused)) inline int sk_NAME_FUNCS_is_sorted(const struct stack_st_NAME_FUNCS *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)(const void *)sk); } static __attribute__((unused)) inline struct stack_st_NAME_FUNCS * sk_NAME_FUNCS_dup(const struct stack_st_NAME_FUNCS *sk) { return (struct stack_st_NAME_FUNCS *)(void *)OPENSSL_sk_dup((const OPENSSL_STACK *)(const void *)sk); } static __attribute__((unused)) inline struct stack_st_NAME_FUNCS *sk_NAME_FUNCS_deep_copy(const struct stack_st_NAME_FUNCS *sk, sk_NAME_FUNCS_copyfunc copyfunc, sk_NAME_FUNCS_freefunc freefunc) { return (struct stack_st_NAME_FUNCS *)(void *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)(const void *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); } static __attribute__((unused)) inline sk_NAME_FUNCS_compfunc sk_NAME_FUNCS_set_cmp_func(struct stack_st_NAME_FUNCS *sk, sk_NAME_FUNCS_compfunc compare) { return (sk_NAME_FUNCS_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)(void *)sk, (OPENSSL_sk_compfunc)compare); }" data-ref="_M/DEFINE_STACK_OF">DEFINE_STACK_OF</a>(<a class="typedef" href="#NAME_FUNCS" title='NAME_FUNCS' data-type='struct name_funcs_st' data-ref="NAME_FUNCS" data-ref-filename="NAME_FUNCS">NAME_FUNCS</a>)</td></tr>
<tr><th id="12">12</th><td><a class="macro" href="../../include/openssl/lhash.h.html#121" title="struct lhash_st_OBJ_NAME { union lh_OBJ_NAME_dummy { void* d1; unsigned long d2; int d3; } dummy; }; static inline struct lhash_st_OBJ_NAME * lh_OBJ_NAME_new(unsigned long (*hfn)(const OBJ_NAME *), int (*cfn)(const OBJ_NAME *, const OBJ_NAME *)) { return (struct lhash_st_OBJ_NAME *) OPENSSL_LH_new((OPENSSL_LH_HASHFUNC)hfn, (OPENSSL_LH_COMPFUNC)cfn); } static __attribute__((unused)) inline void lh_OBJ_NAME_free(struct lhash_st_OBJ_NAME *lh) { OPENSSL_LH_free((OPENSSL_LHASH *)lh); } static __attribute__((unused)) inline OBJ_NAME *lh_OBJ_NAME_insert(struct lhash_st_OBJ_NAME *lh, OBJ_NAME *d) { return (OBJ_NAME *)OPENSSL_LH_insert((OPENSSL_LHASH *)lh, d); } static __attribute__((unused)) inline OBJ_NAME *lh_OBJ_NAME_delete(struct lhash_st_OBJ_NAME *lh, const OBJ_NAME *d) { return (OBJ_NAME *)OPENSSL_LH_delete((OPENSSL_LHASH *)lh, d); } static __attribute__((unused)) inline OBJ_NAME *lh_OBJ_NAME_retrieve(struct lhash_st_OBJ_NAME *lh, const OBJ_NAME *d) { return (OBJ_NAME *)OPENSSL_LH_retrieve((OPENSSL_LHASH *)lh, d); } static __attribute__((unused)) inline int lh_OBJ_NAME_error(struct lhash_st_OBJ_NAME *lh) { return OPENSSL_LH_error((OPENSSL_LHASH *)lh); } static __attribute__((unused)) inline unsigned long lh_OBJ_NAME_num_items(struct lhash_st_OBJ_NAME *lh) { return OPENSSL_LH_num_items((OPENSSL_LHASH *)lh); } static __attribute__((unused)) inline void lh_OBJ_NAME_node_stats_bio(const struct lhash_st_OBJ_NAME *lh, BIO *out) { OPENSSL_LH_node_stats_bio((const OPENSSL_LHASH *)lh, out); } static __attribute__((unused)) inline void lh_OBJ_NAME_node_usage_stats_bio(const struct lhash_st_OBJ_NAME *lh, BIO *out) { OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH *)lh, out); } static __attribute__((unused)) inline void lh_OBJ_NAME_stats_bio(const struct lhash_st_OBJ_NAME *lh, BIO *out) { OPENSSL_LH_stats_bio((const OPENSSL_LHASH *)lh, out); } static __attribute__((unused)) inline unsigned long lh_OBJ_NAME_get_down_load(struct lhash_st_OBJ_NAME *lh) { return OPENSSL_LH_get_down_load((OPENSSL_LHASH *)lh); } static __attribute__((unused)) inline void lh_OBJ_NAME_set_down_load(struct lhash_st_OBJ_NAME *lh, unsigned long dl) { OPENSSL_LH_set_down_load((OPENSSL_LHASH *)lh, dl); } static __attribute__((unused)) inline void lh_OBJ_NAME_doall(struct lhash_st_OBJ_NAME *lh, void (*doall)(OBJ_NAME *)) { OPENSSL_LH_doall((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNC)doall); } struct lhash_st_OBJ_NAME" data-ref="_M/DEFINE_LHASH_OF">DEFINE_LHASH_OF</a>(<a class="typedef" href="../../include/openssl/objects.h.html#OBJ_NAME" title='OBJ_NAME' data-type='struct obj_name_st' data-ref="OBJ_NAME" data-ref-filename="OBJ_NAME">OBJ_NAME</a>);</td></tr>
<tr><th id="13">13</th><td><b>typedef</b> <b>struct</b> <dfn class="type" id="added_obj_st" title='added_obj_st' data-ref="added_obj_st" data-ref-filename="added_obj_st"><a class="type" href="#added_obj_st" title='added_obj_st' data-ref="added_obj_st" data-ref-filename="added_obj_st">added_obj_st</a></dfn> <dfn class="typedef" id="ADDED_OBJ" title='ADDED_OBJ' data-type='struct added_obj_st' data-ref="ADDED_OBJ" data-ref-filename="ADDED_OBJ">ADDED_OBJ</dfn>;</td></tr>
<tr><th id="14">14</th><td><a class="macro" href="../../include/openssl/lhash.h.html#121" title="struct lhash_st_ADDED_OBJ { union lh_ADDED_OBJ_dummy { void* d1; unsigned long d2; int d3; } dummy; }; static inline struct lhash_st_ADDED_OBJ * lh_ADDED_OBJ_new(unsigned long (*hfn)(const ADDED_OBJ *), int (*cfn)(const ADDED_OBJ *, const ADDED_OBJ *)) { return (struct lhash_st_ADDED_OBJ *) OPENSSL_LH_new((OPENSSL_LH_HASHFUNC)hfn, (OPENSSL_LH_COMPFUNC)cfn); } static __attribute__((unused)) inline void lh_ADDED_OBJ_free(struct lhash_st_ADDED_OBJ *lh) { OPENSSL_LH_free((OPENSSL_LHASH *)lh); } static __attribute__((unused)) inline ADDED_OBJ *lh_ADDED_OBJ_insert(struct lhash_st_ADDED_OBJ *lh, ADDED_OBJ *d) { return (ADDED_OBJ *)OPENSSL_LH_insert((OPENSSL_LHASH *)lh, d); } static __attribute__((unused)) inline ADDED_OBJ *lh_ADDED_OBJ_delete(struct lhash_st_ADDED_OBJ *lh, const ADDED_OBJ *d) { return (ADDED_OBJ *)OPENSSL_LH_delete((OPENSSL_LHASH *)lh, d); } static __attribute__((unused)) inline ADDED_OBJ *lh_ADDED_OBJ_retrieve(struct lhash_st_ADDED_OBJ *lh, const ADDED_OBJ *d) { return (ADDED_OBJ *)OPENSSL_LH_retrieve((OPENSSL_LHASH *)lh, d); } static __attribute__((unused)) inline int lh_ADDED_OBJ_error(struct lhash_st_ADDED_OBJ *lh) { return OPENSSL_LH_error((OPENSSL_LHASH *)lh); } static __attribute__((unused)) inline unsigned long lh_ADDED_OBJ_num_items(struct lhash_st_ADDED_OBJ *lh) { return OPENSSL_LH_num_items((OPENSSL_LHASH *)lh); } static __attribute__((unused)) inline void lh_ADDED_OBJ_node_stats_bio(const struct lhash_st_ADDED_OBJ *lh, BIO *out) { OPENSSL_LH_node_stats_bio((const OPENSSL_LHASH *)lh, out); } static __attribute__((unused)) inline void lh_ADDED_OBJ_node_usage_stats_bio(const struct lhash_st_ADDED_OBJ *lh, BIO *out) { OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH *)lh, out); } static __attribute__((unused)) inline void lh_ADDED_OBJ_stats_bio(const struct lhash_st_ADDED_OBJ *lh, BIO *out) { OPENSSL_LH_stats_bio((const OPENSSL_LHASH *)lh, out); } static __attribute__((unused)) inline unsigned long lh_ADDED_OBJ_get_down_load(struct lhash_st_ADDED_OBJ *lh) { return OPENSSL_LH_get_down_load((OPENSSL_LHASH *)lh); } static __attribute__((unused)) inline void lh_ADDED_OBJ_set_down_load(struct lhash_st_ADDED_OBJ *lh, unsigned long dl) { OPENSSL_LH_set_down_load((OPENSSL_LHASH *)lh, dl); } static __attribute__((unused)) inline void lh_ADDED_OBJ_doall(struct lhash_st_ADDED_OBJ *lh, void (*doall)(ADDED_OBJ *)) { OPENSSL_LH_doall((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNC)doall); } struct lhash_st_ADDED_OBJ" data-ref="_M/DEFINE_LHASH_OF">DEFINE_LHASH_OF</a>(<a class="typedef" href="#ADDED_OBJ" title='ADDED_OBJ' data-type='struct added_obj_st' data-ref="ADDED_OBJ" data-ref-filename="ADDED_OBJ">ADDED_OBJ</a>);</td></tr>
<tr><th id="15">15</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='o_names.c.html'>netbsd/crypto/external/bsd/openssl/dist/crypto/objects/o_names.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
