<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>pcap-int.h source code [netbsd/external/bsd/libpcap/dist/pcap-int.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="oneshot_userdata,pcap,pcap_opt,pcap_sf_patched_pkthdr,pcap_sf_pkthdr,pcap_timeval "/>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/external/bsd/libpcap/dist/pcap-int.h'; var root_path = '../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>netbsd</a>/<a href='../../..'>external</a>/<a href='../..'>bsd</a>/<a href='..'>libpcap</a>/<a href='./'>dist</a>/<a href='pcap-int.h.html'>pcap-int.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*	$NetBSD: pcap-int.h,v 1.5 2018/09/03 15:26:43 christos Exp $	*/</i></td></tr>
<tr><th id="2">2</th><td></td></tr>
<tr><th id="3">3</th><td><i>/*</i></td></tr>
<tr><th id="4">4</th><td><i> * Copyright (c) 1994, 1995, 1996</i></td></tr>
<tr><th id="5">5</th><td><i> *	The Regents of the University of California.  All rights reserved.</i></td></tr>
<tr><th id="6">6</th><td><i> *</i></td></tr>
<tr><th id="7">7</th><td><i> * Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="8">8</th><td><i> * modification, are permitted provided that the following conditions</i></td></tr>
<tr><th id="9">9</th><td><i> * are met:</i></td></tr>
<tr><th id="10">10</th><td><i> * 1. Redistributions of source code must retain the above copyright</i></td></tr>
<tr><th id="11">11</th><td><i> *    notice, this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="12">12</th><td><i> * 2. Redistributions in binary form must reproduce the above copyright</i></td></tr>
<tr><th id="13">13</th><td><i> *    notice, this list of conditions and the following disclaimer in the</i></td></tr>
<tr><th id="14">14</th><td><i> *    documentation and/or other materials provided with the distribution.</i></td></tr>
<tr><th id="15">15</th><td><i> * 3. All advertising materials mentioning features or use of this software</i></td></tr>
<tr><th id="16">16</th><td><i> *    must display the following acknowledgement:</i></td></tr>
<tr><th id="17">17</th><td><i> *	This product includes software developed by the Computer Systems</i></td></tr>
<tr><th id="18">18</th><td><i> *	Engineering Group at Lawrence Berkeley Laboratory.</i></td></tr>
<tr><th id="19">19</th><td><i> * 4. Neither the name of the University nor of the Laboratory may be used</i></td></tr>
<tr><th id="20">20</th><td><i> *    to endorse or promote products derived from this software without</i></td></tr>
<tr><th id="21">21</th><td><i> *    specific prior written permission.</i></td></tr>
<tr><th id="22">22</th><td><i> *</i></td></tr>
<tr><th id="23">23</th><td><i> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</i></td></tr>
<tr><th id="24">24</th><td><i> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</i></td></tr>
<tr><th id="25">25</th><td><i> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</i></td></tr>
<tr><th id="26">26</th><td><i> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</i></td></tr>
<tr><th id="27">27</th><td><i> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</i></td></tr>
<tr><th id="28">28</th><td><i> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</i></td></tr>
<tr><th id="29">29</th><td><i> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</i></td></tr>
<tr><th id="30">30</th><td><i> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</i></td></tr>
<tr><th id="31">31</th><td><i> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</i></td></tr>
<tr><th id="32">32</th><td><i> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</i></td></tr>
<tr><th id="33">33</th><td><i> * SUCH DAMAGE.</i></td></tr>
<tr><th id="34">34</th><td><i> */</i></td></tr>
<tr><th id="35">35</th><td></td></tr>
<tr><th id="36">36</th><td><u>#<span data-ppcond="36">ifndef</span> <span class="macro" data-ref="_M/pcap_int_h">pcap_int_h</span></u></td></tr>
<tr><th id="37">37</th><td><u>#define	<dfn class="macro" id="_M/pcap_int_h" data-ref="_M/pcap_int_h">pcap_int_h</dfn></u></td></tr>
<tr><th id="38">38</th><td></td></tr>
<tr><th id="39">39</th><td><u>#include <a href="../../../../objdir.amd64/destdir.amd64/usr/include/signal.h.html">&lt;signal.h&gt;</a></u></td></tr>
<tr><th id="40">40</th><td></td></tr>
<tr><th id="41">41</th><td><u>#include <a href="pcap/pcap.h.html">&lt;pcap/pcap.h&gt;</a></u></td></tr>
<tr><th id="42">42</th><td></td></tr>
<tr><th id="43">43</th><td><u>#include <a href="varattrs.h.html">"varattrs.h"</a></u></td></tr>
<tr><th id="44">44</th><td><u>#include <a href="fmtutils.h.html">"fmtutils.h"</a></u></td></tr>
<tr><th id="45">45</th><td></td></tr>
<tr><th id="46">46</th><td><i>/*</i></td></tr>
<tr><th id="47">47</th><td><i> * Version string.</i></td></tr>
<tr><th id="48">48</th><td><i> * Uses PACKAGE_VERSION from config.h.</i></td></tr>
<tr><th id="49">49</th><td><i> */</i></td></tr>
<tr><th id="50">50</th><td><u>#define <dfn class="macro" id="_M/PCAP_VERSION_STRING" data-ref="_M/PCAP_VERSION_STRING">PCAP_VERSION_STRING</dfn> "libpcap version " PACKAGE_VERSION</u></td></tr>
<tr><th id="51">51</th><td></td></tr>
<tr><th id="52">52</th><td><u>#<span data-ppcond="52">ifdef</span> <span class="macro" data-ref="_M/__cplusplus">__cplusplus</span></u></td></tr>
<tr><th id="53">53</th><td><b>extern</b> <q>"C"</q> {</td></tr>
<tr><th id="54">54</th><td><u>#<span data-ppcond="52">endif</span></u></td></tr>
<tr><th id="55">55</th><td></td></tr>
<tr><th id="56">56</th><td><u>#<span data-ppcond="56">ifdef</span> <span class="macro" data-ref="_M/MSDOS">MSDOS</span></u></td></tr>
<tr><th id="57">57</th><td>  <u>#include &lt;fcntl.h&gt;</u></td></tr>
<tr><th id="58">58</th><td>  <u>#include &lt;io.h&gt;</u></td></tr>
<tr><th id="59">59</th><td><u>#<span data-ppcond="56">endif</span></u></td></tr>
<tr><th id="60">60</th><td></td></tr>
<tr><th id="61">61</th><td><i>/*</i></td></tr>
<tr><th id="62">62</th><td><i> * Swap byte ordering of unsigned long long timestamp on a big endian</i></td></tr>
<tr><th id="63">63</th><td><i> * machine.</i></td></tr>
<tr><th id="64">64</th><td><i> */</i></td></tr>
<tr><th id="65">65</th><td><u>#define <dfn class="macro" id="_M/SWAPLL" data-ref="_M/SWAPLL">SWAPLL</dfn>(ull)  ((ull &amp; 0xff00000000000000ULL) &gt;&gt; 56) | \</u></td></tr>
<tr><th id="66">66</th><td><u>                      ((ull &amp; 0x00ff000000000000ULL) &gt;&gt; 40) | \</u></td></tr>
<tr><th id="67">67</th><td><u>                      ((ull &amp; 0x0000ff0000000000ULL) &gt;&gt; 24) | \</u></td></tr>
<tr><th id="68">68</th><td><u>                      ((ull &amp; 0x000000ff00000000ULL) &gt;&gt; 8)  | \</u></td></tr>
<tr><th id="69">69</th><td><u>                      ((ull &amp; 0x00000000ff000000ULL) &lt;&lt; 8)  | \</u></td></tr>
<tr><th id="70">70</th><td><u>                      ((ull &amp; 0x0000000000ff0000ULL) &lt;&lt; 24) | \</u></td></tr>
<tr><th id="71">71</th><td><u>                      ((ull &amp; 0x000000000000ff00ULL) &lt;&lt; 40) | \</u></td></tr>
<tr><th id="72">72</th><td><u>                      ((ull &amp; 0x00000000000000ffULL) &lt;&lt; 56)</u></td></tr>
<tr><th id="73">73</th><td></td></tr>
<tr><th id="74">74</th><td><i>/*</i></td></tr>
<tr><th id="75">75</th><td><i> * Maximum snapshot length.</i></td></tr>
<tr><th id="76">76</th><td><i> *</i></td></tr>
<tr><th id="77">77</th><td><i> * Somewhat arbitrary, but chosen to be:</i></td></tr>
<tr><th id="78">78</th><td><i> *</i></td></tr>
<tr><th id="79">79</th><td><i> *    1) big enough for maximum-size Linux loopback packets (65549)</i></td></tr>
<tr><th id="80">80</th><td><i> *       and some USB packets captured with USBPcap:</i></td></tr>
<tr><th id="81">81</th><td><i> *</i></td></tr>
<tr><th id="82">82</th><td><i> *           <a href="http://desowin.org/usbpcap/">http://desowin.org/usbpcap/</a></i></td></tr>
<tr><th id="83">83</th><td><i> *</i></td></tr>
<tr><th id="84">84</th><td><i> *       (&gt; 131072, &lt; 262144)</i></td></tr>
<tr><th id="85">85</th><td><i> *</i></td></tr>
<tr><th id="86">86</th><td><i> * and</i></td></tr>
<tr><th id="87">87</th><td><i> *</i></td></tr>
<tr><th id="88">88</th><td><i> *    2) small enough not to cause attempts to allocate huge amounts of</i></td></tr>
<tr><th id="89">89</th><td><i> *       memory; some applications might use the snapshot length in a</i></td></tr>
<tr><th id="90">90</th><td><i> *       savefile header to control the size of the buffer they allocate,</i></td></tr>
<tr><th id="91">91</th><td><i> *       so a size of, say, 2^31-1 might not work well.</i></td></tr>
<tr><th id="92">92</th><td><i> *</i></td></tr>
<tr><th id="93">93</th><td><i> * We don't enforce this in pcap_set_snaplen(), but we use it internally.</i></td></tr>
<tr><th id="94">94</th><td><i> */</i></td></tr>
<tr><th id="95">95</th><td><u>#define <dfn class="macro" id="_M/MAXIMUM_SNAPLEN" data-ref="_M/MAXIMUM_SNAPLEN">MAXIMUM_SNAPLEN</dfn>		262144</u></td></tr>
<tr><th id="96">96</th><td></td></tr>
<tr><th id="97">97</th><td><b>struct</b> <dfn class="type def" id="pcap_opt" title='pcap_opt' data-ref="pcap_opt" data-ref-filename="pcap_opt">pcap_opt</dfn> {</td></tr>
<tr><th id="98">98</th><td>	<em>char</em>	*<dfn class="decl field" id="pcap_opt::device" title='pcap_opt::device' data-ref="pcap_opt::device" data-ref-filename="pcap_opt..device">device</dfn>;</td></tr>
<tr><th id="99">99</th><td>	<em>int</em>	<dfn class="decl field" id="pcap_opt::timeout" title='pcap_opt::timeout' data-ref="pcap_opt::timeout" data-ref-filename="pcap_opt..timeout">timeout</dfn>;	<i>/* timeout for buffering */</i></td></tr>
<tr><th id="100">100</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_int" title='u_int' data-type='unsigned int' data-ref="u_int" data-ref-filename="u_int">u_int</a>	<dfn class="decl field" id="pcap_opt::buffer_size" title='pcap_opt::buffer_size' data-ref="pcap_opt::buffer_size" data-ref-filename="pcap_opt..buffer_size">buffer_size</dfn>;</td></tr>
<tr><th id="101">101</th><td>	<em>int</em>	<dfn class="decl field" id="pcap_opt::promisc" title='pcap_opt::promisc' data-ref="pcap_opt::promisc" data-ref-filename="pcap_opt..promisc">promisc</dfn>;</td></tr>
<tr><th id="102">102</th><td>	<em>int</em>	<dfn class="decl field" id="pcap_opt::rfmon" title='pcap_opt::rfmon' data-ref="pcap_opt::rfmon" data-ref-filename="pcap_opt..rfmon">rfmon</dfn>;		<i>/* monitor mode */</i></td></tr>
<tr><th id="103">103</th><td>	<em>int</em>	<dfn class="decl field" id="pcap_opt::immediate" title='pcap_opt::immediate' data-ref="pcap_opt::immediate" data-ref-filename="pcap_opt..immediate">immediate</dfn>;	<i>/* immediate mode - deliver packets as soon as they arrive */</i></td></tr>
<tr><th id="104">104</th><td>	<em>int</em>	<dfn class="decl field" id="pcap_opt::nonblock" title='pcap_opt::nonblock' data-ref="pcap_opt::nonblock" data-ref-filename="pcap_opt..nonblock">nonblock</dfn>;	<i>/* non-blocking mode - don't wait for packets to be delivered, return "no packets available" */</i></td></tr>
<tr><th id="105">105</th><td>	<em>int</em>	<dfn class="decl field" id="pcap_opt::tstamp_type" title='pcap_opt::tstamp_type' data-ref="pcap_opt::tstamp_type" data-ref-filename="pcap_opt..tstamp_type">tstamp_type</dfn>;</td></tr>
<tr><th id="106">106</th><td>	<em>int</em>	<dfn class="decl field" id="pcap_opt::tstamp_precision" title='pcap_opt::tstamp_precision' data-ref="pcap_opt::tstamp_precision" data-ref-filename="pcap_opt..tstamp_precision">tstamp_precision</dfn>;</td></tr>
<tr><th id="107">107</th><td></td></tr>
<tr><th id="108">108</th><td>	<i>/*</i></td></tr>
<tr><th id="109">109</th><td><i>	 * Platform-dependent options.</i></td></tr>
<tr><th id="110">110</th><td><i>	 */</i></td></tr>
<tr><th id="111">111</th><td><u>#<span data-ppcond="111">ifdef</span> <span class="macro" data-ref="_M/__linux__">__linux__</span></u></td></tr>
<tr><th id="112">112</th><td>	<em>int</em>	<dfn class="decl field" id="pcap_opt::protocol" title='pcap_opt::protocol' data-ref="pcap_opt::protocol" data-ref-filename="pcap_opt..protocol">protocol</dfn>;	<i>/* protocol to use when creating PF_PACKET socket */</i></td></tr>
<tr><th id="113">113</th><td><u>#<span data-ppcond="111">endif</span></u></td></tr>
<tr><th id="114">114</th><td><u>#<span data-ppcond="114">ifdef</span> <span class="macro" data-ref="_M/_WIN32">_WIN32</span></u></td></tr>
<tr><th id="115">115</th><td>	<em>int</em>	nocapture_local;<i>/* disable NPF loopback */</i></td></tr>
<tr><th id="116">116</th><td><u>#<span data-ppcond="114">endif</span></u></td></tr>
<tr><th id="117">117</th><td>};</td></tr>
<tr><th id="118">118</th><td></td></tr>
<tr><th id="119">119</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="activate_op_t" title='activate_op_t' data-type='int (*)(pcap_t *)' data-ref="activate_op_t" data-ref-filename="activate_op_t">activate_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *);</td></tr>
<tr><th id="120">120</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="can_set_rfmon_op_t" title='can_set_rfmon_op_t' data-type='int (*)(pcap_t *)' data-ref="can_set_rfmon_op_t" data-ref-filename="can_set_rfmon_op_t">can_set_rfmon_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *);</td></tr>
<tr><th id="121">121</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="read_op_t" title='read_op_t' data-type='int (*)(pcap_t *, int, pcap_handler, u_char *)' data-ref="read_op_t" data-ref-filename="read_op_t">read_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <em>int</em> <dfn class="local col1 decl" id="1cnt" title='cnt' data-type='int' data-ref="1cnt" data-ref-filename="1cnt">cnt</dfn>, <a class="typedef" href="pcap/pcap.h.html#pcap_handler" title='pcap_handler' data-type='void (*)(u_char *, const struct pcap_pkthdr *, const u_char *)' data-ref="pcap_handler" data-ref-filename="pcap_handler">pcap_handler</a>, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a> *);</td></tr>
<tr><th id="122">122</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="next_packet_op_t" title='next_packet_op_t' data-type='int (*)(pcap_t *, struct pcap_pkthdr *, u_char **)' data-ref="next_packet_op_t" data-ref-filename="next_packet_op_t">next_packet_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <b>struct</b> <a class="type" href="pcap/pcap.h.html#pcap_pkthdr" title='pcap_pkthdr' data-ref="pcap_pkthdr" data-ref-filename="pcap_pkthdr">pcap_pkthdr</a> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a> **);</td></tr>
<tr><th id="123">123</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="inject_op_t" title='inject_op_t' data-type='int (*)(pcap_t *, const void *, size_t)' data-ref="inject_op_t" data-ref-filename="inject_op_t">inject_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <em>const</em> <em>void</em> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>);</td></tr>
<tr><th id="124">124</th><td><b>typedef</b> <em>void</em>	(*<dfn class="typedef" id="save_current_filter_op_t" title='save_current_filter_op_t' data-type='void (*)(pcap_t *, const char *)' data-ref="save_current_filter_op_t" data-ref-filename="save_current_filter_op_t">save_current_filter_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <em>const</em> <em>char</em> *);</td></tr>
<tr><th id="125">125</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="setfilter_op_t" title='setfilter_op_t' data-type='int (*)(pcap_t *, struct bpf_program *)' data-ref="setfilter_op_t" data-ref-filename="setfilter_op_t">setfilter_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <b>struct</b> <a class="type" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_program" title='bpf_program' data-ref="bpf_program" data-ref-filename="bpf_program">bpf_program</a> *);</td></tr>
<tr><th id="126">126</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="setdirection_op_t" title='setdirection_op_t' data-type='int (*)(pcap_t *, pcap_direction_t)' data-ref="setdirection_op_t" data-ref-filename="setdirection_op_t">setdirection_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <a class="typedef" href="pcap/pcap.h.html#pcap_direction_t" title='pcap_direction_t' data-type='enum pcap_direction_t' data-ref="pcap_direction_t" data-ref-filename="pcap_direction_t">pcap_direction_t</a>);</td></tr>
<tr><th id="127">127</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="set_datalink_op_t" title='set_datalink_op_t' data-type='int (*)(pcap_t *, int)' data-ref="set_datalink_op_t" data-ref-filename="set_datalink_op_t">set_datalink_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <em>int</em>);</td></tr>
<tr><th id="128">128</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="getnonblock_op_t" title='getnonblock_op_t' data-type='int (*)(pcap_t *)' data-ref="getnonblock_op_t" data-ref-filename="getnonblock_op_t">getnonblock_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *);</td></tr>
<tr><th id="129">129</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="setnonblock_op_t" title='setnonblock_op_t' data-type='int (*)(pcap_t *, int)' data-ref="setnonblock_op_t" data-ref-filename="setnonblock_op_t">setnonblock_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <em>int</em>);</td></tr>
<tr><th id="130">130</th><td><b>typedef</b> <em>int</em>	(*<dfn class="typedef" id="stats_op_t" title='stats_op_t' data-type='int (*)(pcap_t *, struct pcap_stat *)' data-ref="stats_op_t" data-ref-filename="stats_op_t">stats_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <b>struct</b> <a class="type" href="pcap/pcap.h.html#pcap_stat" title='pcap_stat' data-ref="pcap_stat" data-ref-filename="pcap_stat">pcap_stat</a> *);</td></tr>
<tr><th id="131">131</th><td><u>#<span data-ppcond="131">ifdef</span> <span class="macro" data-ref="_M/_WIN32">_WIN32</span></u></td></tr>
<tr><th id="132">132</th><td><b>typedef</b> <b>struct</b> pcap_stat *(*stats_ex_op_t)(pcap_t *, <em>int</em> *);</td></tr>
<tr><th id="133">133</th><td><b>typedef</b> <em>int</em>	(*setbuff_op_t)(pcap_t *, <em>int</em>);</td></tr>
<tr><th id="134">134</th><td><b>typedef</b> <em>int</em>	(*setmode_op_t)(pcap_t *, <em>int</em>);</td></tr>
<tr><th id="135">135</th><td><b>typedef</b> <em>int</em>	(*setmintocopy_op_t)(pcap_t *, <em>int</em>);</td></tr>
<tr><th id="136">136</th><td><b>typedef</b> HANDLE	(*getevent_op_t)(pcap_t *);</td></tr>
<tr><th id="137">137</th><td><b>typedef</b> <em>int</em>	(*oid_get_request_op_t)(pcap_t *, bpf_u_int32, <em>void</em> *, size_t *);</td></tr>
<tr><th id="138">138</th><td><b>typedef</b> <em>int</em>	(*oid_set_request_op_t)(pcap_t *, bpf_u_int32, <em>const</em> <em>void</em> *, size_t *);</td></tr>
<tr><th id="139">139</th><td><b>typedef</b> u_int	(*sendqueue_transmit_op_t)(pcap_t *, pcap_send_queue *, <em>int</em>);</td></tr>
<tr><th id="140">140</th><td><b>typedef</b> <em>int</em>	(*setuserbuffer_op_t)(pcap_t *, <em>int</em>);</td></tr>
<tr><th id="141">141</th><td><b>typedef</b> <em>int</em>	(*live_dump_op_t)(pcap_t *, <em>char</em> *, <em>int</em>, <em>int</em>);</td></tr>
<tr><th id="142">142</th><td><b>typedef</b> <em>int</em>	(*live_dump_ended_op_t)(pcap_t *, <em>int</em>);</td></tr>
<tr><th id="143">143</th><td><b>typedef</b> PAirpcapHandle	(*get_airpcap_handle_op_t)(pcap_t *);</td></tr>
<tr><th id="144">144</th><td><u>#<span data-ppcond="131">endif</span></u></td></tr>
<tr><th id="145">145</th><td><b>typedef</b> <em>void</em>	(*<dfn class="typedef" id="cleanup_op_t" title='cleanup_op_t' data-type='void (*)(pcap_t *)' data-ref="cleanup_op_t" data-ref-filename="cleanup_op_t">cleanup_op_t</dfn>)(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *);</td></tr>
<tr><th id="146">146</th><td></td></tr>
<tr><th id="147">147</th><td><i>/*</i></td></tr>
<tr><th id="148">148</th><td><i> * We put all the stuff used in the read code path at the beginning,</i></td></tr>
<tr><th id="149">149</th><td><i> * to try to keep it together in the same cache line or lines.</i></td></tr>
<tr><th id="150">150</th><td><i> */</i></td></tr>
<tr><th id="151">151</th><td><b>struct</b> <dfn class="type def" id="pcap" title='pcap' data-ref="pcap" data-ref-filename="pcap">pcap</dfn> {</td></tr>
<tr><th id="152">152</th><td>	<i>/*</i></td></tr>
<tr><th id="153">153</th><td><i>	 * Method to call to read packets on a live capture.</i></td></tr>
<tr><th id="154">154</th><td><i>	 */</i></td></tr>
<tr><th id="155">155</th><td>	<a class="typedef" href="#read_op_t" title='read_op_t' data-type='int (*)(pcap_t *, int, pcap_handler, u_char *)' data-ref="read_op_t" data-ref-filename="read_op_t">read_op_t</a> <dfn class="decl field" id="pcap::read_op" title='pcap::read_op' data-ref="pcap::read_op" data-ref-filename="pcap..read_op">read_op</dfn>;</td></tr>
<tr><th id="156">156</th><td></td></tr>
<tr><th id="157">157</th><td>	<i>/*</i></td></tr>
<tr><th id="158">158</th><td><i>	 * Method to call to read the next packet from a savefile.</i></td></tr>
<tr><th id="159">159</th><td><i>	 */</i></td></tr>
<tr><th id="160">160</th><td>	<a class="typedef" href="#next_packet_op_t" title='next_packet_op_t' data-type='int (*)(pcap_t *, struct pcap_pkthdr *, u_char **)' data-ref="next_packet_op_t" data-ref-filename="next_packet_op_t">next_packet_op_t</a> <dfn class="decl field" id="pcap::next_packet_op" title='pcap::next_packet_op' data-ref="pcap::next_packet_op" data-ref-filename="pcap..next_packet_op">next_packet_op</dfn>;</td></tr>
<tr><th id="161">161</th><td></td></tr>
<tr><th id="162">162</th><td><u>#<span data-ppcond="162">ifdef</span> <span class="macro" data-ref="_M/_WIN32">_WIN32</span></u></td></tr>
<tr><th id="163">163</th><td>	HANDLE handle;</td></tr>
<tr><th id="164">164</th><td><u>#<span data-ppcond="162">else</span></u></td></tr>
<tr><th id="165">165</th><td>	<em>int</em> <dfn class="decl field" id="pcap::fd" title='pcap::fd' data-ref="pcap::fd" data-ref-filename="pcap..fd">fd</dfn>;</td></tr>
<tr><th id="166">166</th><td><u>#<span data-ppcond="162">endif</span> /* _WIN32 */</u></td></tr>
<tr><th id="167">167</th><td></td></tr>
<tr><th id="168">168</th><td>	<i>/*</i></td></tr>
<tr><th id="169">169</th><td><i>	 * Read buffer.</i></td></tr>
<tr><th id="170">170</th><td><i>	 */</i></td></tr>
<tr><th id="171">171</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_int" title='u_int' data-type='unsigned int' data-ref="u_int" data-ref-filename="u_int">u_int</a> <dfn class="decl field" id="pcap::bufsize" title='pcap::bufsize' data-ref="pcap::bufsize" data-ref-filename="pcap..bufsize">bufsize</dfn>;</td></tr>
<tr><th id="172">172</th><td>	<em>void</em> *<dfn class="decl field" id="pcap::buffer" title='pcap::buffer' data-ref="pcap::buffer" data-ref-filename="pcap..buffer">buffer</dfn>;</td></tr>
<tr><th id="173">173</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a> *<dfn class="decl field" id="pcap::bp" title='pcap::bp' data-ref="pcap::bp" data-ref-filename="pcap..bp">bp</dfn>;</td></tr>
<tr><th id="174">174</th><td>	<em>int</em> <dfn class="decl field" id="pcap::cc" title='pcap::cc' data-ref="pcap::cc" data-ref-filename="pcap..cc">cc</dfn>;</td></tr>
<tr><th id="175">175</th><td></td></tr>
<tr><th id="176">176</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/i386/signal.h.html#sig_atomic_t" title='sig_atomic_t' data-type='int' data-ref="sig_atomic_t" data-ref-filename="sig_atomic_t">sig_atomic_t</a> <dfn class="decl field" id="pcap::break_loop" title='pcap::break_loop' data-ref="pcap::break_loop" data-ref-filename="pcap..break_loop">break_loop</dfn>; <i>/* flag set to force break from packet-reading loop */</i></td></tr>
<tr><th id="177">177</th><td></td></tr>
<tr><th id="178">178</th><td>	<em>void</em> *<dfn class="decl field" id="pcap::priv" title='pcap::priv' data-ref="pcap::priv" data-ref-filename="pcap..priv">priv</dfn>;		<i>/* private data for methods */</i></td></tr>
<tr><th id="179">179</th><td></td></tr>
<tr><th id="180">180</th><td><u>#<span data-ppcond="180">ifdef</span> <span class="macro" data-ref="_M/ENABLE_REMOTE">ENABLE_REMOTE</span></u></td></tr>
<tr><th id="181">181</th><td>	<b>struct</b> pcap_samp rmt_samp;	<i>/* parameters related to the sampling process. */</i></td></tr>
<tr><th id="182">182</th><td><u>#<span data-ppcond="180">endif</span></u></td></tr>
<tr><th id="183">183</th><td></td></tr>
<tr><th id="184">184</th><td>	<em>int</em> <dfn class="decl field" id="pcap::swapped" title='pcap::swapped' data-ref="pcap::swapped" data-ref-filename="pcap..swapped">swapped</dfn>;</td></tr>
<tr><th id="185">185</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#FILE" title='FILE' data-type='struct __sFILE' data-ref="FILE" data-ref-filename="FILE">FILE</a> *<dfn class="decl field" id="pcap::rfile" title='pcap::rfile' data-ref="pcap::rfile" data-ref-filename="pcap..rfile">rfile</dfn>;		<i>/* null if live capture, non-null if savefile */</i></td></tr>
<tr><th id="186">186</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_int" title='u_int' data-type='unsigned int' data-ref="u_int" data-ref-filename="u_int">u_int</a> <dfn class="decl field" id="pcap::fddipad" title='pcap::fddipad' data-ref="pcap::fddipad" data-ref-filename="pcap..fddipad">fddipad</dfn>;</td></tr>
<tr><th id="187">187</th><td>	<b>struct</b> <a class="type" href="#pcap" title='pcap' data-ref="pcap" data-ref-filename="pcap">pcap</a> *<dfn class="decl field" id="pcap::next" title='pcap::next' data-ref="pcap::next" data-ref-filename="pcap..next">next</dfn>;	<i>/* list of open pcaps that need stuff cleared on close */</i></td></tr>
<tr><th id="188">188</th><td></td></tr>
<tr><th id="189">189</th><td>	<i>/*</i></td></tr>
<tr><th id="190">190</th><td><i>	 * File version number; meaningful only for a savefile, but we</i></td></tr>
<tr><th id="191">191</th><td><i>	 * keep it here so that apps that (mistakenly) ask for the</i></td></tr>
<tr><th id="192">192</th><td><i>	 * version numbers will get the same zero values that they</i></td></tr>
<tr><th id="193">193</th><td><i>	 * always did.</i></td></tr>
<tr><th id="194">194</th><td><i>	 */</i></td></tr>
<tr><th id="195">195</th><td>	<em>int</em> <dfn class="decl field" id="pcap::version_major" title='pcap::version_major' data-ref="pcap::version_major" data-ref-filename="pcap..version_major">version_major</dfn>;</td></tr>
<tr><th id="196">196</th><td>	<em>int</em> <dfn class="decl field" id="pcap::version_minor" title='pcap::version_minor' data-ref="pcap::version_minor" data-ref-filename="pcap..version_minor">version_minor</dfn>;</td></tr>
<tr><th id="197">197</th><td></td></tr>
<tr><th id="198">198</th><td>	<em>int</em> <dfn class="decl field" id="pcap::snapshot" title='pcap::snapshot' data-ref="pcap::snapshot" data-ref-filename="pcap..snapshot">snapshot</dfn>;</td></tr>
<tr><th id="199">199</th><td>	<em>int</em> <dfn class="decl field" id="pcap::linktype" title='pcap::linktype' data-ref="pcap::linktype" data-ref-filename="pcap..linktype">linktype</dfn>;		<i>/* Network linktype */</i></td></tr>
<tr><th id="200">200</th><td>	<em>int</em> <dfn class="decl field" id="pcap::linktype_ext" title='pcap::linktype_ext' data-ref="pcap::linktype_ext" data-ref-filename="pcap..linktype_ext">linktype_ext</dfn>;       <i>/* Extended information stored in the linktype field of a file */</i></td></tr>
<tr><th id="201">201</th><td>	<em>int</em> <dfn class="decl field" id="pcap::tzoff" title='pcap::tzoff' data-ref="pcap::tzoff" data-ref-filename="pcap..tzoff">tzoff</dfn>;		<i>/* timezone offset */</i></td></tr>
<tr><th id="202">202</th><td>	<em>int</em> <dfn class="decl field" id="pcap::offset" title='pcap::offset' data-ref="pcap::offset" data-ref-filename="pcap..offset">offset</dfn>;		<i>/* offset for proper alignment */</i></td></tr>
<tr><th id="203">203</th><td>	<em>int</em> <dfn class="decl field" id="pcap::activated" title='pcap::activated' data-ref="pcap::activated" data-ref-filename="pcap..activated">activated</dfn>;		<i>/* true if the capture is really started */</i></td></tr>
<tr><th id="204">204</th><td>	<em>int</em> <dfn class="decl field" id="pcap::oldstyle" title='pcap::oldstyle' data-ref="pcap::oldstyle" data-ref-filename="pcap..oldstyle">oldstyle</dfn>;		<i>/* if we're opening with pcap_open_live() */</i></td></tr>
<tr><th id="205">205</th><td></td></tr>
<tr><th id="206">206</th><td>	<b>struct</b> <a class="type" href="#pcap_opt" title='pcap_opt' data-ref="pcap_opt" data-ref-filename="pcap_opt">pcap_opt</a> <dfn class="decl field" id="pcap::opt" title='pcap::opt' data-ref="pcap::opt" data-ref-filename="pcap..opt">opt</dfn>;</td></tr>
<tr><th id="207">207</th><td></td></tr>
<tr><th id="208">208</th><td>	<i>/*</i></td></tr>
<tr><th id="209">209</th><td><i>	 * Place holder for pcap_next().</i></td></tr>
<tr><th id="210">210</th><td><i>	 */</i></td></tr>
<tr><th id="211">211</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a> *<dfn class="decl field" id="pcap::pkt" title='pcap::pkt' data-ref="pcap::pkt" data-ref-filename="pcap..pkt">pkt</dfn>;</td></tr>
<tr><th id="212">212</th><td></td></tr>
<tr><th id="213">213</th><td><u>#<span data-ppcond="213">ifdef</span> <span class="macro" data-ref="_M/_WIN32">_WIN32</span></u></td></tr>
<tr><th id="214">214</th><td>	<b>struct</b> pcap_stat stat;	<i>/* used for pcap_stats_ex() */</i></td></tr>
<tr><th id="215">215</th><td><u>#<span data-ppcond="213">endif</span></u></td></tr>
<tr><th id="216">216</th><td></td></tr>
<tr><th id="217">217</th><td>	<i>/* We're accepting only packets in this direction/these directions. */</i></td></tr>
<tr><th id="218">218</th><td>	<a class="typedef" href="pcap/pcap.h.html#pcap_direction_t" title='pcap_direction_t' data-type='enum pcap_direction_t' data-ref="pcap_direction_t" data-ref-filename="pcap_direction_t">pcap_direction_t</a> <dfn class="decl field" id="pcap::direction" title='pcap::direction' data-ref="pcap::direction" data-ref-filename="pcap..direction">direction</dfn>;</td></tr>
<tr><th id="219">219</th><td></td></tr>
<tr><th id="220">220</th><td>	<i>/*</i></td></tr>
<tr><th id="221">221</th><td><i>	 * Flags to affect BPF code generation.</i></td></tr>
<tr><th id="222">222</th><td><i>	 */</i></td></tr>
<tr><th id="223">223</th><td>	<em>int</em> <dfn class="decl field" id="pcap::bpf_codegen_flags" title='pcap::bpf_codegen_flags' data-ref="pcap::bpf_codegen_flags" data-ref-filename="pcap..bpf_codegen_flags">bpf_codegen_flags</dfn>;</td></tr>
<tr><th id="224">224</th><td></td></tr>
<tr><th id="225">225</th><td><u>#<span data-ppcond="225">if</span> !defined(<span class="macro" data-ref="_M/_WIN32">_WIN32</span>) &amp;&amp; !defined(<span class="macro" data-ref="_M/MSDOS">MSDOS</span>)</u></td></tr>
<tr><th id="226">226</th><td>	<em>int</em> <dfn class="decl field" id="pcap::selectable_fd" title='pcap::selectable_fd' data-ref="pcap::selectable_fd" data-ref-filename="pcap..selectable_fd">selectable_fd</dfn>;	<i>/* FD on which select()/poll()/epoll_wait()/kevent()/etc. can be done */</i></td></tr>
<tr><th id="227">227</th><td></td></tr>
<tr><th id="228">228</th><td>	<i>/*</i></td></tr>
<tr><th id="229">229</th><td><i>	 * In case there either is no selectable FD, or there is but</i></td></tr>
<tr><th id="230">230</th><td><i>	 * it doesn't necessarily work (e.g., if it doesn't get notified</i></td></tr>
<tr><th id="231">231</th><td><i>	 * if the packet capture timeout expires before the buffer</i></td></tr>
<tr><th id="232">232</th><td><i>	 * fills up), this points to a timeout that should be used</i></td></tr>
<tr><th id="233">233</th><td><i>	 * in select()/poll()/epoll_wait()/kevent() call.  The pcap_t should</i></td></tr>
<tr><th id="234">234</th><td><i>	 * be put into non-blocking mode, and, if the timeout expires on</i></td></tr>
<tr><th id="235">235</th><td><i>	 * the call, an attempt should be made to read packets from all</i></td></tr>
<tr><th id="236">236</th><td><i>	 * pcap_t's with a required timeout, and the code must be</i></td></tr>
<tr><th id="237">237</th><td><i>	 * prepared not to see any packets from the attempt.</i></td></tr>
<tr><th id="238">238</th><td><i>	 */</i></td></tr>
<tr><th id="239">239</th><td>	<b>struct</b> <a class="type" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/time.h.html#timeval" title='timeval' data-ref="timeval" data-ref-filename="timeval">timeval</a> *<dfn class="decl field" id="pcap::required_select_timeout" title='pcap::required_select_timeout' data-ref="pcap::required_select_timeout" data-ref-filename="pcap..required_select_timeout">required_select_timeout</dfn>;</td></tr>
<tr><th id="240">240</th><td><u>#<span data-ppcond="225">endif</span></u></td></tr>
<tr><th id="241">241</th><td></td></tr>
<tr><th id="242">242</th><td>	<i>/*</i></td></tr>
<tr><th id="243">243</th><td><i>	 * Placeholder for filter code if bpf not in kernel.</i></td></tr>
<tr><th id="244">244</th><td><i>	 */</i></td></tr>
<tr><th id="245">245</th><td>	<b>struct</b> <a class="type" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_program" title='bpf_program' data-ref="bpf_program" data-ref-filename="bpf_program">bpf_program</a> <dfn class="decl field" id="pcap::fcode" title='pcap::fcode' data-ref="pcap::fcode" data-ref-filename="pcap..fcode">fcode</dfn>;</td></tr>
<tr><th id="246">246</th><td></td></tr>
<tr><th id="247">247</th><td>	<em>char</em> <dfn class="decl field" id="pcap::errbuf" title='pcap::errbuf' data-ref="pcap::errbuf" data-ref-filename="pcap..errbuf">errbuf</dfn>[<a class="macro" href="pcap/pcap.h.html#111" title="256" data-ref="_M/PCAP_ERRBUF_SIZE">PCAP_ERRBUF_SIZE</a> + <var>1</var>];</td></tr>
<tr><th id="248">248</th><td>	<em>int</em> <dfn class="decl field" id="pcap::dlt_count" title='pcap::dlt_count' data-ref="pcap::dlt_count" data-ref-filename="pcap..dlt_count">dlt_count</dfn>;</td></tr>
<tr><th id="249">249</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_int" title='u_int' data-type='unsigned int' data-ref="u_int" data-ref-filename="u_int">u_int</a> *<dfn class="decl field" id="pcap::dlt_list" title='pcap::dlt_list' data-ref="pcap::dlt_list" data-ref-filename="pcap..dlt_list">dlt_list</dfn>;</td></tr>
<tr><th id="250">250</th><td>	<em>int</em> <dfn class="decl field" id="pcap::tstamp_type_count" title='pcap::tstamp_type_count' data-ref="pcap::tstamp_type_count" data-ref-filename="pcap..tstamp_type_count">tstamp_type_count</dfn>;</td></tr>
<tr><th id="251">251</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_int" title='u_int' data-type='unsigned int' data-ref="u_int" data-ref-filename="u_int">u_int</a> *<dfn class="decl field" id="pcap::tstamp_type_list" title='pcap::tstamp_type_list' data-ref="pcap::tstamp_type_list" data-ref-filename="pcap..tstamp_type_list">tstamp_type_list</dfn>;</td></tr>
<tr><th id="252">252</th><td>	<em>int</em> <dfn class="decl field" id="pcap::tstamp_precision_count" title='pcap::tstamp_precision_count' data-ref="pcap::tstamp_precision_count" data-ref-filename="pcap..tstamp_precision_count">tstamp_precision_count</dfn>;</td></tr>
<tr><th id="253">253</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_int" title='u_int' data-type='unsigned int' data-ref="u_int" data-ref-filename="u_int">u_int</a> *<dfn class="decl field" id="pcap::tstamp_precision_list" title='pcap::tstamp_precision_list' data-ref="pcap::tstamp_precision_list" data-ref-filename="pcap..tstamp_precision_list">tstamp_precision_list</dfn>;</td></tr>
<tr><th id="254">254</th><td></td></tr>
<tr><th id="255">255</th><td>	<b>struct</b> <a class="type" href="pcap/pcap.h.html#pcap_pkthdr" title='pcap_pkthdr' data-ref="pcap_pkthdr" data-ref-filename="pcap_pkthdr">pcap_pkthdr</a> <dfn class="decl field" id="pcap::pcap_header" title='pcap::pcap_header' data-ref="pcap::pcap_header" data-ref-filename="pcap..pcap_header">pcap_header</dfn>;	<i>/* This is needed for the pcap_next_ex() to work */</i></td></tr>
<tr><th id="256">256</th><td></td></tr>
<tr><th id="257">257</th><td>	<i>/*</i></td></tr>
<tr><th id="258">258</th><td><i>	 * More methods.</i></td></tr>
<tr><th id="259">259</th><td><i>	 */</i></td></tr>
<tr><th id="260">260</th><td>	<a class="typedef" href="#activate_op_t" title='activate_op_t' data-type='int (*)(pcap_t *)' data-ref="activate_op_t" data-ref-filename="activate_op_t">activate_op_t</a> <dfn class="decl field" id="pcap::activate_op" title='pcap::activate_op' data-ref="pcap::activate_op" data-ref-filename="pcap..activate_op">activate_op</dfn>;</td></tr>
<tr><th id="261">261</th><td>	<a class="typedef" href="#can_set_rfmon_op_t" title='can_set_rfmon_op_t' data-type='int (*)(pcap_t *)' data-ref="can_set_rfmon_op_t" data-ref-filename="can_set_rfmon_op_t">can_set_rfmon_op_t</a> <dfn class="decl field" id="pcap::can_set_rfmon_op" title='pcap::can_set_rfmon_op' data-ref="pcap::can_set_rfmon_op" data-ref-filename="pcap..can_set_rfmon_op">can_set_rfmon_op</dfn>;</td></tr>
<tr><th id="262">262</th><td>	<a class="typedef" href="#inject_op_t" title='inject_op_t' data-type='int (*)(pcap_t *, const void *, size_t)' data-ref="inject_op_t" data-ref-filename="inject_op_t">inject_op_t</a> <dfn class="decl field" id="pcap::inject_op" title='pcap::inject_op' data-ref="pcap::inject_op" data-ref-filename="pcap..inject_op">inject_op</dfn>;</td></tr>
<tr><th id="263">263</th><td>	<a class="typedef" href="#save_current_filter_op_t" title='save_current_filter_op_t' data-type='void (*)(pcap_t *, const char *)' data-ref="save_current_filter_op_t" data-ref-filename="save_current_filter_op_t">save_current_filter_op_t</a> <dfn class="decl field" id="pcap::save_current_filter_op" title='pcap::save_current_filter_op' data-ref="pcap::save_current_filter_op" data-ref-filename="pcap..save_current_filter_op">save_current_filter_op</dfn>;</td></tr>
<tr><th id="264">264</th><td>	<a class="typedef" href="#setfilter_op_t" title='setfilter_op_t' data-type='int (*)(pcap_t *, struct bpf_program *)' data-ref="setfilter_op_t" data-ref-filename="setfilter_op_t">setfilter_op_t</a> <dfn class="decl field" id="pcap::setfilter_op" title='pcap::setfilter_op' data-ref="pcap::setfilter_op" data-ref-filename="pcap..setfilter_op">setfilter_op</dfn>;</td></tr>
<tr><th id="265">265</th><td>	<a class="typedef" href="#setdirection_op_t" title='setdirection_op_t' data-type='int (*)(pcap_t *, pcap_direction_t)' data-ref="setdirection_op_t" data-ref-filename="setdirection_op_t">setdirection_op_t</a> <dfn class="decl field" id="pcap::setdirection_op" title='pcap::setdirection_op' data-ref="pcap::setdirection_op" data-ref-filename="pcap..setdirection_op">setdirection_op</dfn>;</td></tr>
<tr><th id="266">266</th><td>	<a class="typedef" href="#set_datalink_op_t" title='set_datalink_op_t' data-type='int (*)(pcap_t *, int)' data-ref="set_datalink_op_t" data-ref-filename="set_datalink_op_t">set_datalink_op_t</a> <dfn class="decl field" id="pcap::set_datalink_op" title='pcap::set_datalink_op' data-ref="pcap::set_datalink_op" data-ref-filename="pcap..set_datalink_op">set_datalink_op</dfn>;</td></tr>
<tr><th id="267">267</th><td>	<a class="typedef" href="#getnonblock_op_t" title='getnonblock_op_t' data-type='int (*)(pcap_t *)' data-ref="getnonblock_op_t" data-ref-filename="getnonblock_op_t">getnonblock_op_t</a> <dfn class="decl field" id="pcap::getnonblock_op" title='pcap::getnonblock_op' data-ref="pcap::getnonblock_op" data-ref-filename="pcap..getnonblock_op">getnonblock_op</dfn>;</td></tr>
<tr><th id="268">268</th><td>	<a class="typedef" href="#setnonblock_op_t" title='setnonblock_op_t' data-type='int (*)(pcap_t *, int)' data-ref="setnonblock_op_t" data-ref-filename="setnonblock_op_t">setnonblock_op_t</a> <dfn class="decl field" id="pcap::setnonblock_op" title='pcap::setnonblock_op' data-ref="pcap::setnonblock_op" data-ref-filename="pcap..setnonblock_op">setnonblock_op</dfn>;</td></tr>
<tr><th id="269">269</th><td>	<a class="typedef" href="#stats_op_t" title='stats_op_t' data-type='int (*)(pcap_t *, struct pcap_stat *)' data-ref="stats_op_t" data-ref-filename="stats_op_t">stats_op_t</a> <dfn class="decl field" id="pcap::stats_op" title='pcap::stats_op' data-ref="pcap::stats_op" data-ref-filename="pcap..stats_op">stats_op</dfn>;</td></tr>
<tr><th id="270">270</th><td></td></tr>
<tr><th id="271">271</th><td>	<i>/*</i></td></tr>
<tr><th id="272">272</th><td><i>	 * Routine to use as callback for pcap_next()/pcap_next_ex().</i></td></tr>
<tr><th id="273">273</th><td><i>	 */</i></td></tr>
<tr><th id="274">274</th><td>	<a class="typedef" href="pcap/pcap.h.html#pcap_handler" title='pcap_handler' data-type='void (*)(u_char *, const struct pcap_pkthdr *, const u_char *)' data-ref="pcap_handler" data-ref-filename="pcap_handler">pcap_handler</a> <dfn class="decl field" id="pcap::oneshot_callback" title='pcap::oneshot_callback' data-ref="pcap::oneshot_callback" data-ref-filename="pcap..oneshot_callback">oneshot_callback</dfn>;</td></tr>
<tr><th id="275">275</th><td></td></tr>
<tr><th id="276">276</th><td><u>#<span data-ppcond="276">ifdef</span> <span class="macro" data-ref="_M/_WIN32">_WIN32</span></u></td></tr>
<tr><th id="277">277</th><td>	<i>/*</i></td></tr>
<tr><th id="278">278</th><td><i>	 * These are, at least currently, specific to the Win32 NPF</i></td></tr>
<tr><th id="279">279</th><td><i>	 * driver.</i></td></tr>
<tr><th id="280">280</th><td><i>	 */</i></td></tr>
<tr><th id="281">281</th><td>	stats_ex_op_t stats_ex_op;</td></tr>
<tr><th id="282">282</th><td>	setbuff_op_t setbuff_op;</td></tr>
<tr><th id="283">283</th><td>	setmode_op_t setmode_op;</td></tr>
<tr><th id="284">284</th><td>	setmintocopy_op_t setmintocopy_op;</td></tr>
<tr><th id="285">285</th><td>	getevent_op_t getevent_op;</td></tr>
<tr><th id="286">286</th><td>	oid_get_request_op_t oid_get_request_op;</td></tr>
<tr><th id="287">287</th><td>	oid_set_request_op_t oid_set_request_op;</td></tr>
<tr><th id="288">288</th><td>	sendqueue_transmit_op_t sendqueue_transmit_op;</td></tr>
<tr><th id="289">289</th><td>	setuserbuffer_op_t setuserbuffer_op;</td></tr>
<tr><th id="290">290</th><td>	live_dump_op_t live_dump_op;</td></tr>
<tr><th id="291">291</th><td>	live_dump_ended_op_t live_dump_ended_op;</td></tr>
<tr><th id="292">292</th><td>	get_airpcap_handle_op_t get_airpcap_handle_op;</td></tr>
<tr><th id="293">293</th><td><u>#<span data-ppcond="276">endif</span></u></td></tr>
<tr><th id="294">294</th><td>	<a class="typedef" href="#cleanup_op_t" title='cleanup_op_t' data-type='void (*)(pcap_t *)' data-ref="cleanup_op_t" data-ref-filename="cleanup_op_t">cleanup_op_t</a> <dfn class="decl field" id="pcap::cleanup_op" title='pcap::cleanup_op' data-ref="pcap::cleanup_op" data-ref-filename="pcap..cleanup_op">cleanup_op</dfn>;</td></tr>
<tr><th id="295">295</th><td>};</td></tr>
<tr><th id="296">296</th><td></td></tr>
<tr><th id="297">297</th><td><i>/*</i></td></tr>
<tr><th id="298">298</th><td><i> * BPF code generation flags.</i></td></tr>
<tr><th id="299">299</th><td><i> */</i></td></tr>
<tr><th id="300">300</th><td><u>#define <dfn class="macro" id="_M/BPF_SPECIAL_VLAN_HANDLING" data-ref="_M/BPF_SPECIAL_VLAN_HANDLING">BPF_SPECIAL_VLAN_HANDLING</dfn>	0x00000001	/* special VLAN handling for Linux */</u></td></tr>
<tr><th id="301">301</th><td></td></tr>
<tr><th id="302">302</th><td><i>/*</i></td></tr>
<tr><th id="303">303</th><td><i> * This is a timeval as stored in a savefile.</i></td></tr>
<tr><th id="304">304</th><td><i> * It has to use the same types everywhere, independent of the actual</i></td></tr>
<tr><th id="305">305</th><td><i> * `struct timeval'; `struct timeval' has 32-bit tv_sec values on some</i></td></tr>
<tr><th id="306">306</th><td><i> * platforms and 64-bit tv_sec values on other platforms, and writing</i></td></tr>
<tr><th id="307">307</th><td><i> * out native `struct timeval' values would mean files could only be</i></td></tr>
<tr><th id="308">308</th><td><i> * read on systems with the same tv_sec size as the system on which</i></td></tr>
<tr><th id="309">309</th><td><i> * the file was written.</i></td></tr>
<tr><th id="310">310</th><td><i> */</i></td></tr>
<tr><th id="311">311</th><td></td></tr>
<tr><th id="312">312</th><td><b>struct</b> <dfn class="type def" id="pcap_timeval" title='pcap_timeval' data-ref="pcap_timeval" data-ref-filename="pcap_timeval">pcap_timeval</dfn> {</td></tr>
<tr><th id="313">313</th><td>    <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_int32" title='bpf_int32' data-type='int' data-ref="bpf_int32" data-ref-filename="bpf_int32">bpf_int32</a> <dfn class="decl field" id="pcap_timeval::tv_sec" title='pcap_timeval::tv_sec' data-ref="pcap_timeval::tv_sec" data-ref-filename="pcap_timeval..tv_sec">tv_sec</dfn>;		<i>/* seconds */</i></td></tr>
<tr><th id="314">314</th><td>    <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_int32" title='bpf_int32' data-type='int' data-ref="bpf_int32" data-ref-filename="bpf_int32">bpf_int32</a> <dfn class="decl field" id="pcap_timeval::tv_usec" title='pcap_timeval::tv_usec' data-ref="pcap_timeval::tv_usec" data-ref-filename="pcap_timeval..tv_usec">tv_usec</dfn>;		<i>/* microseconds */</i></td></tr>
<tr><th id="315">315</th><td>};</td></tr>
<tr><th id="316">316</th><td></td></tr>
<tr><th id="317">317</th><td><i>/*</i></td></tr>
<tr><th id="318">318</th><td><i> * This is a `pcap_pkthdr' as actually stored in a savefile.</i></td></tr>
<tr><th id="319">319</th><td><i> *</i></td></tr>
<tr><th id="320">320</th><td><i> * Do not change the format of this structure, in any way (this includes</i></td></tr>
<tr><th id="321">321</th><td><i> * changes that only affect the length of fields in this structure),</i></td></tr>
<tr><th id="322">322</th><td><i> * and do not make the time stamp anything other than seconds and</i></td></tr>
<tr><th id="323">323</th><td><i> * microseconds (e.g., seconds and nanoseconds).  Instead:</i></td></tr>
<tr><th id="324">324</th><td><i> *</i></td></tr>
<tr><th id="325">325</th><td><i> *	introduce a new structure for the new format;</i></td></tr>
<tr><th id="326">326</th><td><i> *</i></td></tr>
<tr><th id="327">327</th><td><i> *	send mail to "tcpdump-workers@lists.tcpdump.org", requesting</i></td></tr>
<tr><th id="328">328</th><td><i> *	a new magic number for your new capture file format, and, when</i></td></tr>
<tr><th id="329">329</th><td><i> *	you get the new magic number, put it in "savefile.c";</i></td></tr>
<tr><th id="330">330</th><td><i> *</i></td></tr>
<tr><th id="331">331</th><td><i> *	use that magic number for save files with the changed record</i></td></tr>
<tr><th id="332">332</th><td><i> *	header;</i></td></tr>
<tr><th id="333">333</th><td><i> *</i></td></tr>
<tr><th id="334">334</th><td><i> *	make the code in "savefile.c" capable of reading files with</i></td></tr>
<tr><th id="335">335</th><td><i> *	the old record header as well as files with the new record header</i></td></tr>
<tr><th id="336">336</th><td><i> *	(using the magic number to determine the header format).</i></td></tr>
<tr><th id="337">337</th><td><i> *</i></td></tr>
<tr><th id="338">338</th><td><i> * Then supply the changes by forking the branch at</i></td></tr>
<tr><th id="339">339</th><td><i> *</i></td></tr>
<tr><th id="340">340</th><td><i> *	<a href="https://github.com/the-tcpdump-group/libpcap/issues">https://github.com/the-tcpdump-group/libpcap/issues</a></i></td></tr>
<tr><th id="341">341</th><td><i> *</i></td></tr>
<tr><th id="342">342</th><td><i> * and issuing a pull request, so that future versions of libpcap and</i></td></tr>
<tr><th id="343">343</th><td><i> * programs that use it (such as tcpdump) will be able to read your new</i></td></tr>
<tr><th id="344">344</th><td><i> * capture file format.</i></td></tr>
<tr><th id="345">345</th><td><i> */</i></td></tr>
<tr><th id="346">346</th><td></td></tr>
<tr><th id="347">347</th><td><b>struct</b> <dfn class="type def" id="pcap_sf_pkthdr" title='pcap_sf_pkthdr' data-ref="pcap_sf_pkthdr" data-ref-filename="pcap_sf_pkthdr">pcap_sf_pkthdr</dfn> {</td></tr>
<tr><th id="348">348</th><td>    <b>struct</b> <a class="type" href="#pcap_timeval" title='pcap_timeval' data-ref="pcap_timeval" data-ref-filename="pcap_timeval">pcap_timeval</a> <dfn class="decl field" id="pcap_sf_pkthdr::ts" title='pcap_sf_pkthdr::ts' data-ref="pcap_sf_pkthdr::ts" data-ref-filename="pcap_sf_pkthdr..ts">ts</dfn>;	<i>/* time stamp */</i></td></tr>
<tr><th id="349">349</th><td>    <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_u_int32" title='bpf_u_int32' data-type='u_int' data-ref="bpf_u_int32" data-ref-filename="bpf_u_int32">bpf_u_int32</a> <dfn class="decl field" id="pcap_sf_pkthdr::caplen" title='pcap_sf_pkthdr::caplen' data-ref="pcap_sf_pkthdr::caplen" data-ref-filename="pcap_sf_pkthdr..caplen">caplen</dfn>;		<i>/* length of portion present */</i></td></tr>
<tr><th id="350">350</th><td>    <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_u_int32" title='bpf_u_int32' data-type='u_int' data-ref="bpf_u_int32" data-ref-filename="bpf_u_int32">bpf_u_int32</a> <dfn class="decl field" id="pcap_sf_pkthdr::len" title='pcap_sf_pkthdr::len' data-ref="pcap_sf_pkthdr::len" data-ref-filename="pcap_sf_pkthdr..len">len</dfn>;		<i>/* length this packet (off wire) */</i></td></tr>
<tr><th id="351">351</th><td>};</td></tr>
<tr><th id="352">352</th><td></td></tr>
<tr><th id="353">353</th><td><i>/*</i></td></tr>
<tr><th id="354">354</th><td><i> * How a `pcap_pkthdr' is actually stored in savefiles written</i></td></tr>
<tr><th id="355">355</th><td><i> * by some patched versions of libpcap (e.g. the ones in Red</i></td></tr>
<tr><th id="356">356</th><td><i> * Hat Linux 6.1 and 6.2).</i></td></tr>
<tr><th id="357">357</th><td><i> *</i></td></tr>
<tr><th id="358">358</th><td><i> * Do not change the format of this structure, in any way (this includes</i></td></tr>
<tr><th id="359">359</th><td><i> * changes that only affect the length of fields in this structure).</i></td></tr>
<tr><th id="360">360</th><td><i> * Instead, introduce a new structure, as per the above.</i></td></tr>
<tr><th id="361">361</th><td><i> */</i></td></tr>
<tr><th id="362">362</th><td></td></tr>
<tr><th id="363">363</th><td><b>struct</b> <dfn class="type def" id="pcap_sf_patched_pkthdr" title='pcap_sf_patched_pkthdr' data-ref="pcap_sf_patched_pkthdr" data-ref-filename="pcap_sf_patched_pkthdr">pcap_sf_patched_pkthdr</dfn> {</td></tr>
<tr><th id="364">364</th><td>    <b>struct</b> <a class="type" href="#pcap_timeval" title='pcap_timeval' data-ref="pcap_timeval" data-ref-filename="pcap_timeval">pcap_timeval</a> <dfn class="decl field" id="pcap_sf_patched_pkthdr::ts" title='pcap_sf_patched_pkthdr::ts' data-ref="pcap_sf_patched_pkthdr::ts" data-ref-filename="pcap_sf_patched_pkthdr..ts">ts</dfn>;	<i>/* time stamp */</i></td></tr>
<tr><th id="365">365</th><td>    <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_u_int32" title='bpf_u_int32' data-type='u_int' data-ref="bpf_u_int32" data-ref-filename="bpf_u_int32">bpf_u_int32</a> <dfn class="decl field" id="pcap_sf_patched_pkthdr::caplen" title='pcap_sf_patched_pkthdr::caplen' data-ref="pcap_sf_patched_pkthdr::caplen" data-ref-filename="pcap_sf_patched_pkthdr..caplen">caplen</dfn>;		<i>/* length of portion present */</i></td></tr>
<tr><th id="366">366</th><td>    <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_u_int32" title='bpf_u_int32' data-type='u_int' data-ref="bpf_u_int32" data-ref-filename="bpf_u_int32">bpf_u_int32</a> <dfn class="decl field" id="pcap_sf_patched_pkthdr::len" title='pcap_sf_patched_pkthdr::len' data-ref="pcap_sf_patched_pkthdr::len" data-ref-filename="pcap_sf_patched_pkthdr..len">len</dfn>;		<i>/* length this packet (off wire) */</i></td></tr>
<tr><th id="367">367</th><td>    <em>int</em>		<dfn class="decl field" id="pcap_sf_patched_pkthdr::index" title='pcap_sf_patched_pkthdr::index' data-ref="pcap_sf_patched_pkthdr::index" data-ref-filename="pcap_sf_patched_pkthdr..index">index</dfn>;</td></tr>
<tr><th id="368">368</th><td>    <em>unsigned</em> <em>short</em> <dfn class="decl field" id="pcap_sf_patched_pkthdr::protocol" title='pcap_sf_patched_pkthdr::protocol' data-ref="pcap_sf_patched_pkthdr::protocol" data-ref-filename="pcap_sf_patched_pkthdr..protocol">protocol</dfn>;</td></tr>
<tr><th id="369">369</th><td>    <em>unsigned</em> <em>char</em> <dfn class="decl field" id="pcap_sf_patched_pkthdr::pkt_type" title='pcap_sf_patched_pkthdr::pkt_type' data-ref="pcap_sf_patched_pkthdr::pkt_type" data-ref-filename="pcap_sf_patched_pkthdr..pkt_type">pkt_type</dfn>;</td></tr>
<tr><th id="370">370</th><td>};</td></tr>
<tr><th id="371">371</th><td></td></tr>
<tr><th id="372">372</th><td><i>/*</i></td></tr>
<tr><th id="373">373</th><td><i> * User data structure for the one-shot callback used for pcap_next()</i></td></tr>
<tr><th id="374">374</th><td><i> * and pcap_next_ex().</i></td></tr>
<tr><th id="375">375</th><td><i> */</i></td></tr>
<tr><th id="376">376</th><td><b>struct</b> <dfn class="type def" id="oneshot_userdata" title='oneshot_userdata' data-ref="oneshot_userdata" data-ref-filename="oneshot_userdata">oneshot_userdata</dfn> {</td></tr>
<tr><th id="377">377</th><td>	<b>struct</b> <a class="type" href="pcap/pcap.h.html#pcap_pkthdr" title='pcap_pkthdr' data-ref="pcap_pkthdr" data-ref-filename="pcap_pkthdr">pcap_pkthdr</a> *<dfn class="decl field" id="oneshot_userdata::hdr" title='oneshot_userdata::hdr' data-ref="oneshot_userdata::hdr" data-ref-filename="oneshot_userdata..hdr">hdr</dfn>;</td></tr>
<tr><th id="378">378</th><td>	<em>const</em> <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a> **<dfn class="decl field" id="oneshot_userdata::pkt" title='oneshot_userdata::pkt' data-ref="oneshot_userdata::pkt" data-ref-filename="oneshot_userdata..pkt">pkt</dfn>;</td></tr>
<tr><th id="379">379</th><td>	<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *<dfn class="decl field" id="oneshot_userdata::pd" title='oneshot_userdata::pd' data-ref="oneshot_userdata::pd" data-ref-filename="oneshot_userdata..pd">pd</dfn>;</td></tr>
<tr><th id="380">380</th><td>};</td></tr>
<tr><th id="381">381</th><td></td></tr>
<tr><th id="382">382</th><td><u>#<span data-ppcond="382">ifndef</span> <span class="macro" data-ref="_M/min">min</span></u></td></tr>
<tr><th id="383">383</th><td><u>#define <dfn class="macro" id="_M/min" data-ref="_M/min">min</dfn>(a, b) ((a) &gt; (b) ? (b) : (a))</u></td></tr>
<tr><th id="384">384</th><td><u>#<span data-ppcond="382">endif</span></u></td></tr>
<tr><th id="385">385</th><td></td></tr>
<tr><th id="386">386</th><td><em>int</em>	<dfn class="decl fn" id="pcap_offline_read" title='pcap_offline_read' data-ref="pcap_offline_read" data-ref-filename="pcap_offline_read">pcap_offline_read</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <em>int</em>, <a class="typedef" href="pcap/pcap.h.html#pcap_handler" title='pcap_handler' data-type='void (*)(u_char *, const struct pcap_pkthdr *, const u_char *)' data-ref="pcap_handler" data-ref-filename="pcap_handler">pcap_handler</a>, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a> *);</td></tr>
<tr><th id="387">387</th><td></td></tr>
<tr><th id="388">388</th><td><u>#include &lt;stdarg.h&gt;</u></td></tr>
<tr><th id="389">389</th><td></td></tr>
<tr><th id="390">390</th><td><u>#include <a href="portability.h.html">"portability.h"</a></u></td></tr>
<tr><th id="391">391</th><td></td></tr>
<tr><th id="392">392</th><td><i>/*</i></td></tr>
<tr><th id="393">393</th><td><i> * Does the packet count argument to a module's read routine say</i></td></tr>
<tr><th id="394">394</th><td><i> * "supply packets until you run out of packets"?</i></td></tr>
<tr><th id="395">395</th><td><i> */</i></td></tr>
<tr><th id="396">396</th><td><u>#define <dfn class="macro" id="_M/PACKET_COUNT_IS_UNLIMITED" data-ref="_M/PACKET_COUNT_IS_UNLIMITED">PACKET_COUNT_IS_UNLIMITED</dfn>(count)	((count) &lt;= 0)</u></td></tr>
<tr><th id="397">397</th><td></td></tr>
<tr><th id="398">398</th><td><i>/*</i></td></tr>
<tr><th id="399">399</th><td><i> * Routines that most pcap implementations can use for non-blocking mode.</i></td></tr>
<tr><th id="400">400</th><td><i> */</i></td></tr>
<tr><th id="401">401</th><td><u>#<span data-ppcond="401">if</span> !defined(<span class="macro" data-ref="_M/_WIN32">_WIN32</span>) &amp;&amp; !defined(<span class="macro" data-ref="_M/MSDOS">MSDOS</span>)</u></td></tr>
<tr><th id="402">402</th><td><em>int</em>	<dfn class="decl fn" id="pcap_getnonblock_fd" title='pcap_getnonblock_fd' data-ref="pcap_getnonblock_fd" data-ref-filename="pcap_getnonblock_fd">pcap_getnonblock_fd</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *);</td></tr>
<tr><th id="403">403</th><td><em>int</em>	<dfn class="decl fn" id="pcap_setnonblock_fd" title='pcap_setnonblock_fd' data-ref="pcap_setnonblock_fd" data-ref-filename="pcap_setnonblock_fd">pcap_setnonblock_fd</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *<dfn class="local col2 decl" id="2p" title='p' data-type='pcap_t *' data-ref="2p" data-ref-filename="2p">p</dfn>, <em>int</em>);</td></tr>
<tr><th id="404">404</th><td><u>#<span data-ppcond="401">endif</span></u></td></tr>
<tr><th id="405">405</th><td></td></tr>
<tr><th id="406">406</th><td><i>/*</i></td></tr>
<tr><th id="407">407</th><td><i> * Internal interfaces for "pcap_create()".</i></td></tr>
<tr><th id="408">408</th><td><i> *</i></td></tr>
<tr><th id="409">409</th><td><i> * "pcap_create_interface()" is the routine to do a pcap_create on</i></td></tr>
<tr><th id="410">410</th><td><i> * a regular network interface.  There are multiple implementations</i></td></tr>
<tr><th id="411">411</th><td><i> * of this, one for each platform type (Linux, BPF, DLPI, etc.),</i></td></tr>
<tr><th id="412">412</th><td><i> * with the one used chosen by the configure script.</i></td></tr>
<tr><th id="413">413</th><td><i> *</i></td></tr>
<tr><th id="414">414</th><td><i> * "pcap_create_common()" allocates and fills in a pcap_t, for use</i></td></tr>
<tr><th id="415">415</th><td><i> * by pcap_create routines.</i></td></tr>
<tr><th id="416">416</th><td><i> */</i></td></tr>
<tr><th id="417">417</th><td><a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a>	*<dfn class="decl fn" id="pcap_create_interface" title='pcap_create_interface' data-ref="pcap_create_interface" data-ref-filename="pcap_create_interface">pcap_create_interface</dfn>(<em>const</em> <em>char</em> *, <em>char</em> *);</td></tr>
<tr><th id="418">418</th><td><a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a>	*<dfn class="decl fn" id="pcap_create_common" title='pcap_create_common' data-ref="pcap_create_common" data-ref-filename="pcap_create_common">pcap_create_common</dfn>(<em>char</em> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>);</td></tr>
<tr><th id="419">419</th><td><em>int</em>	<dfn class="decl fn" id="pcap_do_addexit" title='pcap_do_addexit' data-ref="pcap_do_addexit" data-ref-filename="pcap_do_addexit">pcap_do_addexit</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *);</td></tr>
<tr><th id="420">420</th><td><em>void</em>	<dfn class="decl fn" id="pcap_add_to_pcaps_to_close" title='pcap_add_to_pcaps_to_close' data-ref="pcap_add_to_pcaps_to_close" data-ref-filename="pcap_add_to_pcaps_to_close">pcap_add_to_pcaps_to_close</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *);</td></tr>
<tr><th id="421">421</th><td><em>void</em>	<dfn class="decl fn" id="pcap_remove_from_pcaps_to_close" title='pcap_remove_from_pcaps_to_close' data-ref="pcap_remove_from_pcaps_to_close" data-ref-filename="pcap_remove_from_pcaps_to_close">pcap_remove_from_pcaps_to_close</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *);</td></tr>
<tr><th id="422">422</th><td><em>void</em>	<dfn class="decl fn" id="pcap_cleanup_live_common" title='pcap_cleanup_live_common' data-ref="pcap_cleanup_live_common" data-ref-filename="pcap_cleanup_live_common">pcap_cleanup_live_common</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *);</td></tr>
<tr><th id="423">423</th><td><em>int</em>	<dfn class="decl fn" id="pcap_check_activated" title='pcap_check_activated' data-ref="pcap_check_activated" data-ref-filename="pcap_check_activated">pcap_check_activated</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *);</td></tr>
<tr><th id="424">424</th><td></td></tr>
<tr><th id="425">425</th><td><i>/*</i></td></tr>
<tr><th id="426">426</th><td><i> * Internal interfaces for "pcap_findalldevs()".</i></td></tr>
<tr><th id="427">427</th><td><i> *</i></td></tr>
<tr><th id="428">428</th><td><i> * A pcap_if_list_t * is a reference to a list of devices.</i></td></tr>
<tr><th id="429">429</th><td><i> *</i></td></tr>
<tr><th id="430">430</th><td><i> * A get_if_flags_func is a platform-dependent function called to get</i></td></tr>
<tr><th id="431">431</th><td><i> * additional interface flags.</i></td></tr>
<tr><th id="432">432</th><td><i> *</i></td></tr>
<tr><th id="433">433</th><td><i> * "pcap_platform_finddevs()" is the platform-dependent routine to</i></td></tr>
<tr><th id="434">434</th><td><i> * find local network interfaces.</i></td></tr>
<tr><th id="435">435</th><td><i> *</i></td></tr>
<tr><th id="436">436</th><td><i> * "pcap_findalldevs_interfaces()" is a helper to find those interfaces</i></td></tr>
<tr><th id="437">437</th><td><i> * using the "standard" mechanisms (SIOCGIFCONF, "getifaddrs()", etc.).</i></td></tr>
<tr><th id="438">438</th><td><i> *</i></td></tr>
<tr><th id="439">439</th><td><i> * "add_dev()" adds an entry to a pcap_if_list_t.</i></td></tr>
<tr><th id="440">440</th><td><i> *</i></td></tr>
<tr><th id="441">441</th><td><i> * "find_dev()" tries to find a device, by name, in a pcap_if_list_t.</i></td></tr>
<tr><th id="442">442</th><td><i> *</i></td></tr>
<tr><th id="443">443</th><td><i> * "find_or_add_dev()" checks whether a device is already in a pcap_if_list_t</i></td></tr>
<tr><th id="444">444</th><td><i> * and, if not, adds an entry for it.</i></td></tr>
<tr><th id="445">445</th><td><i> */</i></td></tr>
<tr><th id="446">446</th><td><b>struct</b> <dfn class="type" id="pcap_if_list" title='pcap_if_list' data-ref="pcap_if_list" data-ref-filename="pcap_if_list">pcap_if_list</dfn>;</td></tr>
<tr><th id="447">447</th><td><b>typedef</b> <b>struct</b> <a class="type" href="#pcap_if_list" title='pcap_if_list' data-ref="pcap_if_list" data-ref-filename="pcap_if_list">pcap_if_list</a> <dfn class="typedef" id="pcap_if_list_t" title='pcap_if_list_t' data-type='struct pcap_if_list' data-ref="pcap_if_list_t" data-ref-filename="pcap_if_list_t">pcap_if_list_t</dfn>;</td></tr>
<tr><th id="448">448</th><td><b>typedef</b> <em>int</em> (*<dfn class="typedef" id="get_if_flags_func" title='get_if_flags_func' data-type='int (*)(const char *, bpf_u_int32 *, char *)' data-ref="get_if_flags_func" data-ref-filename="get_if_flags_func">get_if_flags_func</dfn>)(<em>const</em> <em>char</em> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_u_int32" title='bpf_u_int32' data-type='u_int' data-ref="bpf_u_int32" data-ref-filename="bpf_u_int32">bpf_u_int32</a> *, <em>char</em> *);</td></tr>
<tr><th id="449">449</th><td><em>int</em>	<dfn class="decl fn" id="pcap_platform_finddevs" title='pcap_platform_finddevs' data-ref="pcap_platform_finddevs" data-ref-filename="pcap_platform_finddevs">pcap_platform_finddevs</dfn>(<a class="typedef" href="#pcap_if_list_t" title='pcap_if_list_t' data-type='struct pcap_if_list' data-ref="pcap_if_list_t" data-ref-filename="pcap_if_list_t">pcap_if_list_t</a> *, <em>char</em> *);</td></tr>
<tr><th id="450">450</th><td><u>#<span data-ppcond="450">if</span> !defined(<span class="macro" data-ref="_M/_WIN32">_WIN32</span>) &amp;&amp; !defined(<span class="macro" data-ref="_M/MSDOS">MSDOS</span>)</u></td></tr>
<tr><th id="451">451</th><td><em>int</em>	<dfn class="decl fn" id="pcap_findalldevs_interfaces" title='pcap_findalldevs_interfaces' data-ref="pcap_findalldevs_interfaces" data-ref-filename="pcap_findalldevs_interfaces">pcap_findalldevs_interfaces</dfn>(<a class="typedef" href="#pcap_if_list_t" title='pcap_if_list_t' data-type='struct pcap_if_list' data-ref="pcap_if_list_t" data-ref-filename="pcap_if_list_t">pcap_if_list_t</a> *, <em>char</em> *,</td></tr>
<tr><th id="452">452</th><td>	    <em>int</em> (*)(<em>const</em> <em>char</em> *), <a class="typedef" href="#get_if_flags_func" title='get_if_flags_func' data-type='int (*)(const char *, bpf_u_int32 *, char *)' data-ref="get_if_flags_func" data-ref-filename="get_if_flags_func">get_if_flags_func</a>);</td></tr>
<tr><th id="453">453</th><td><u>#<span data-ppcond="450">endif</span></u></td></tr>
<tr><th id="454">454</th><td><a class="typedef" href="pcap/pcap.h.html#pcap_if_t" title='pcap_if_t' data-type='struct pcap_if' data-ref="pcap_if_t" data-ref-filename="pcap_if_t">pcap_if_t</a> *<dfn class="decl fn" id="find_or_add_dev" title='find_or_add_dev' data-ref="find_or_add_dev" data-ref-filename="find_or_add_dev">find_or_add_dev</dfn>(<a class="typedef" href="#pcap_if_list_t" title='pcap_if_list_t' data-type='struct pcap_if_list' data-ref="pcap_if_list_t" data-ref-filename="pcap_if_list_t">pcap_if_list_t</a> *, <em>const</em> <em>char</em> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_u_int32" title='bpf_u_int32' data-type='u_int' data-ref="bpf_u_int32" data-ref-filename="bpf_u_int32">bpf_u_int32</a>,</td></tr>
<tr><th id="455">455</th><td>	    <a class="typedef" href="#get_if_flags_func" title='get_if_flags_func' data-type='int (*)(const char *, bpf_u_int32 *, char *)' data-ref="get_if_flags_func" data-ref-filename="get_if_flags_func">get_if_flags_func</a>, <em>const</em> <em>char</em> *, <em>char</em> *);</td></tr>
<tr><th id="456">456</th><td><a class="typedef" href="pcap/pcap.h.html#pcap_if_t" title='pcap_if_t' data-type='struct pcap_if' data-ref="pcap_if_t" data-ref-filename="pcap_if_t">pcap_if_t</a> *<dfn class="decl fn" id="find_dev" title='find_dev' data-ref="find_dev" data-ref-filename="find_dev">find_dev</dfn>(<a class="typedef" href="#pcap_if_list_t" title='pcap_if_list_t' data-type='struct pcap_if_list' data-ref="pcap_if_list_t" data-ref-filename="pcap_if_list_t">pcap_if_list_t</a> *, <em>const</em> <em>char</em> *);</td></tr>
<tr><th id="457">457</th><td><a class="typedef" href="pcap/pcap.h.html#pcap_if_t" title='pcap_if_t' data-type='struct pcap_if' data-ref="pcap_if_t" data-ref-filename="pcap_if_t">pcap_if_t</a> *<dfn class="decl fn" id="add_dev" title='add_dev' data-ref="add_dev" data-ref-filename="add_dev">add_dev</dfn>(<a class="typedef" href="#pcap_if_list_t" title='pcap_if_list_t' data-type='struct pcap_if_list' data-ref="pcap_if_list_t" data-ref-filename="pcap_if_list_t">pcap_if_list_t</a> *, <em>const</em> <em>char</em> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_u_int32" title='bpf_u_int32' data-type='u_int' data-ref="bpf_u_int32" data-ref-filename="bpf_u_int32">bpf_u_int32</a>, <em>const</em> <em>char</em> *,</td></tr>
<tr><th id="458">458</th><td>	    <em>char</em> *);</td></tr>
<tr><th id="459">459</th><td><em>int</em>	<dfn class="decl fn" id="add_addr_to_dev" title='add_addr_to_dev' data-ref="add_addr_to_dev" data-ref-filename="add_addr_to_dev">add_addr_to_dev</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_if_t" title='pcap_if_t' data-type='struct pcap_if' data-ref="pcap_if_t" data-ref-filename="pcap_if_t">pcap_if_t</a> *, <b>struct</b> <a class="type" href="pcap/pcap.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>,</td></tr>
<tr><th id="460">460</th><td>	    <b>struct</b> <a class="type" href="pcap/pcap.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>, <b>struct</b> <a class="type" href="pcap/pcap.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>,</td></tr>
<tr><th id="461">461</th><td>	    <b>struct</b> <a class="type" href="pcap/pcap.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *<dfn class="local col3 decl" id="3dstaddr" title='dstaddr' data-type='struct sockaddr *' data-ref="3dstaddr" data-ref-filename="3dstaddr">dstaddr</dfn>, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>, <em>char</em> *<dfn class="local col4 decl" id="4errbuf" title='errbuf' data-type='char *' data-ref="4errbuf" data-ref-filename="4errbuf">errbuf</dfn>);</td></tr>
<tr><th id="462">462</th><td><u>#<span data-ppcond="462">ifndef</span> <span class="macro" data-ref="_M/_WIN32">_WIN32</span></u></td></tr>
<tr><th id="463">463</th><td><a class="typedef" href="pcap/pcap.h.html#pcap_if_t" title='pcap_if_t' data-type='struct pcap_if' data-ref="pcap_if_t" data-ref-filename="pcap_if_t">pcap_if_t</a> *<dfn class="decl fn" id="find_or_add_if" title='find_or_add_if' data-ref="find_or_add_if" data-ref-filename="find_or_add_if">find_or_add_if</dfn>(<a class="typedef" href="#pcap_if_list_t" title='pcap_if_list_t' data-type='struct pcap_if_list' data-ref="pcap_if_list_t" data-ref-filename="pcap_if_list_t">pcap_if_list_t</a> *, <em>const</em> <em>char</em> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_u_int32" title='bpf_u_int32' data-type='u_int' data-ref="bpf_u_int32" data-ref-filename="bpf_u_int32">bpf_u_int32</a>,</td></tr>
<tr><th id="464">464</th><td>	    <a class="typedef" href="#get_if_flags_func" title='get_if_flags_func' data-type='int (*)(const char *, bpf_u_int32 *, char *)' data-ref="get_if_flags_func" data-ref-filename="get_if_flags_func">get_if_flags_func</a>, <em>char</em> *);</td></tr>
<tr><th id="465">465</th><td><em>int</em>	<dfn class="decl fn" id="add_addr_to_if" title='add_addr_to_if' data-ref="add_addr_to_if" data-ref-filename="add_addr_to_if">add_addr_to_if</dfn>(<a class="typedef" href="#pcap_if_list_t" title='pcap_if_list_t' data-type='struct pcap_if_list' data-ref="pcap_if_list_t" data-ref-filename="pcap_if_list_t">pcap_if_list_t</a> *, <em>const</em> <em>char</em> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_u_int32" title='bpf_u_int32' data-type='u_int' data-ref="bpf_u_int32" data-ref-filename="bpf_u_int32">bpf_u_int32</a>,</td></tr>
<tr><th id="466">466</th><td>	    <a class="typedef" href="#get_if_flags_func" title='get_if_flags_func' data-type='int (*)(const char *, bpf_u_int32 *, char *)' data-ref="get_if_flags_func" data-ref-filename="get_if_flags_func">get_if_flags_func</a>,</td></tr>
<tr><th id="467">467</th><td>	    <b>struct</b> <a class="type" href="pcap/pcap.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>, <b>struct</b> <a class="type" href="pcap/pcap.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>,</td></tr>
<tr><th id="468">468</th><td>	    <b>struct</b> <a class="type" href="pcap/pcap.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>, <b>struct</b> <a class="type" href="pcap/pcap.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>, <em>char</em> *);</td></tr>
<tr><th id="469">469</th><td><u>#<span data-ppcond="462">endif</span></u></td></tr>
<tr><th id="470">470</th><td></td></tr>
<tr><th id="471">471</th><td><i>/*</i></td></tr>
<tr><th id="472">472</th><td><i> * Internal interfaces for "pcap_open_offline()".</i></td></tr>
<tr><th id="473">473</th><td><i> *</i></td></tr>
<tr><th id="474">474</th><td><i> * "pcap_open_offline_common()" allocates and fills in a pcap_t, for use</i></td></tr>
<tr><th id="475">475</th><td><i> * by pcap_open_offline routines.</i></td></tr>
<tr><th id="476">476</th><td><i> *</i></td></tr>
<tr><th id="477">477</th><td><i> * "sf_cleanup()" closes the file handle associated with a pcap_t, if</i></td></tr>
<tr><th id="478">478</th><td><i> * appropriate, and frees all data common to all modules for handling</i></td></tr>
<tr><th id="479">479</th><td><i> * savefile types.</i></td></tr>
<tr><th id="480">480</th><td><i> */</i></td></tr>
<tr><th id="481">481</th><td><a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a>	*<dfn class="decl fn" id="pcap_open_offline_common" title='pcap_open_offline_common' data-ref="pcap_open_offline_common" data-ref-filename="pcap_open_offline_common">pcap_open_offline_common</dfn>(<em>char</em> *<dfn class="local col5 decl" id="5ebuf" title='ebuf' data-type='char *' data-ref="5ebuf" data-ref-filename="5ebuf">ebuf</dfn>, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="local col6 decl" id="6size" title='size' data-type='size_t' data-ref="6size" data-ref-filename="6size">size</dfn>);</td></tr>
<tr><th id="482">482</th><td><em>void</em>	<dfn class="decl fn" id="sf_cleanup" title='sf_cleanup' data-ref="sf_cleanup" data-ref-filename="sf_cleanup">sf_cleanup</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *<dfn class="local col7 decl" id="7p" title='p' data-type='pcap_t *' data-ref="7p" data-ref-filename="7p">p</dfn>);</td></tr>
<tr><th id="483">483</th><td></td></tr>
<tr><th id="484">484</th><td><i>/*</i></td></tr>
<tr><th id="485">485</th><td><i> * Internal interfaces for both "pcap_create()" and routines that</i></td></tr>
<tr><th id="486">486</th><td><i> * open savefiles.</i></td></tr>
<tr><th id="487">487</th><td><i> *</i></td></tr>
<tr><th id="488">488</th><td><i> * "pcap_oneshot()" is the standard one-shot callback for "pcap_next()"</i></td></tr>
<tr><th id="489">489</th><td><i> * and "pcap_next_ex()".</i></td></tr>
<tr><th id="490">490</th><td><i> */</i></td></tr>
<tr><th id="491">491</th><td><em>void</em>	<dfn class="decl fn" id="pcap_oneshot" title='pcap_oneshot' data-ref="pcap_oneshot" data-ref-filename="pcap_oneshot">pcap_oneshot</dfn>(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a> *, <em>const</em> <b>struct</b> <a class="type" href="pcap/pcap.h.html#pcap_pkthdr" title='pcap_pkthdr' data-ref="pcap_pkthdr" data-ref-filename="pcap_pkthdr">pcap_pkthdr</a> *, <em>const</em> <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a> *);</td></tr>
<tr><th id="492">492</th><td></td></tr>
<tr><th id="493">493</th><td><u>#<span data-ppcond="493">ifdef</span> <span class="macro" data-ref="_M/_WIN32">_WIN32</span></u></td></tr>
<tr><th id="494">494</th><td><em>void</em>	pcap_win32_err_to_str(DWORD, <em>char</em> *);</td></tr>
<tr><th id="495">495</th><td><u>#<span data-ppcond="493">endif</span></u></td></tr>
<tr><th id="496">496</th><td></td></tr>
<tr><th id="497">497</th><td><em>int</em>	<dfn class="decl fn" id="install_bpf_program" title='install_bpf_program' data-ref="install_bpf_program" data-ref-filename="install_bpf_program">install_bpf_program</dfn>(<a class="typedef" href="pcap/pcap.h.html#pcap_t" title='pcap_t' data-type='struct pcap' data-ref="pcap_t" data-ref-filename="pcap_t">pcap_t</a> *, <b>struct</b> <a class="type" href="../../../../objdir.amd64/destdir.amd64/usr/include/net/bpf.h.html#bpf_program" title='bpf_program' data-ref="bpf_program" data-ref-filename="bpf_program">bpf_program</a> *);</td></tr>
<tr><th id="498">498</th><td></td></tr>
<tr><th id="499">499</th><td><em>int</em>	<dfn class="decl fn" id="pcap_strcasecmp" title='pcap_strcasecmp' data-ref="pcap_strcasecmp" data-ref-filename="pcap_strcasecmp">pcap_strcasecmp</dfn>(<em>const</em> <em>char</em> *, <em>const</em> <em>char</em> *);</td></tr>
<tr><th id="500">500</th><td></td></tr>
<tr><th id="501">501</th><td><u>#<span data-ppcond="501">ifdef</span> <span class="macro" data-ref="_M/YYDEBUG">YYDEBUG</span></u></td></tr>
<tr><th id="502">502</th><td><b>extern</b> <em>int</em> pcap_debug;</td></tr>
<tr><th id="503">503</th><td><u>#<span data-ppcond="501">endif</span></u></td></tr>
<tr><th id="504">504</th><td></td></tr>
<tr><th id="505">505</th><td><u>#<span data-ppcond="505">ifdef</span> <span class="macro" data-ref="_M/__cplusplus">__cplusplus</span></u></td></tr>
<tr><th id="506">506</th><td>}</td></tr>
<tr><th id="507">507</th><td><u>#<span data-ppcond="505">endif</span></u></td></tr>
<tr><th id="508">508</th><td></td></tr>
<tr><th id="509">509</th><td><u>#<span data-ppcond="36">endif</span></u></td></tr>
<tr><th id="510">510</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='bpf_image.c.html'>netbsd/external/bsd/libpcap/dist/bpf_image.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
