<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>eloop.h source code [netbsd/external/bsd/wpa/dist/src/utils/eloop.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/external/bsd/wpa/dist/src/utils/eloop.h'; var root_path = '../../../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../../..'>netbsd</a>/<a href='../../../../..'>external</a>/<a href='../../../..'>bsd</a>/<a href='../../..'>wpa</a>/<a href='../..'>dist</a>/<a href='..'>src</a>/<a href='./'>utils</a>/<a href='eloop.h.html'>eloop.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*</i></td></tr>
<tr><th id="2">2</th><td><i> * Event loop</i></td></tr>
<tr><th id="3">3</th><td><i> * Copyright (c) 2002-2006, Jouni Malinen &lt;j@w1.fi&gt;</i></td></tr>
<tr><th id="4">4</th><td><i> *</i></td></tr>
<tr><th id="5">5</th><td><i> * This software may be distributed under the terms of the BSD license.</i></td></tr>
<tr><th id="6">6</th><td><i> * See README for more details.</i></td></tr>
<tr><th id="7">7</th><td><i> *</i></td></tr>
<tr><th id="8">8</th><td><i> * This file defines an event loop interface that supports processing events</i></td></tr>
<tr><th id="9">9</th><td><i> * from registered timeouts (i.e., do something after N seconds), sockets</i></td></tr>
<tr><th id="10">10</th><td><i> * (e.g., a new packet available for reading), and signals. eloop.c is an</i></td></tr>
<tr><th id="11">11</th><td><i> * implementation of this interface using select() and sockets. This is</i></td></tr>
<tr><th id="12">12</th><td><i> * suitable for most UNIX/POSIX systems. When porting to other operating</i></td></tr>
<tr><th id="13">13</th><td><i> * systems, it may be necessary to replace that implementation with OS specific</i></td></tr>
<tr><th id="14">14</th><td><i> * mechanisms.</i></td></tr>
<tr><th id="15">15</th><td><i> */</i></td></tr>
<tr><th id="16">16</th><td></td></tr>
<tr><th id="17">17</th><td><u>#<span data-ppcond="17">ifndef</span> <span class="macro" data-ref="_M/ELOOP_H">ELOOP_H</span></u></td></tr>
<tr><th id="18">18</th><td><u>#define <dfn class="macro" id="_M/ELOOP_H" data-ref="_M/ELOOP_H">ELOOP_H</dfn></u></td></tr>
<tr><th id="19">19</th><td></td></tr>
<tr><th id="20">20</th><td><i class="doc">/**</i></td></tr>
<tr><th id="21">21</th><td><i class="doc"> * ELOOP_ALL_CTX - eloop_cancel_timeout() magic number to match all timeouts</i></td></tr>
<tr><th id="22">22</th><td><i class="doc"> */</i></td></tr>
<tr><th id="23">23</th><td><u>#define <dfn class="macro" id="_M/ELOOP_ALL_CTX" data-ref="_M/ELOOP_ALL_CTX">ELOOP_ALL_CTX</dfn> (void *) -1</u></td></tr>
<tr><th id="24">24</th><td></td></tr>
<tr><th id="25">25</th><td><i class="doc">/**</i></td></tr>
<tr><th id="26">26</th><td><i class="doc"> * eloop_event_type - eloop socket event type for eloop_register_sock()</i></td></tr>
<tr><th id="27">27</th><td><i class="doc"> *<span class="command"> @EVENT</span>_TYPE_READ: Socket has data available for reading</i></td></tr>
<tr><th id="28">28</th><td><i class="doc"> *<span class="command"> @EVENT</span>_TYPE_WRITE: Socket has room for new data to be written</i></td></tr>
<tr><th id="29">29</th><td><i class="doc"> *<span class="command"> @EVENT</span>_TYPE_EXCEPTION: An exception has been reported</i></td></tr>
<tr><th id="30">30</th><td><i class="doc"> */</i></td></tr>
<tr><th id="31">31</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="32">32</th><td>	<dfn class="enum" id="EVENT_TYPE_READ" title='EVENT_TYPE_READ' data-ref="EVENT_TYPE_READ" data-ref-filename="EVENT_TYPE_READ">EVENT_TYPE_READ</dfn> = <var>0</var>,</td></tr>
<tr><th id="33">33</th><td>	<dfn class="enum" id="EVENT_TYPE_WRITE" title='EVENT_TYPE_WRITE' data-ref="EVENT_TYPE_WRITE" data-ref-filename="EVENT_TYPE_WRITE">EVENT_TYPE_WRITE</dfn>,</td></tr>
<tr><th id="34">34</th><td>	<dfn class="enum" id="EVENT_TYPE_EXCEPTION" title='EVENT_TYPE_EXCEPTION' data-ref="EVENT_TYPE_EXCEPTION" data-ref-filename="EVENT_TYPE_EXCEPTION">EVENT_TYPE_EXCEPTION</dfn></td></tr>
<tr><th id="35">35</th><td>} <dfn class="typedef" id="eloop_event_type" title='eloop_event_type' data-type='enum eloop_event_type' data-ref="eloop_event_type" data-ref-filename="eloop_event_type">eloop_event_type</dfn>;</td></tr>
<tr><th id="36">36</th><td></td></tr>
<tr><th id="37">37</th><td><i class="doc">/**</i></td></tr>
<tr><th id="38">38</th><td><i class="doc"> * eloop_sock_handler - eloop socket event callback type</i></td></tr>
<tr><th id="39">39</th><td><i class="doc"> *<span class="command"> @sock</span>: File descriptor number for the socket</i></td></tr>
<tr><th id="40">40</th><td><i class="doc"> *<span class="command"> @eloop</span>_ctx: Registered callback context data (eloop_data)</i></td></tr>
<tr><th id="41">41</th><td><i class="doc"> *<span class="command"> @sock</span>_ctx: Registered callback context data (user_data)</i></td></tr>
<tr><th id="42">42</th><td><i class="doc"> */</i></td></tr>
<tr><th id="43">43</th><td><b>typedef</b> <em>void</em> (*<dfn class="typedef" id="eloop_sock_handler" title='eloop_sock_handler' data-type='void (*)(int, void *, void *)' data-ref="eloop_sock_handler" data-ref-filename="eloop_sock_handler">eloop_sock_handler</dfn>)(<em>int</em> <dfn class="local col1 decl" id="1sock" title='sock' data-type='int' data-ref="1sock" data-ref-filename="1sock">sock</dfn>, <em>void</em> *<dfn class="local col2 decl" id="2eloop_ctx" title='eloop_ctx' data-type='void *' data-ref="2eloop_ctx" data-ref-filename="2eloop_ctx">eloop_ctx</dfn>, <em>void</em> *<dfn class="local col3 decl" id="3sock_ctx" title='sock_ctx' data-type='void *' data-ref="3sock_ctx" data-ref-filename="3sock_ctx">sock_ctx</dfn>);</td></tr>
<tr><th id="44">44</th><td></td></tr>
<tr><th id="45">45</th><td><i class="doc">/**</i></td></tr>
<tr><th id="46">46</th><td><i class="doc"> * eloop_event_handler - eloop generic event callback type</i></td></tr>
<tr><th id="47">47</th><td><i class="doc"> *<span class="command"> @eloop</span>_ctx: Registered callback context data (eloop_data)</i></td></tr>
<tr><th id="48">48</th><td><i class="doc"> *<span class="command"> @user</span>_ctx: Registered callback context data (user_data)</i></td></tr>
<tr><th id="49">49</th><td><i class="doc"> */</i></td></tr>
<tr><th id="50">50</th><td><b>typedef</b> <em>void</em> (*<dfn class="typedef" id="eloop_event_handler" title='eloop_event_handler' data-type='void (*)(void *, void *)' data-ref="eloop_event_handler" data-ref-filename="eloop_event_handler">eloop_event_handler</dfn>)(<em>void</em> *<dfn class="local col4 decl" id="4eloop_ctx" title='eloop_ctx' data-type='void *' data-ref="4eloop_ctx" data-ref-filename="4eloop_ctx">eloop_ctx</dfn>, <em>void</em> *<dfn class="local col5 decl" id="5user_ctx" title='user_ctx' data-type='void *' data-ref="5user_ctx" data-ref-filename="5user_ctx">user_ctx</dfn>);</td></tr>
<tr><th id="51">51</th><td></td></tr>
<tr><th id="52">52</th><td><i class="doc">/**</i></td></tr>
<tr><th id="53">53</th><td><i class="doc"> * eloop_timeout_handler - eloop timeout event callback type</i></td></tr>
<tr><th id="54">54</th><td><i class="doc"> *<span class="command"> @eloop</span>_ctx: Registered callback context data (eloop_data)</i></td></tr>
<tr><th id="55">55</th><td><i class="doc"> *<span class="command"> @user</span>_ctx: Registered callback context data (user_data)</i></td></tr>
<tr><th id="56">56</th><td><i class="doc"> */</i></td></tr>
<tr><th id="57">57</th><td><b>typedef</b> <em>void</em> (*<dfn class="typedef" id="eloop_timeout_handler" title='eloop_timeout_handler' data-type='void (*)(void *, void *)' data-ref="eloop_timeout_handler" data-ref-filename="eloop_timeout_handler">eloop_timeout_handler</dfn>)(<em>void</em> *<dfn class="local col6 decl" id="6eloop_ctx" title='eloop_ctx' data-type='void *' data-ref="6eloop_ctx" data-ref-filename="6eloop_ctx">eloop_ctx</dfn>, <em>void</em> *<dfn class="local col7 decl" id="7user_ctx" title='user_ctx' data-type='void *' data-ref="7user_ctx" data-ref-filename="7user_ctx">user_ctx</dfn>);</td></tr>
<tr><th id="58">58</th><td></td></tr>
<tr><th id="59">59</th><td><i class="doc">/**</i></td></tr>
<tr><th id="60">60</th><td><i class="doc"> * eloop_signal_handler - eloop signal event callback type</i></td></tr>
<tr><th id="61">61</th><td><i class="doc"> *<span class="command"> @sig</span>: Signal number</i></td></tr>
<tr><th id="62">62</th><td><i class="doc"> *<span class="command"> @signal</span>_ctx: Registered callback context data (user_data from</i></td></tr>
<tr><th id="63">63</th><td><i class="doc"> * eloop_register_signal(), eloop_register_signal_terminate(), or</i></td></tr>
<tr><th id="64">64</th><td><i class="doc"> * eloop_register_signal_reconfig() call)</i></td></tr>
<tr><th id="65">65</th><td><i class="doc"> */</i></td></tr>
<tr><th id="66">66</th><td><b>typedef</b> <em>void</em> (*<dfn class="typedef" id="eloop_signal_handler" title='eloop_signal_handler' data-type='void (*)(int, void *)' data-ref="eloop_signal_handler" data-ref-filename="eloop_signal_handler">eloop_signal_handler</dfn>)(<em>int</em> <dfn class="local col8 decl" id="8sig" title='sig' data-type='int' data-ref="8sig" data-ref-filename="8sig">sig</dfn>, <em>void</em> *<dfn class="local col9 decl" id="9signal_ctx" title='signal_ctx' data-type='void *' data-ref="9signal_ctx" data-ref-filename="9signal_ctx">signal_ctx</dfn>);</td></tr>
<tr><th id="67">67</th><td></td></tr>
<tr><th id="68">68</th><td><i class="doc">/**</i></td></tr>
<tr><th id="69">69</th><td><i class="doc"> * eloop_init() - Initialize global event loop data</i></td></tr>
<tr><th id="70">70</th><td><i class="doc"> * Returns: 0 on success, -1 on failure</i></td></tr>
<tr><th id="71">71</th><td><i class="doc"> *</i></td></tr>
<tr><th id="72">72</th><td><i class="doc"> * This function must be called before any other eloop_* function.</i></td></tr>
<tr><th id="73">73</th><td><i class="doc"> */</i></td></tr>
<tr><th id="74">74</th><td><em>int</em> <dfn class="decl fn" id="eloop_init" title='eloop_init' data-ref="eloop_init" data-ref-filename="eloop_init">eloop_init</dfn>(<em>void</em>);</td></tr>
<tr><th id="75">75</th><td></td></tr>
<tr><th id="76">76</th><td><i class="doc">/**</i></td></tr>
<tr><th id="77">77</th><td><i class="doc"> * eloop_register_read_sock - Register handler for read events</i></td></tr>
<tr><th id="78">78</th><td><i class="doc"> *<span class="command"> @sock</span>: File descriptor number for the socket</i></td></tr>
<tr><th id="79">79</th><td><i class="doc"> *<span class="command"> @handler</span>: Callback function to be called when data is available for reading</i></td></tr>
<tr><th id="80">80</th><td><i class="doc"> *<span class="command"> @eloop</span>_data: Callback context data (eloop_ctx)</i></td></tr>
<tr><th id="81">81</th><td><i class="doc"> *<span class="command"> @user</span>_data: Callback context data (sock_ctx)</i></td></tr>
<tr><th id="82">82</th><td><i class="doc"> * Returns: 0 on success, -1 on failure</i></td></tr>
<tr><th id="83">83</th><td><i class="doc"> *</i></td></tr>
<tr><th id="84">84</th><td><i class="doc"> * Register a read socket notifier for the given file descriptor. The handler</i></td></tr>
<tr><th id="85">85</th><td><i class="doc"> * function will be called whenever data is available for reading from the</i></td></tr>
<tr><th id="86">86</th><td><i class="doc"> * socket. The handler function is responsible for clearing the event after</i></td></tr>
<tr><th id="87">87</th><td><i class="doc"> * having processed it in order to avoid eloop from calling the handler again</i></td></tr>
<tr><th id="88">88</th><td><i class="doc"> * for the same event.</i></td></tr>
<tr><th id="89">89</th><td><i class="doc"> */</i></td></tr>
<tr><th id="90">90</th><td><em>int</em> <dfn class="decl fn" id="eloop_register_read_sock" title='eloop_register_read_sock' data-ref="eloop_register_read_sock" data-ref-filename="eloop_register_read_sock">eloop_register_read_sock</dfn>(<em>int</em> <dfn class="local col0 decl" id="10sock" title='sock' data-type='int' data-ref="10sock" data-ref-filename="10sock">sock</dfn>, <a class="typedef" href="#eloop_sock_handler" title='eloop_sock_handler' data-type='void (*)(int, void *, void *)' data-ref="eloop_sock_handler" data-ref-filename="eloop_sock_handler">eloop_sock_handler</a> <dfn class="local col1 decl" id="11handler" title='handler' data-type='eloop_sock_handler' data-ref="11handler" data-ref-filename="11handler">handler</dfn>,</td></tr>
<tr><th id="91">91</th><td>			     <em>void</em> *<dfn class="local col2 decl" id="12eloop_data" title='eloop_data' data-type='void *' data-ref="12eloop_data" data-ref-filename="12eloop_data">eloop_data</dfn>, <em>void</em> *<dfn class="local col3 decl" id="13user_data" title='user_data' data-type='void *' data-ref="13user_data" data-ref-filename="13user_data">user_data</dfn>);</td></tr>
<tr><th id="92">92</th><td></td></tr>
<tr><th id="93">93</th><td><i class="doc">/**</i></td></tr>
<tr><th id="94">94</th><td><i class="doc"> * eloop_unregister_read_sock - Unregister handler for read events</i></td></tr>
<tr><th id="95">95</th><td><i class="doc"> *<span class="command"> @sock</span>: File descriptor number for the socket</i></td></tr>
<tr><th id="96">96</th><td><i class="doc"> *</i></td></tr>
<tr><th id="97">97</th><td><i class="doc"> * Unregister a read socket notifier that was previously registered with</i></td></tr>
<tr><th id="98">98</th><td><i class="doc"> * eloop_register_read_sock().</i></td></tr>
<tr><th id="99">99</th><td><i class="doc"> */</i></td></tr>
<tr><th id="100">100</th><td><em>void</em> <dfn class="decl fn" id="eloop_unregister_read_sock" title='eloop_unregister_read_sock' data-ref="eloop_unregister_read_sock" data-ref-filename="eloop_unregister_read_sock">eloop_unregister_read_sock</dfn>(<em>int</em> <dfn class="local col4 decl" id="14sock" title='sock' data-type='int' data-ref="14sock" data-ref-filename="14sock">sock</dfn>);</td></tr>
<tr><th id="101">101</th><td></td></tr>
<tr><th id="102">102</th><td><i class="doc">/**</i></td></tr>
<tr><th id="103">103</th><td><i class="doc"> * eloop_register_sock - Register handler for socket events</i></td></tr>
<tr><th id="104">104</th><td><i class="doc"> *<span class="command"> @sock</span>: File descriptor number for the socket</i></td></tr>
<tr><th id="105">105</th><td><i class="doc"> *<span class="command"> @type</span>: Type of event to wait for</i></td></tr>
<tr><th id="106">106</th><td><i class="doc"> *<span class="command"> @handler</span>: Callback function to be called when the event is triggered</i></td></tr>
<tr><th id="107">107</th><td><i class="doc"> *<span class="command"> @eloop</span>_data: Callback context data (eloop_ctx)</i></td></tr>
<tr><th id="108">108</th><td><i class="doc"> *<span class="command"> @user</span>_data: Callback context data (sock_ctx)</i></td></tr>
<tr><th id="109">109</th><td><i class="doc"> * Returns: 0 on success, -1 on failure</i></td></tr>
<tr><th id="110">110</th><td><i class="doc"> *</i></td></tr>
<tr><th id="111">111</th><td><i class="doc"> * Register an event notifier for the given socket's file descriptor. The</i></td></tr>
<tr><th id="112">112</th><td><i class="doc"> * handler function will be called whenever the that event is triggered for the</i></td></tr>
<tr><th id="113">113</th><td><i class="doc"> * socket. The handler function is responsible for clearing the event after</i></td></tr>
<tr><th id="114">114</th><td><i class="doc"> * having processed it in order to avoid eloop from calling the handler again</i></td></tr>
<tr><th id="115">115</th><td><i class="doc"> * for the same event.</i></td></tr>
<tr><th id="116">116</th><td><i class="doc"> */</i></td></tr>
<tr><th id="117">117</th><td><em>int</em> <dfn class="decl fn" id="eloop_register_sock" title='eloop_register_sock' data-ref="eloop_register_sock" data-ref-filename="eloop_register_sock">eloop_register_sock</dfn>(<em>int</em> <dfn class="local col5 decl" id="15sock" title='sock' data-type='int' data-ref="15sock" data-ref-filename="15sock">sock</dfn>, <a class="typedef" href="#eloop_event_type" title='eloop_event_type' data-type='enum eloop_event_type' data-ref="eloop_event_type" data-ref-filename="eloop_event_type">eloop_event_type</a> <dfn class="local col6 decl" id="16type" title='type' data-type='eloop_event_type' data-ref="16type" data-ref-filename="16type">type</dfn>,</td></tr>
<tr><th id="118">118</th><td>			<a class="typedef" href="#eloop_sock_handler" title='eloop_sock_handler' data-type='void (*)(int, void *, void *)' data-ref="eloop_sock_handler" data-ref-filename="eloop_sock_handler">eloop_sock_handler</a> <dfn class="local col7 decl" id="17handler" title='handler' data-type='eloop_sock_handler' data-ref="17handler" data-ref-filename="17handler">handler</dfn>,</td></tr>
<tr><th id="119">119</th><td>			<em>void</em> *<dfn class="local col8 decl" id="18eloop_data" title='eloop_data' data-type='void *' data-ref="18eloop_data" data-ref-filename="18eloop_data">eloop_data</dfn>, <em>void</em> *<dfn class="local col9 decl" id="19user_data" title='user_data' data-type='void *' data-ref="19user_data" data-ref-filename="19user_data">user_data</dfn>);</td></tr>
<tr><th id="120">120</th><td></td></tr>
<tr><th id="121">121</th><td><i class="doc">/**</i></td></tr>
<tr><th id="122">122</th><td><i class="doc"> * eloop_unregister_sock - Unregister handler for socket events</i></td></tr>
<tr><th id="123">123</th><td><i class="doc"> *<span class="command"> @sock</span>: File descriptor number for the socket</i></td></tr>
<tr><th id="124">124</th><td><i class="doc"> *<span class="command"> @type</span>: Type of event for which sock was registered</i></td></tr>
<tr><th id="125">125</th><td><i class="doc"> *</i></td></tr>
<tr><th id="126">126</th><td><i class="doc"> * Unregister a socket event notifier that was previously registered with</i></td></tr>
<tr><th id="127">127</th><td><i class="doc"> * eloop_register_sock().</i></td></tr>
<tr><th id="128">128</th><td><i class="doc"> */</i></td></tr>
<tr><th id="129">129</th><td><em>void</em> <dfn class="decl fn" id="eloop_unregister_sock" title='eloop_unregister_sock' data-ref="eloop_unregister_sock" data-ref-filename="eloop_unregister_sock">eloop_unregister_sock</dfn>(<em>int</em> <dfn class="local col0 decl" id="20sock" title='sock' data-type='int' data-ref="20sock" data-ref-filename="20sock">sock</dfn>, <a class="typedef" href="#eloop_event_type" title='eloop_event_type' data-type='enum eloop_event_type' data-ref="eloop_event_type" data-ref-filename="eloop_event_type">eloop_event_type</a> <dfn class="local col1 decl" id="21type" title='type' data-type='eloop_event_type' data-ref="21type" data-ref-filename="21type">type</dfn>);</td></tr>
<tr><th id="130">130</th><td></td></tr>
<tr><th id="131">131</th><td><i class="doc">/**</i></td></tr>
<tr><th id="132">132</th><td><i class="doc"> * eloop_register_event - Register handler for generic events</i></td></tr>
<tr><th id="133">133</th><td><i class="doc"> *<span class="command"> @event</span>: Event to wait (eloop implementation specific)</i></td></tr>
<tr><th id="134">134</th><td><i class="doc"> *<span class="command"> @event</span>_size: Size of event data</i></td></tr>
<tr><th id="135">135</th><td><i class="doc"> *<span class="command"> @handler</span>: Callback function to be called when event is triggered</i></td></tr>
<tr><th id="136">136</th><td><i class="doc"> *<span class="command"> @eloop</span>_data: Callback context data (eloop_data)</i></td></tr>
<tr><th id="137">137</th><td><i class="doc"> *<span class="command"> @user</span>_data: Callback context data (user_data)</i></td></tr>
<tr><th id="138">138</th><td><i class="doc"> * Returns: 0 on success, -1 on failure</i></td></tr>
<tr><th id="139">139</th><td><i class="doc"> *</i></td></tr>
<tr><th id="140">140</th><td><i class="doc"> * Register an event handler for the given event. This function is used to</i></td></tr>
<tr><th id="141">141</th><td><i class="doc"> * register eloop implementation specific events which are mainly targeted for</i></td></tr>
<tr><th id="142">142</th><td><i class="doc"> * operating system specific code (driver interface and l2_packet) since the</i></td></tr>
<tr><th id="143">143</th><td><i class="doc"> * portable code will not be able to use such an OS-specific call. The handler</i></td></tr>
<tr><th id="144">144</th><td><i class="doc"> * function will be called whenever the event is triggered. The handler</i></td></tr>
<tr><th id="145">145</th><td><i class="doc"> * function is responsible for clearing the event after having processed it in</i></td></tr>
<tr><th id="146">146</th><td><i class="doc"> * order to avoid eloop from calling the handler again for the same event.</i></td></tr>
<tr><th id="147">147</th><td><i class="doc"> *</i></td></tr>
<tr><th id="148">148</th><td><i class="doc"> * In case of Windows implementation (eloop_win.c), event pointer is of HANDLE</i></td></tr>
<tr><th id="149">149</th><td><i class="doc"> * type, i.e., void*. The callers are likely to have 'HANDLE h' type variable,</i></td></tr>
<tr><th id="150">150</th><td><i class="doc"> * and they would call this function with eloop_register_event(h, sizeof(h),</i></td></tr>
<tr><th id="151">151</th><td><i class="doc"> * ...).</i></td></tr>
<tr><th id="152">152</th><td><i class="doc"> */</i></td></tr>
<tr><th id="153">153</th><td><em>int</em> <dfn class="decl fn" id="eloop_register_event" title='eloop_register_event' data-ref="eloop_register_event" data-ref-filename="eloop_register_event">eloop_register_event</dfn>(<em>void</em> *<dfn class="local col2 decl" id="22event" title='event' data-type='void *' data-ref="22event" data-ref-filename="22event">event</dfn>, <a class="typedef" href="../../../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned long' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="local col3 decl" id="23event_size" title='event_size' data-type='size_t' data-ref="23event_size" data-ref-filename="23event_size">event_size</dfn>,</td></tr>
<tr><th id="154">154</th><td>			 <a class="typedef" href="#eloop_event_handler" title='eloop_event_handler' data-type='void (*)(void *, void *)' data-ref="eloop_event_handler" data-ref-filename="eloop_event_handler">eloop_event_handler</a> <dfn class="local col4 decl" id="24handler" title='handler' data-type='eloop_event_handler' data-ref="24handler" data-ref-filename="24handler">handler</dfn>,</td></tr>
<tr><th id="155">155</th><td>			 <em>void</em> *<dfn class="local col5 decl" id="25eloop_data" title='eloop_data' data-type='void *' data-ref="25eloop_data" data-ref-filename="25eloop_data">eloop_data</dfn>, <em>void</em> *<dfn class="local col6 decl" id="26user_data" title='user_data' data-type='void *' data-ref="26user_data" data-ref-filename="26user_data">user_data</dfn>);</td></tr>
<tr><th id="156">156</th><td></td></tr>
<tr><th id="157">157</th><td><i class="doc">/**</i></td></tr>
<tr><th id="158">158</th><td><i class="doc"> * eloop_unregister_event - Unregister handler for a generic event</i></td></tr>
<tr><th id="159">159</th><td><i class="doc"> *<span class="command"> @event</span>: Event to cancel (eloop implementation specific)</i></td></tr>
<tr><th id="160">160</th><td><i class="doc"> *<span class="command"> @event</span>_size: Size of event data</i></td></tr>
<tr><th id="161">161</th><td><i class="doc"> *</i></td></tr>
<tr><th id="162">162</th><td><i class="doc"> * Unregister a generic event notifier that was previously registered with</i></td></tr>
<tr><th id="163">163</th><td><i class="doc"> * eloop_register_event().</i></td></tr>
<tr><th id="164">164</th><td><i class="doc"> */</i></td></tr>
<tr><th id="165">165</th><td><em>void</em> <dfn class="decl fn" id="eloop_unregister_event" title='eloop_unregister_event' data-ref="eloop_unregister_event" data-ref-filename="eloop_unregister_event">eloop_unregister_event</dfn>(<em>void</em> *<dfn class="local col7 decl" id="27event" title='event' data-type='void *' data-ref="27event" data-ref-filename="27event">event</dfn>, <a class="typedef" href="../../../../../../objdir.amd64/destdir.amd64/usr/include/sys/types.h.html#size_t" title='size_t' data-type='unsigned long' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="local col8 decl" id="28event_size" title='event_size' data-type='size_t' data-ref="28event_size" data-ref-filename="28event_size">event_size</dfn>);</td></tr>
<tr><th id="166">166</th><td></td></tr>
<tr><th id="167">167</th><td><i class="doc">/**</i></td></tr>
<tr><th id="168">168</th><td><i class="doc"> * eloop_register_timeout - Register timeout</i></td></tr>
<tr><th id="169">169</th><td><i class="doc"> *<span class="command"> @secs</span>: Number of seconds to the timeout</i></td></tr>
<tr><th id="170">170</th><td><i class="doc"> *<span class="command"> @usecs</span>: Number of microseconds to the timeout</i></td></tr>
<tr><th id="171">171</th><td><i class="doc"> *<span class="command"> @handler</span>: Callback function to be called when timeout occurs</i></td></tr>
<tr><th id="172">172</th><td><i class="doc"> *<span class="command"> @eloop</span>_data: Callback context data (eloop_ctx)</i></td></tr>
<tr><th id="173">173</th><td><i class="doc"> *<span class="command"> @user</span>_data: Callback context data (sock_ctx)</i></td></tr>
<tr><th id="174">174</th><td><i class="doc"> * Returns: 0 on success, -1 on failure</i></td></tr>
<tr><th id="175">175</th><td><i class="doc"> *</i></td></tr>
<tr><th id="176">176</th><td><i class="doc"> * Register a timeout that will cause the handler function to be called after</i></td></tr>
<tr><th id="177">177</th><td><i class="doc"> * given time.</i></td></tr>
<tr><th id="178">178</th><td><i class="doc"> */</i></td></tr>
<tr><th id="179">179</th><td><em>int</em> <dfn class="decl fn" id="eloop_register_timeout" title='eloop_register_timeout' data-ref="eloop_register_timeout" data-ref-filename="eloop_register_timeout">eloop_register_timeout</dfn>(<em>unsigned</em> <em>int</em> <dfn class="local col9 decl" id="29secs" title='secs' data-type='unsigned int' data-ref="29secs" data-ref-filename="29secs">secs</dfn>, <em>unsigned</em> <em>int</em> <dfn class="local col0 decl" id="30usecs" title='usecs' data-type='unsigned int' data-ref="30usecs" data-ref-filename="30usecs">usecs</dfn>,</td></tr>
<tr><th id="180">180</th><td>			   <a class="typedef" href="#eloop_timeout_handler" title='eloop_timeout_handler' data-type='void (*)(void *, void *)' data-ref="eloop_timeout_handler" data-ref-filename="eloop_timeout_handler">eloop_timeout_handler</a> <dfn class="local col1 decl" id="31handler" title='handler' data-type='eloop_timeout_handler' data-ref="31handler" data-ref-filename="31handler">handler</dfn>,</td></tr>
<tr><th id="181">181</th><td>			   <em>void</em> *<dfn class="local col2 decl" id="32eloop_data" title='eloop_data' data-type='void *' data-ref="32eloop_data" data-ref-filename="32eloop_data">eloop_data</dfn>, <em>void</em> *<dfn class="local col3 decl" id="33user_data" title='user_data' data-type='void *' data-ref="33user_data" data-ref-filename="33user_data">user_data</dfn>);</td></tr>
<tr><th id="182">182</th><td></td></tr>
<tr><th id="183">183</th><td><i class="doc">/**</i></td></tr>
<tr><th id="184">184</th><td><i class="doc"> * eloop_cancel_timeout - Cancel timeouts</i></td></tr>
<tr><th id="185">185</th><td><i class="doc"> *<span class="command"> @handler</span>: Matching callback function</i></td></tr>
<tr><th id="186">186</th><td><i class="doc"> *<span class="command"> @eloop</span>_data: Matching eloop_data or %ELOOP_ALL_CTX to match all</i></td></tr>
<tr><th id="187">187</th><td><i class="doc"> *<span class="command"> @user</span>_data: Matching user_data or %ELOOP_ALL_CTX to match all</i></td></tr>
<tr><th id="188">188</th><td><i class="doc"> * Returns: Number of cancelled timeouts</i></td></tr>
<tr><th id="189">189</th><td><i class="doc"> *</i></td></tr>
<tr><th id="190">190</th><td><i class="doc"> * Cancel matching &lt;handler,eloop_data,user_data&gt; timeouts registered with</i></td></tr>
<tr><th id="191">191</th><td><i class="doc"> * eloop_register_timeout(). ELOOP_ALL_CTX can be used as a wildcard for</i></td></tr>
<tr><th id="192">192</th><td><i class="doc"> * cancelling all timeouts regardless of eloop_data/user_data.</i></td></tr>
<tr><th id="193">193</th><td><i class="doc"> */</i></td></tr>
<tr><th id="194">194</th><td><em>int</em> <dfn class="decl fn" id="eloop_cancel_timeout" title='eloop_cancel_timeout' data-ref="eloop_cancel_timeout" data-ref-filename="eloop_cancel_timeout">eloop_cancel_timeout</dfn>(<a class="typedef" href="#eloop_timeout_handler" title='eloop_timeout_handler' data-type='void (*)(void *, void *)' data-ref="eloop_timeout_handler" data-ref-filename="eloop_timeout_handler">eloop_timeout_handler</a> <dfn class="local col4 decl" id="34handler" title='handler' data-type='eloop_timeout_handler' data-ref="34handler" data-ref-filename="34handler">handler</dfn>,</td></tr>
<tr><th id="195">195</th><td>			 <em>void</em> *<dfn class="local col5 decl" id="35eloop_data" title='eloop_data' data-type='void *' data-ref="35eloop_data" data-ref-filename="35eloop_data">eloop_data</dfn>, <em>void</em> *<dfn class="local col6 decl" id="36user_data" title='user_data' data-type='void *' data-ref="36user_data" data-ref-filename="36user_data">user_data</dfn>);</td></tr>
<tr><th id="196">196</th><td></td></tr>
<tr><th id="197">197</th><td><i class="doc">/**</i></td></tr>
<tr><th id="198">198</th><td><i class="doc"> * eloop_cancel_timeout_one - Cancel a single timeout</i></td></tr>
<tr><th id="199">199</th><td><i class="doc"> *<span class="command"> @handler</span>: Matching callback function</i></td></tr>
<tr><th id="200">200</th><td><i class="doc"> *<span class="command"> @eloop</span>_data: Matching eloop_data</i></td></tr>
<tr><th id="201">201</th><td><i class="doc"> *<span class="command"> @user</span>_data: Matching user_data</i></td></tr>
<tr><th id="202">202</th><td><i class="doc"> *<span class="command"> @remaining</span>: Time left on the cancelled timer</i></td></tr>
<tr><th id="203">203</th><td><i class="doc"> * Returns: Number of cancelled timeouts</i></td></tr>
<tr><th id="204">204</th><td><i class="doc"> *</i></td></tr>
<tr><th id="205">205</th><td><i class="doc"> * Cancel matching &lt;handler,eloop_data,user_data&gt; timeout registered with</i></td></tr>
<tr><th id="206">206</th><td><i class="doc"> * eloop_register_timeout() and return the remaining time left.</i></td></tr>
<tr><th id="207">207</th><td><i class="doc"> */</i></td></tr>
<tr><th id="208">208</th><td><em>int</em> <dfn class="decl fn" id="eloop_cancel_timeout_one" title='eloop_cancel_timeout_one' data-ref="eloop_cancel_timeout_one" data-ref-filename="eloop_cancel_timeout_one">eloop_cancel_timeout_one</dfn>(<a class="typedef" href="#eloop_timeout_handler" title='eloop_timeout_handler' data-type='void (*)(void *, void *)' data-ref="eloop_timeout_handler" data-ref-filename="eloop_timeout_handler">eloop_timeout_handler</a> <dfn class="local col7 decl" id="37handler" title='handler' data-type='eloop_timeout_handler' data-ref="37handler" data-ref-filename="37handler">handler</dfn>,</td></tr>
<tr><th id="209">209</th><td>			     <em>void</em> *<dfn class="local col8 decl" id="38eloop_data" title='eloop_data' data-type='void *' data-ref="38eloop_data" data-ref-filename="38eloop_data">eloop_data</dfn>, <em>void</em> *<dfn class="local col9 decl" id="39user_data" title='user_data' data-type='void *' data-ref="39user_data" data-ref-filename="39user_data">user_data</dfn>,</td></tr>
<tr><th id="210">210</th><td>			     <b>struct</b> <a class="type" href="os.h.html#os_reltime" title='os_reltime' data-ref="os_reltime" data-ref-filename="os_reltime">os_reltime</a> *<dfn class="local col0 decl" id="40remaining" title='remaining' data-type='struct os_reltime *' data-ref="40remaining" data-ref-filename="40remaining">remaining</dfn>);</td></tr>
<tr><th id="211">211</th><td></td></tr>
<tr><th id="212">212</th><td><i class="doc">/**</i></td></tr>
<tr><th id="213">213</th><td><i class="doc"> * eloop_is_timeout_registered - Check if a timeout is already registered</i></td></tr>
<tr><th id="214">214</th><td><i class="doc"> *<span class="command"> @handler</span>: Matching callback function</i></td></tr>
<tr><th id="215">215</th><td><i class="doc"> *<span class="command"> @eloop</span>_data: Matching eloop_data</i></td></tr>
<tr><th id="216">216</th><td><i class="doc"> *<span class="command"> @user</span>_data: Matching user_data</i></td></tr>
<tr><th id="217">217</th><td><i class="doc"> * Returns: 1 if the timeout is registered, 0 if the timeout is not registered</i></td></tr>
<tr><th id="218">218</th><td><i class="doc"> *</i></td></tr>
<tr><th id="219">219</th><td><i class="doc"> * Determine if a matching &lt;handler,eloop_data,user_data&gt; timeout is registered</i></td></tr>
<tr><th id="220">220</th><td><i class="doc"> * with eloop_register_timeout().</i></td></tr>
<tr><th id="221">221</th><td><i class="doc"> */</i></td></tr>
<tr><th id="222">222</th><td><em>int</em> <dfn class="decl fn" id="eloop_is_timeout_registered" title='eloop_is_timeout_registered' data-ref="eloop_is_timeout_registered" data-ref-filename="eloop_is_timeout_registered">eloop_is_timeout_registered</dfn>(<a class="typedef" href="#eloop_timeout_handler" title='eloop_timeout_handler' data-type='void (*)(void *, void *)' data-ref="eloop_timeout_handler" data-ref-filename="eloop_timeout_handler">eloop_timeout_handler</a> <dfn class="local col1 decl" id="41handler" title='handler' data-type='eloop_timeout_handler' data-ref="41handler" data-ref-filename="41handler">handler</dfn>,</td></tr>
<tr><th id="223">223</th><td>				<em>void</em> *<dfn class="local col2 decl" id="42eloop_data" title='eloop_data' data-type='void *' data-ref="42eloop_data" data-ref-filename="42eloop_data">eloop_data</dfn>, <em>void</em> *<dfn class="local col3 decl" id="43user_data" title='user_data' data-type='void *' data-ref="43user_data" data-ref-filename="43user_data">user_data</dfn>);</td></tr>
<tr><th id="224">224</th><td></td></tr>
<tr><th id="225">225</th><td><i class="doc">/**</i></td></tr>
<tr><th id="226">226</th><td><i class="doc"> * eloop_deplete_timeout - Deplete a timeout that is already registered</i></td></tr>
<tr><th id="227">227</th><td><i class="doc"> * <span class="command">@req</span>_<span class="verb">secs: Requested number of seconds to the timeout</span></i></td></tr>
<tr><th id="228">228</th><td><i class="doc"> * <span class="command">@req</span>_<span class="verb">usecs: Requested number of microseconds to the timeout</span></i></td></tr>
<tr><th id="229">229</th><td><i class="doc"> *<span class="command"> @handler</span>: Matching callback function</i></td></tr>
<tr><th id="230">230</th><td><i class="doc"> *<span class="command"> @eloop</span>_data: Matching eloop_data</i></td></tr>
<tr><th id="231">231</th><td><i class="doc"> *<span class="command"> @user</span>_data: Matching user_data</i></td></tr>
<tr><th id="232">232</th><td><i class="doc"> * Returns: 1 if the timeout is depleted, 0 if no change is made, -1 if no</i></td></tr>
<tr><th id="233">233</th><td><i class="doc"> * timeout matched</i></td></tr>
<tr><th id="234">234</th><td><i class="doc"> *</i></td></tr>
<tr><th id="235">235</th><td><i class="doc"> * Find a registered matching &lt;handler,eloop_data,user_data&gt; timeout. If found,</i></td></tr>
<tr><th id="236">236</th><td><i class="doc"> * deplete the timeout if remaining time is more than the requested time.</i></td></tr>
<tr><th id="237">237</th><td><i class="doc"> */</i></td></tr>
<tr><th id="238">238</th><td><em>int</em> <dfn class="decl fn" id="eloop_deplete_timeout" title='eloop_deplete_timeout' data-ref="eloop_deplete_timeout" data-ref-filename="eloop_deplete_timeout">eloop_deplete_timeout</dfn>(<em>unsigned</em> <em>int</em> <dfn class="local col4 decl" id="44req_secs" title='req_secs' data-type='unsigned int' data-ref="44req_secs" data-ref-filename="44req_secs">req_secs</dfn>, <em>unsigned</em> <em>int</em> <dfn class="local col5 decl" id="45req_usecs" title='req_usecs' data-type='unsigned int' data-ref="45req_usecs" data-ref-filename="45req_usecs">req_usecs</dfn>,</td></tr>
<tr><th id="239">239</th><td>			  <a class="typedef" href="#eloop_timeout_handler" title='eloop_timeout_handler' data-type='void (*)(void *, void *)' data-ref="eloop_timeout_handler" data-ref-filename="eloop_timeout_handler">eloop_timeout_handler</a> <dfn class="local col6 decl" id="46handler" title='handler' data-type='eloop_timeout_handler' data-ref="46handler" data-ref-filename="46handler">handler</dfn>, <em>void</em> *<dfn class="local col7 decl" id="47eloop_data" title='eloop_data' data-type='void *' data-ref="47eloop_data" data-ref-filename="47eloop_data">eloop_data</dfn>,</td></tr>
<tr><th id="240">240</th><td>			  <em>void</em> *<dfn class="local col8 decl" id="48user_data" title='user_data' data-type='void *' data-ref="48user_data" data-ref-filename="48user_data">user_data</dfn>);</td></tr>
<tr><th id="241">241</th><td></td></tr>
<tr><th id="242">242</th><td><i class="doc">/**</i></td></tr>
<tr><th id="243">243</th><td><i class="doc"> * eloop_replenish_timeout - Replenish a timeout that is already registered</i></td></tr>
<tr><th id="244">244</th><td><i class="doc"> * <span class="command">@req</span>_<span class="verb">secs: Requested number of seconds to the timeout</span></i></td></tr>
<tr><th id="245">245</th><td><i class="doc"> * <span class="command">@req</span>_<span class="verb">usecs: Requested number of microseconds to the timeout</span></i></td></tr>
<tr><th id="246">246</th><td><i class="doc"> *<span class="command"> @handler</span>: Matching callback function</i></td></tr>
<tr><th id="247">247</th><td><i class="doc"> *<span class="command"> @eloop</span>_data: Matching eloop_data</i></td></tr>
<tr><th id="248">248</th><td><i class="doc"> *<span class="command"> @user</span>_data: Matching user_data</i></td></tr>
<tr><th id="249">249</th><td><i class="doc"> * Returns: 1 if the timeout is replenished, 0 if no change is made, -1 if no</i></td></tr>
<tr><th id="250">250</th><td><i class="doc"> * timeout matched</i></td></tr>
<tr><th id="251">251</th><td><i class="doc"> *</i></td></tr>
<tr><th id="252">252</th><td><i class="doc"> * Find a registered matching &lt;handler,eloop_data,user_data&gt; timeout. If found,</i></td></tr>
<tr><th id="253">253</th><td><i class="doc"> * replenish the timeout if remaining time is less than the requested time.</i></td></tr>
<tr><th id="254">254</th><td><i class="doc"> */</i></td></tr>
<tr><th id="255">255</th><td><em>int</em> <dfn class="decl fn" id="eloop_replenish_timeout" title='eloop_replenish_timeout' data-ref="eloop_replenish_timeout" data-ref-filename="eloop_replenish_timeout">eloop_replenish_timeout</dfn>(<em>unsigned</em> <em>int</em> <dfn class="local col9 decl" id="49req_secs" title='req_secs' data-type='unsigned int' data-ref="49req_secs" data-ref-filename="49req_secs">req_secs</dfn>, <em>unsigned</em> <em>int</em> <dfn class="local col0 decl" id="50req_usecs" title='req_usecs' data-type='unsigned int' data-ref="50req_usecs" data-ref-filename="50req_usecs">req_usecs</dfn>,</td></tr>
<tr><th id="256">256</th><td>			    <a class="typedef" href="#eloop_timeout_handler" title='eloop_timeout_handler' data-type='void (*)(void *, void *)' data-ref="eloop_timeout_handler" data-ref-filename="eloop_timeout_handler">eloop_timeout_handler</a> <dfn class="local col1 decl" id="51handler" title='handler' data-type='eloop_timeout_handler' data-ref="51handler" data-ref-filename="51handler">handler</dfn>, <em>void</em> *<dfn class="local col2 decl" id="52eloop_data" title='eloop_data' data-type='void *' data-ref="52eloop_data" data-ref-filename="52eloop_data">eloop_data</dfn>,</td></tr>
<tr><th id="257">257</th><td>			    <em>void</em> *<dfn class="local col3 decl" id="53user_data" title='user_data' data-type='void *' data-ref="53user_data" data-ref-filename="53user_data">user_data</dfn>);</td></tr>
<tr><th id="258">258</th><td></td></tr>
<tr><th id="259">259</th><td><i class="doc">/**</i></td></tr>
<tr><th id="260">260</th><td><i class="doc"> * eloop_register_signal - Register handler for signals</i></td></tr>
<tr><th id="261">261</th><td><i class="doc"> *<span class="command"> @sig</span>: Signal number (e.g., SIGHUP)</i></td></tr>
<tr><th id="262">262</th><td><i class="doc"> *<span class="command"> @handler</span>: Callback function to be called when the signal is received</i></td></tr>
<tr><th id="263">263</th><td><i class="doc"> *<span class="command"> @user</span>_data: Callback context data (signal_ctx)</i></td></tr>
<tr><th id="264">264</th><td><i class="doc"> * Returns: 0 on success, -1 on failure</i></td></tr>
<tr><th id="265">265</th><td><i class="doc"> *</i></td></tr>
<tr><th id="266">266</th><td><i class="doc"> * Register a callback function that will be called when a signal is received.</i></td></tr>
<tr><th id="267">267</th><td><i class="doc"> * The callback function is actually called only after the system signal</i></td></tr>
<tr><th id="268">268</th><td><i class="doc"> * handler has returned. This means that the normal limits for sighandlers</i></td></tr>
<tr><th id="269">269</th><td><i class="doc"> * (i.e., only "safe functions" allowed) do not apply for the registered</i></td></tr>
<tr><th id="270">270</th><td><i class="doc"> * callback.</i></td></tr>
<tr><th id="271">271</th><td><i class="doc"> */</i></td></tr>
<tr><th id="272">272</th><td><em>int</em> <dfn class="decl fn" id="eloop_register_signal" title='eloop_register_signal' data-ref="eloop_register_signal" data-ref-filename="eloop_register_signal">eloop_register_signal</dfn>(<em>int</em> <dfn class="local col4 decl" id="54sig" title='sig' data-type='int' data-ref="54sig" data-ref-filename="54sig">sig</dfn>, <a class="typedef" href="#eloop_signal_handler" title='eloop_signal_handler' data-type='void (*)(int, void *)' data-ref="eloop_signal_handler" data-ref-filename="eloop_signal_handler">eloop_signal_handler</a> <dfn class="local col5 decl" id="55handler" title='handler' data-type='eloop_signal_handler' data-ref="55handler" data-ref-filename="55handler">handler</dfn>,</td></tr>
<tr><th id="273">273</th><td>			  <em>void</em> *<dfn class="local col6 decl" id="56user_data" title='user_data' data-type='void *' data-ref="56user_data" data-ref-filename="56user_data">user_data</dfn>);</td></tr>
<tr><th id="274">274</th><td></td></tr>
<tr><th id="275">275</th><td><i class="doc">/**</i></td></tr>
<tr><th id="276">276</th><td><i class="doc"> * eloop_register_signal_terminate - Register handler for terminate signals</i></td></tr>
<tr><th id="277">277</th><td><i class="doc"> *<span class="command"> @handler</span>: Callback function to be called when the signal is received</i></td></tr>
<tr><th id="278">278</th><td><i class="doc"> *<span class="command"> @user</span>_data: Callback context data (signal_ctx)</i></td></tr>
<tr><th id="279">279</th><td><i class="doc"> * Returns: 0 on success, -1 on failure</i></td></tr>
<tr><th id="280">280</th><td><i class="doc"> *</i></td></tr>
<tr><th id="281">281</th><td><i class="doc"> * Register a callback function that will be called when a process termination</i></td></tr>
<tr><th id="282">282</th><td><i class="doc"> * signal is received. The callback function is actually called only after the</i></td></tr>
<tr><th id="283">283</th><td><i class="doc"> * system signal handler has returned. This means that the normal limits for</i></td></tr>
<tr><th id="284">284</th><td><i class="doc"> * sighandlers (i.e., only "safe functions" allowed) do not apply for the</i></td></tr>
<tr><th id="285">285</th><td><i class="doc"> * registered callback.</i></td></tr>
<tr><th id="286">286</th><td><i class="doc"> *</i></td></tr>
<tr><th id="287">287</th><td><i class="doc"> * This function is a more portable version of eloop_register_signal() since</i></td></tr>
<tr><th id="288">288</th><td><i class="doc"> * the knowledge of exact details of the signals is hidden in eloop</i></td></tr>
<tr><th id="289">289</th><td><i class="doc"> * implementation. In case of operating systems using signal(), this function</i></td></tr>
<tr><th id="290">290</th><td><i class="doc"> * registers handlers for SIGINT and SIGTERM.</i></td></tr>
<tr><th id="291">291</th><td><i class="doc"> */</i></td></tr>
<tr><th id="292">292</th><td><em>int</em> <dfn class="decl fn" id="eloop_register_signal_terminate" title='eloop_register_signal_terminate' data-ref="eloop_register_signal_terminate" data-ref-filename="eloop_register_signal_terminate">eloop_register_signal_terminate</dfn>(<a class="typedef" href="#eloop_signal_handler" title='eloop_signal_handler' data-type='void (*)(int, void *)' data-ref="eloop_signal_handler" data-ref-filename="eloop_signal_handler">eloop_signal_handler</a> <dfn class="local col7 decl" id="57handler" title='handler' data-type='eloop_signal_handler' data-ref="57handler" data-ref-filename="57handler">handler</dfn>,</td></tr>
<tr><th id="293">293</th><td>				    <em>void</em> *<dfn class="local col8 decl" id="58user_data" title='user_data' data-type='void *' data-ref="58user_data" data-ref-filename="58user_data">user_data</dfn>);</td></tr>
<tr><th id="294">294</th><td></td></tr>
<tr><th id="295">295</th><td><i class="doc">/**</i></td></tr>
<tr><th id="296">296</th><td><i class="doc"> * eloop_register_signal_reconfig - Register handler for reconfig signals</i></td></tr>
<tr><th id="297">297</th><td><i class="doc"> *<span class="command"> @handler</span>: Callback function to be called when the signal is received</i></td></tr>
<tr><th id="298">298</th><td><i class="doc"> *<span class="command"> @user</span>_data: Callback context data (signal_ctx)</i></td></tr>
<tr><th id="299">299</th><td><i class="doc"> * Returns: 0 on success, -1 on failure</i></td></tr>
<tr><th id="300">300</th><td><i class="doc"> *</i></td></tr>
<tr><th id="301">301</th><td><i class="doc"> * Register a callback function that will be called when a reconfiguration /</i></td></tr>
<tr><th id="302">302</th><td><i class="doc"> * hangup signal is received. The callback function is actually called only</i></td></tr>
<tr><th id="303">303</th><td><i class="doc"> * after the system signal handler has returned. This means that the normal</i></td></tr>
<tr><th id="304">304</th><td><i class="doc"> * limits for sighandlers (i.e., only "safe functions" allowed) do not apply</i></td></tr>
<tr><th id="305">305</th><td><i class="doc"> * for the registered callback.</i></td></tr>
<tr><th id="306">306</th><td><i class="doc"> *</i></td></tr>
<tr><th id="307">307</th><td><i class="doc"> * This function is a more portable version of eloop_register_signal() since</i></td></tr>
<tr><th id="308">308</th><td><i class="doc"> * the knowledge of exact details of the signals is hidden in eloop</i></td></tr>
<tr><th id="309">309</th><td><i class="doc"> * implementation. In case of operating systems using signal(), this function</i></td></tr>
<tr><th id="310">310</th><td><i class="doc"> * registers a handler for SIGHUP.</i></td></tr>
<tr><th id="311">311</th><td><i class="doc"> */</i></td></tr>
<tr><th id="312">312</th><td><em>int</em> <dfn class="decl fn" id="eloop_register_signal_reconfig" title='eloop_register_signal_reconfig' data-ref="eloop_register_signal_reconfig" data-ref-filename="eloop_register_signal_reconfig">eloop_register_signal_reconfig</dfn>(<a class="typedef" href="#eloop_signal_handler" title='eloop_signal_handler' data-type='void (*)(int, void *)' data-ref="eloop_signal_handler" data-ref-filename="eloop_signal_handler">eloop_signal_handler</a> <dfn class="local col9 decl" id="59handler" title='handler' data-type='eloop_signal_handler' data-ref="59handler" data-ref-filename="59handler">handler</dfn>,</td></tr>
<tr><th id="313">313</th><td>				   <em>void</em> *<dfn class="local col0 decl" id="60user_data" title='user_data' data-type='void *' data-ref="60user_data" data-ref-filename="60user_data">user_data</dfn>);</td></tr>
<tr><th id="314">314</th><td></td></tr>
<tr><th id="315">315</th><td><i class="doc">/**</i></td></tr>
<tr><th id="316">316</th><td><i class="doc"> * eloop_sock_requeue - Requeue sockets</i></td></tr>
<tr><th id="317">317</th><td><i class="doc"> *</i></td></tr>
<tr><th id="318">318</th><td><i class="doc"> * Requeue sockets after forking because some implementations require this,</i></td></tr>
<tr><th id="319">319</th><td><i class="doc"> * such as epoll and kqueue.</i></td></tr>
<tr><th id="320">320</th><td><i class="doc"> */</i></td></tr>
<tr><th id="321">321</th><td><em>int</em> <dfn class="decl fn" id="eloop_sock_requeue" title='eloop_sock_requeue' data-ref="eloop_sock_requeue" data-ref-filename="eloop_sock_requeue">eloop_sock_requeue</dfn>(<em>void</em>);</td></tr>
<tr><th id="322">322</th><td></td></tr>
<tr><th id="323">323</th><td><i class="doc">/**</i></td></tr>
<tr><th id="324">324</th><td><i class="doc"> * eloop_run - Start the event loop</i></td></tr>
<tr><th id="325">325</th><td><i class="doc"> *</i></td></tr>
<tr><th id="326">326</th><td><i class="doc"> * Start the event loop and continue running as long as there are any</i></td></tr>
<tr><th id="327">327</th><td><i class="doc"> * registered event handlers. This function is run after event loop has been</i></td></tr>
<tr><th id="328">328</th><td><i class="doc"> * initialized with event_init() and one or more events have been registered.</i></td></tr>
<tr><th id="329">329</th><td><i class="doc"> */</i></td></tr>
<tr><th id="330">330</th><td><em>void</em> <dfn class="decl fn" id="eloop_run" title='eloop_run' data-ref="eloop_run" data-ref-filename="eloop_run">eloop_run</dfn>(<em>void</em>);</td></tr>
<tr><th id="331">331</th><td></td></tr>
<tr><th id="332">332</th><td><i class="doc">/**</i></td></tr>
<tr><th id="333">333</th><td><i class="doc"> * eloop_terminate - Terminate event loop</i></td></tr>
<tr><th id="334">334</th><td><i class="doc"> *</i></td></tr>
<tr><th id="335">335</th><td><i class="doc"> * Terminate event loop even if there are registered events. This can be used</i></td></tr>
<tr><th id="336">336</th><td><i class="doc"> * to request the program to be terminated cleanly.</i></td></tr>
<tr><th id="337">337</th><td><i class="doc"> */</i></td></tr>
<tr><th id="338">338</th><td><em>void</em> <dfn class="decl fn" id="eloop_terminate" title='eloop_terminate' data-ref="eloop_terminate" data-ref-filename="eloop_terminate">eloop_terminate</dfn>(<em>void</em>);</td></tr>
<tr><th id="339">339</th><td></td></tr>
<tr><th id="340">340</th><td><i class="doc">/**</i></td></tr>
<tr><th id="341">341</th><td><i class="doc"> * eloop_destroy - Free any resources allocated for the event loop</i></td></tr>
<tr><th id="342">342</th><td><i class="doc"> *</i></td></tr>
<tr><th id="343">343</th><td><i class="doc"> * After calling eloop_destroy(), other eloop_* functions must not be called</i></td></tr>
<tr><th id="344">344</th><td><i class="doc"> * before re-running eloop_init().</i></td></tr>
<tr><th id="345">345</th><td><i class="doc"> */</i></td></tr>
<tr><th id="346">346</th><td><em>void</em> <dfn class="decl fn" id="eloop_destroy" title='eloop_destroy' data-ref="eloop_destroy" data-ref-filename="eloop_destroy">eloop_destroy</dfn>(<em>void</em>);</td></tr>
<tr><th id="347">347</th><td></td></tr>
<tr><th id="348">348</th><td><i class="doc">/**</i></td></tr>
<tr><th id="349">349</th><td><i class="doc"> * eloop_terminated - Check whether event loop has been terminated</i></td></tr>
<tr><th id="350">350</th><td><i class="doc"> * Returns: 1 = event loop terminate, 0 = event loop still running</i></td></tr>
<tr><th id="351">351</th><td><i class="doc"> *</i></td></tr>
<tr><th id="352">352</th><td><i class="doc"> * This function can be used to check whether eloop_terminate() has been called</i></td></tr>
<tr><th id="353">353</th><td><i class="doc"> * to request termination of the event loop. This is normally used to abort</i></td></tr>
<tr><th id="354">354</th><td><i class="doc"> * operations that may still be queued to be run when eloop_terminate() was</i></td></tr>
<tr><th id="355">355</th><td><i class="doc"> * called.</i></td></tr>
<tr><th id="356">356</th><td><i class="doc"> */</i></td></tr>
<tr><th id="357">357</th><td><em>int</em> <dfn class="decl fn" id="eloop_terminated" title='eloop_terminated' data-ref="eloop_terminated" data-ref-filename="eloop_terminated">eloop_terminated</dfn>(<em>void</em>);</td></tr>
<tr><th id="358">358</th><td></td></tr>
<tr><th id="359">359</th><td><i class="doc">/**</i></td></tr>
<tr><th id="360">360</th><td><i class="doc"> * eloop_wait_for_read_sock - Wait for a single reader</i></td></tr>
<tr><th id="361">361</th><td><i class="doc"> *<span class="command"> @sock</span>: File descriptor number for the socket</i></td></tr>
<tr><th id="362">362</th><td><i class="doc"> *</i></td></tr>
<tr><th id="363">363</th><td><i class="doc"> * Do a blocking wait for a single read socket.</i></td></tr>
<tr><th id="364">364</th><td><i class="doc"> */</i></td></tr>
<tr><th id="365">365</th><td><em>void</em> <dfn class="decl fn" id="eloop_wait_for_read_sock" title='eloop_wait_for_read_sock' data-ref="eloop_wait_for_read_sock" data-ref-filename="eloop_wait_for_read_sock">eloop_wait_for_read_sock</dfn>(<em>int</em> <dfn class="local col1 decl" id="61sock" title='sock' data-type='int' data-ref="61sock" data-ref-filename="61sock">sock</dfn>);</td></tr>
<tr><th id="366">366</th><td></td></tr>
<tr><th id="367">367</th><td><u>#<span data-ppcond="17">endif</span> /* ELOOP_H */</u></td></tr>
<tr><th id="368">368</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../hostapd/ctrl_iface.c.html'>netbsd/external/bsd/wpa/dist/hostapd/ctrl_iface.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
