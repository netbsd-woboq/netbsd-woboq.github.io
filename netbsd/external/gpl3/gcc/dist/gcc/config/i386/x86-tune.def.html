<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>x86-tune.def source code [netbsd/external/gpl3/gcc/dist/gcc/config/i386/x86-tune.def] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/external/gpl3/gcc/dist/gcc/config/i386/x86-tune.def'; var root_path = '../../../../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../../../..'>netbsd</a>/<a href='../../../../../..'>external</a>/<a href='../../../../..'>gpl3</a>/<a href='../../../..'>gcc</a>/<a href='../../..'>dist</a>/<a href='../..'>gcc</a>/<a href='..'>config</a>/<a href='./'>i386</a>/<a href='x86-tune.def.html'>x86-tune.def</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* Definitions of x86 tunable features.</i></td></tr>
<tr><th id="2">2</th><td><i>   Copyright (C) 2013-2017 Free Software Foundation, Inc.</i></td></tr>
<tr><th id="3">3</th><td><i></i></td></tr>
<tr><th id="4">4</th><td><i>This file is part of GCC.</i></td></tr>
<tr><th id="5">5</th><td><i></i></td></tr>
<tr><th id="6">6</th><td><i>GCC is free software; you can redistribute it and/or modify</i></td></tr>
<tr><th id="7">7</th><td><i>it under the terms of the GNU General Public License as published by</i></td></tr>
<tr><th id="8">8</th><td><i>the Free Software Foundation; either version 3, or (at your option)</i></td></tr>
<tr><th id="9">9</th><td><i>any later version.</i></td></tr>
<tr><th id="10">10</th><td><i></i></td></tr>
<tr><th id="11">11</th><td><i>GCC is distributed in the hope that it will be useful,</i></td></tr>
<tr><th id="12">12</th><td><i>but WITHOUT ANY WARRANTY; without even the implied warranty of</i></td></tr>
<tr><th id="13">13</th><td><i>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</i></td></tr>
<tr><th id="14">14</th><td><i>GNU General Public License for more details.</i></td></tr>
<tr><th id="15">15</th><td><i></i></td></tr>
<tr><th id="16">16</th><td><i>You should have received a copy of the GNU General Public License and</i></td></tr>
<tr><th id="17">17</th><td><i>a copy of the GCC Runtime Library Exception along with this program;</i></td></tr>
<tr><th id="18">18</th><td><i>see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</i></td></tr>
<tr><th id="19">19</th><td><i>&lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.  */</i></td></tr>
<tr><th id="20">20</th><td></td></tr>
<tr><th id="21">21</th><td><i>/* Tuning for a given CPU XXXX consists of:</i></td></tr>
<tr><th id="22">22</th><td><i>    - adding new CPU into:</i></td></tr>
<tr><th id="23">23</th><td><i>	- adding PROCESSOR_XXX to processor_type (in i386.h)</i></td></tr>
<tr><th id="24">24</th><td><i>	- possibly adding XXX into CPU attribute in i386.md</i></td></tr>
<tr><th id="25">25</th><td><i>	- adding XXX to processor_alias_table (in i386.c)</i></td></tr>
<tr><th id="26">26</th><td><i>    - introducing ix86_XXX_cost in i386.c</i></td></tr>
<tr><th id="27">27</th><td><i>	- Stringop generation table can be build based on test_stringop</i></td></tr>
<tr><th id="28">28</th><td><i>	- script (once rest of tuning is complete)</i></td></tr>
<tr><th id="29">29</th><td><i>    - designing a scheduler model in</i></td></tr>
<tr><th id="30">30</th><td><i>	- XXXX.md file</i></td></tr>
<tr><th id="31">31</th><td><i>	- Updating ix86_issue_rate and ix86_adjust_cost in i386.md</i></td></tr>
<tr><th id="32">32</th><td><i>	- possibly updating ia32_multipass_dfa_lookahead, ix86_sched_reorder</i></td></tr>
<tr><th id="33">33</th><td><i>	  and ix86_sched_init_global if those tricks are needed.</i></td></tr>
<tr><th id="34">34</th><td><i>    - Tunning the flags bellow. Those are split into sections and each</i></td></tr>
<tr><th id="35">35</th><td><i>      section is very roughly ordered by importance.  */</i></td></tr>
<tr><th id="36">36</th><td></td></tr>
<tr><th id="37">37</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="38">38</th><td><i>/* Scheduling flags. 					                     */</i></td></tr>
<tr><th id="39">39</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="40">40</th><td></td></tr>
<tr><th id="41">41</th><td><i>/* X86_TUNE_SCHEDULE: Enable scheduling.  */</i></td></tr>
<tr><th id="42">42</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SCHEDULE," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SCHEDULE" title='X86_TUNE_SCHEDULE' data-ref="X86_TUNE_SCHEDULE" data-ref-filename="X86_TUNE_SCHEDULE">X86_TUNE_SCHEDULE</dfn>, <q>"schedule"</q>,</td></tr>
<tr><th id="43">43</th><td>          m_PENT | m_LAKEMONT | m_PPRO | m_CORE_ALL | m_BONNELL | m_SILVERMONT</td></tr>
<tr><th id="44">44</th><td>	  | m_INTEL | m_KNL | m_K6_GEODE | m_AMD_MULTIPLE | m_GENERIC)</td></tr>
<tr><th id="45">45</th><td></td></tr>
<tr><th id="46">46</th><td><i>/* X86_TUNE_PARTIAL_REG_DEPENDENCY: Enable more register renaming</i></td></tr>
<tr><th id="47">47</th><td><i>   on modern chips.  Preffer stores affecting whole integer register</i></td></tr>
<tr><th id="48">48</th><td><i>   over partial stores.  For example preffer MOVZBL or MOVQ to load 8bit</i></td></tr>
<tr><th id="49">49</th><td><i>   value over movb.  */</i></td></tr>
<tr><th id="50">50</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PARTIAL_REG_DEPENDENCY," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PARTIAL_REG_DEPENDENCY" title='X86_TUNE_PARTIAL_REG_DEPENDENCY' data-ref="X86_TUNE_PARTIAL_REG_DEPENDENCY" data-ref-filename="X86_TUNE_PARTIAL_REG_DEPENDENCY">X86_TUNE_PARTIAL_REG_DEPENDENCY</dfn>, <q>"partial_reg_dependency"</q>,</td></tr>
<tr><th id="51">51</th><td>          m_P4_NOCONA | m_CORE_ALL | m_BONNELL | m_SILVERMONT | m_INTEL</td></tr>
<tr><th id="52">52</th><td>	  | m_KNL | m_AMD_MULTIPLE | m_GENERIC)</td></tr>
<tr><th id="53">53</th><td></td></tr>
<tr><th id="54">54</th><td><i>/* X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY: This knob promotes all store</i></td></tr>
<tr><th id="55">55</th><td><i>   destinations to be 128bit to allow register renaming on 128bit SSE units,</i></td></tr>
<tr><th id="56">56</th><td><i>   but usually results in one extra microop on 64bit SSE units.</i></td></tr>
<tr><th id="57">57</th><td><i>   Experimental results shows that disabling this option on P4 brings over 20%</i></td></tr>
<tr><th id="58">58</th><td><i>   SPECfp regression, while enabling it on K8 brings roughly 2.4% regression</i></td></tr>
<tr><th id="59">59</th><td><i>   that can be partly masked by careful scheduling of moves.  */</i></td></tr>
<tr><th id="60">60</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY" title='X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY' data-ref="X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY" data-ref-filename="X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY">X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY</dfn>, <q>"sse_partial_reg_dependency"</q>,</td></tr>
<tr><th id="61">61</th><td>          m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_BONNELL | m_AMDFAM10</td></tr>
<tr><th id="62">62</th><td>	  | m_BDVER | m_ZNVER1 | m_GENERIC)</td></tr>
<tr><th id="63">63</th><td></td></tr>
<tr><th id="64">64</th><td><i>/* X86_TUNE_SSE_SPLIT_REGS: Set for machines where the type and dependencies</i></td></tr>
<tr><th id="65">65</th><td><i>   are resolved on SSE register parts instead of whole registers, so we may</i></td></tr>
<tr><th id="66">66</th><td><i>   maintain just lower part of scalar values in proper format leaving the</i></td></tr>
<tr><th id="67">67</th><td><i>   upper part undefined.  */</i></td></tr>
<tr><th id="68">68</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SSE_SPLIT_REGS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SSE_SPLIT_REGS" title='X86_TUNE_SSE_SPLIT_REGS' data-ref="X86_TUNE_SSE_SPLIT_REGS" data-ref-filename="X86_TUNE_SSE_SPLIT_REGS">X86_TUNE_SSE_SPLIT_REGS</dfn>, <q>"sse_split_regs"</q>, m_ATHLON_K8)</td></tr>
<tr><th id="69">69</th><td></td></tr>
<tr><th id="70">70</th><td><i>/* X86_TUNE_PARTIAL_FLAG_REG_STALL: this flag disables use of of flags</i></td></tr>
<tr><th id="71">71</th><td><i>   set by instructions affecting just some flags (in particular shifts).</i></td></tr>
<tr><th id="72">72</th><td><i>   This is because Core2 resolves dependencies on whole flags register</i></td></tr>
<tr><th id="73">73</th><td><i>   and such sequences introduce false dependency on previous instruction</i></td></tr>
<tr><th id="74">74</th><td><i>   setting full flags.</i></td></tr>
<tr><th id="75">75</th><td><i></i></td></tr>
<tr><th id="76">76</th><td><i>   The flags does not affect generation of INC and DEC that is controlled</i></td></tr>
<tr><th id="77">77</th><td><i>   by X86_TUNE_USE_INCDEC.</i></td></tr>
<tr><th id="78">78</th><td><i></i></td></tr>
<tr><th id="79">79</th><td><i>   This flag may be dropped from generic once core2-corei5 machines are</i></td></tr>
<tr><th id="80">80</th><td><i>   rare enough.  */</i></td></tr>
<tr><th id="81">81</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PARTIAL_FLAG_REG_STALL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PARTIAL_FLAG_REG_STALL" title='X86_TUNE_PARTIAL_FLAG_REG_STALL' data-ref="X86_TUNE_PARTIAL_FLAG_REG_STALL" data-ref-filename="X86_TUNE_PARTIAL_FLAG_REG_STALL">X86_TUNE_PARTIAL_FLAG_REG_STALL</dfn>, <q>"partial_flag_reg_stall"</q>,</td></tr>
<tr><th id="82">82</th><td>          m_CORE2 | m_GENERIC)</td></tr>
<tr><th id="83">83</th><td></td></tr>
<tr><th id="84">84</th><td><i>/* X86_TUNE_MOVX: Enable to zero extend integer registers to avoid</i></td></tr>
<tr><th id="85">85</th><td><i>   partial dependencies.  */</i></td></tr>
<tr><th id="86">86</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_MOVX," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_MOVX" title='X86_TUNE_MOVX' data-ref="X86_TUNE_MOVX" data-ref-filename="X86_TUNE_MOVX">X86_TUNE_MOVX</dfn>, <q>"movx"</q>,</td></tr>
<tr><th id="87">87</th><td>          m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_BONNELL | m_SILVERMONT</td></tr>
<tr><th id="88">88</th><td>	  | m_KNL | m_INTEL | m_GEODE | m_AMD_MULTIPLE  | m_GENERIC)</td></tr>
<tr><th id="89">89</th><td></td></tr>
<tr><th id="90">90</th><td><i>/* X86_TUNE_MEMORY_MISMATCH_STALL: Avoid partial stores that are followed by</i></td></tr>
<tr><th id="91">91</th><td><i>   full sized loads.  */</i></td></tr>
<tr><th id="92">92</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_MEMORY_MISMATCH_STALL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_MEMORY_MISMATCH_STALL" title='X86_TUNE_MEMORY_MISMATCH_STALL' data-ref="X86_TUNE_MEMORY_MISMATCH_STALL" data-ref-filename="X86_TUNE_MEMORY_MISMATCH_STALL">X86_TUNE_MEMORY_MISMATCH_STALL</dfn>, <q>"memory_mismatch_stall"</q>,</td></tr>
<tr><th id="93">93</th><td>          m_P4_NOCONA | m_CORE_ALL | m_BONNELL | m_SILVERMONT | m_INTEL</td></tr>
<tr><th id="94">94</th><td>	  | m_KNL | m_AMD_MULTIPLE | m_GENERIC)</td></tr>
<tr><th id="95">95</th><td></td></tr>
<tr><th id="96">96</th><td><i>/* X86_TUNE_FUSE_CMP_AND_BRANCH_32: Fuse compare with a subsequent</i></td></tr>
<tr><th id="97">97</th><td><i>   conditional jump instruction for 32 bit TARGET.</i></td></tr>
<tr><th id="98">98</th><td><i>   FIXME: revisit for generic.  */</i></td></tr>
<tr><th id="99">99</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_FUSE_CMP_AND_BRANCH_32," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_FUSE_CMP_AND_BRANCH_32" title='X86_TUNE_FUSE_CMP_AND_BRANCH_32' data-ref="X86_TUNE_FUSE_CMP_AND_BRANCH_32" data-ref-filename="X86_TUNE_FUSE_CMP_AND_BRANCH_32">X86_TUNE_FUSE_CMP_AND_BRANCH_32</dfn>, <q>"fuse_cmp_and_branch_32"</q>,</td></tr>
<tr><th id="100">100</th><td>	  m_CORE_ALL | m_BDVER | m_ZNVER1)</td></tr>
<tr><th id="101">101</th><td></td></tr>
<tr><th id="102">102</th><td><i>/* X86_TUNE_FUSE_CMP_AND_BRANCH_64: Fuse compare with a subsequent</i></td></tr>
<tr><th id="103">103</th><td><i>   conditional jump instruction for TARGET_64BIT.</i></td></tr>
<tr><th id="104">104</th><td><i>   FIXME: revisit for generic.  */</i></td></tr>
<tr><th id="105">105</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_FUSE_CMP_AND_BRANCH_64," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_FUSE_CMP_AND_BRANCH_64" title='X86_TUNE_FUSE_CMP_AND_BRANCH_64' data-ref="X86_TUNE_FUSE_CMP_AND_BRANCH_64" data-ref-filename="X86_TUNE_FUSE_CMP_AND_BRANCH_64">X86_TUNE_FUSE_CMP_AND_BRANCH_64</dfn>, <q>"fuse_cmp_and_branch_64"</q>,</td></tr>
<tr><th id="106">106</th><td>	  m_NEHALEM | m_SANDYBRIDGE | m_HASWELL | m_BDVER | m_ZNVER1)</td></tr>
<tr><th id="107">107</th><td></td></tr>
<tr><th id="108">108</th><td><i>/* X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS: Fuse compare with a</i></td></tr>
<tr><th id="109">109</th><td><i>   subsequent conditional jump instruction when the condition jump</i></td></tr>
<tr><th id="110">110</th><td><i>   check sign flag (SF) or overflow flag (OF).  */</i></td></tr>
<tr><th id="111">111</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS" title='X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS' data-ref="X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS" data-ref-filename="X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS">X86_TUNE_FUSE_CMP_AND_BRANCH_SOFLAGS</dfn>, <q>"fuse_cmp_and_branch_soflags"</q>,</td></tr>
<tr><th id="112">112</th><td>	  m_NEHALEM | m_SANDYBRIDGE | m_HASWELL | m_BDVER | m_ZNVER1)</td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td><i>/* X86_TUNE_FUSE_ALU_AND_BRANCH: Fuse alu with a subsequent conditional</i></td></tr>
<tr><th id="115">115</th><td><i>   jump instruction when the alu instruction produces the CCFLAG consumed by</i></td></tr>
<tr><th id="116">116</th><td><i>   the conditional jump instruction. */</i></td></tr>
<tr><th id="117">117</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_FUSE_ALU_AND_BRANCH," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_FUSE_ALU_AND_BRANCH" title='X86_TUNE_FUSE_ALU_AND_BRANCH' data-ref="X86_TUNE_FUSE_ALU_AND_BRANCH" data-ref-filename="X86_TUNE_FUSE_ALU_AND_BRANCH">X86_TUNE_FUSE_ALU_AND_BRANCH</dfn>, <q>"fuse_alu_and_branch"</q>,</td></tr>
<tr><th id="118">118</th><td>          m_SANDYBRIDGE | m_HASWELL)</td></tr>
<tr><th id="119">119</th><td></td></tr>
<tr><th id="120">120</th><td><i>/* X86_TUNE_REASSOC_INT_TO_PARALLEL: Try to produce parallel computations</i></td></tr>
<tr><th id="121">121</th><td><i>   during reassociation of integer computation.  */</i></td></tr>
<tr><th id="122">122</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_REASSOC_INT_TO_PARALLEL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_REASSOC_INT_TO_PARALLEL" title='X86_TUNE_REASSOC_INT_TO_PARALLEL' data-ref="X86_TUNE_REASSOC_INT_TO_PARALLEL" data-ref-filename="X86_TUNE_REASSOC_INT_TO_PARALLEL">X86_TUNE_REASSOC_INT_TO_PARALLEL</dfn>, <q>"reassoc_int_to_parallel"</q>,</td></tr>
<tr><th id="123">123</th><td>          m_BONNELL)</td></tr>
<tr><th id="124">124</th><td></td></tr>
<tr><th id="125">125</th><td><i>/* X86_TUNE_REASSOC_FP_TO_PARALLEL: Try to produce parallel computations</i></td></tr>
<tr><th id="126">126</th><td><i>   during reassociation of fp computation.  */</i></td></tr>
<tr><th id="127">127</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_REASSOC_FP_TO_PARALLEL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_REASSOC_FP_TO_PARALLEL" title='X86_TUNE_REASSOC_FP_TO_PARALLEL' data-ref="X86_TUNE_REASSOC_FP_TO_PARALLEL" data-ref-filename="X86_TUNE_REASSOC_FP_TO_PARALLEL">X86_TUNE_REASSOC_FP_TO_PARALLEL</dfn>, <q>"reassoc_fp_to_parallel"</q>,</td></tr>
<tr><th id="128">128</th><td>          m_BONNELL | m_SILVERMONT | m_HASWELL | m_KNL |m_INTEL | m_BDVER1</td></tr>
<tr><th id="129">129</th><td>	  | m_BDVER2 | m_ZNVER1 | m_GENERIC)</td></tr>
<tr><th id="130">130</th><td></td></tr>
<tr><th id="131">131</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="132">132</th><td><i>/* Function prologue, epilogue and function calling sequences.               */</i></td></tr>
<tr><th id="133">133</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="134">134</th><td></td></tr>
<tr><th id="135">135</th><td><i>/* X86_TUNE_ACCUMULATE_OUTGOING_ARGS: Allocate stack space for outgoing</i></td></tr>
<tr><th id="136">136</th><td><i>   arguments in prologue/epilogue instead of separately for each call</i></td></tr>
<tr><th id="137">137</th><td><i>   by push/pop instructions.</i></td></tr>
<tr><th id="138">138</th><td><i>   This increase code size by about 5% in 32bit mode, less so in 64bit mode</i></td></tr>
<tr><th id="139">139</th><td><i>   because parameters are passed in registers.  It is considerable</i></td></tr>
<tr><th id="140">140</th><td><i>   win for targets without stack engine that prevents multple push operations</i></td></tr>
<tr><th id="141">141</th><td><i>   to happen in parallel.</i></td></tr>
<tr><th id="142">142</th><td><i></i></td></tr>
<tr><th id="143">143</th><td><i>   FIXME: the flags is incorrectly enabled for amdfam10, Bulldozer,</i></td></tr>
<tr><th id="144">144</th><td><i>   Bobcat and Generic.  This is because disabling it causes large</i></td></tr>
<tr><th id="145">145</th><td><i>   regression on mgrid due to IRA limitation leading to unecessary</i></td></tr>
<tr><th id="146">146</th><td><i>   use of the frame pointer in 32bit mode.  */</i></td></tr>
<tr><th id="147">147</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_ACCUMULATE_OUTGOING_ARGS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_ACCUMULATE_OUTGOING_ARGS" title='X86_TUNE_ACCUMULATE_OUTGOING_ARGS' data-ref="X86_TUNE_ACCUMULATE_OUTGOING_ARGS" data-ref-filename="X86_TUNE_ACCUMULATE_OUTGOING_ARGS">X86_TUNE_ACCUMULATE_OUTGOING_ARGS</dfn>, <q>"accumulate_outgoing_args"</q>,</td></tr>
<tr><th id="148">148</th><td>	  m_PPRO | m_P4_NOCONA | m_BONNELL | m_SILVERMONT | m_KNL | m_INTEL</td></tr>
<tr><th id="149">149</th><td>	  | m_ATHLON_K8)</td></tr>
<tr><th id="150">150</th><td></td></tr>
<tr><th id="151">151</th><td><i>/* X86_TUNE_PROLOGUE_USING_MOVE: Do not use push/pop in prologues that are</i></td></tr>
<tr><th id="152">152</th><td><i>   considered on critical path.  */</i></td></tr>
<tr><th id="153">153</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PROLOGUE_USING_MOVE," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PROLOGUE_USING_MOVE" title='X86_TUNE_PROLOGUE_USING_MOVE' data-ref="X86_TUNE_PROLOGUE_USING_MOVE" data-ref-filename="X86_TUNE_PROLOGUE_USING_MOVE">X86_TUNE_PROLOGUE_USING_MOVE</dfn>, <q>"prologue_using_move"</q>,</td></tr>
<tr><th id="154">154</th><td>          m_PPRO | m_ATHLON_K8)</td></tr>
<tr><th id="155">155</th><td></td></tr>
<tr><th id="156">156</th><td><i>/* X86_TUNE_PROLOGUE_USING_MOVE: Do not use push/pop in epilogues that are</i></td></tr>
<tr><th id="157">157</th><td><i>   considered on critical path.  */</i></td></tr>
<tr><th id="158">158</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_EPILOGUE_USING_MOVE," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_EPILOGUE_USING_MOVE" title='X86_TUNE_EPILOGUE_USING_MOVE' data-ref="X86_TUNE_EPILOGUE_USING_MOVE" data-ref-filename="X86_TUNE_EPILOGUE_USING_MOVE">X86_TUNE_EPILOGUE_USING_MOVE</dfn>, <q>"epilogue_using_move"</q>,</td></tr>
<tr><th id="159">159</th><td>          m_PPRO | m_ATHLON_K8)</td></tr>
<tr><th id="160">160</th><td></td></tr>
<tr><th id="161">161</th><td><i>/* X86_TUNE_USE_LEAVE: Use "leave" instruction in epilogues where it fits.  */</i></td></tr>
<tr><th id="162">162</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_LEAVE," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_LEAVE" title='X86_TUNE_USE_LEAVE' data-ref="X86_TUNE_USE_LEAVE" data-ref-filename="X86_TUNE_USE_LEAVE">X86_TUNE_USE_LEAVE</dfn>, <q>"use_leave"</q>,</td></tr>
<tr><th id="163">163</th><td>	  m_386 | m_CORE_ALL | m_K6_GEODE | m_AMD_MULTIPLE | m_GENERIC)</td></tr>
<tr><th id="164">164</th><td></td></tr>
<tr><th id="165">165</th><td><i>/* X86_TUNE_PUSH_MEMORY: Enable generation of "push mem" instructions.</i></td></tr>
<tr><th id="166">166</th><td><i>   Some chips, like 486 and Pentium works faster with separate load</i></td></tr>
<tr><th id="167">167</th><td><i>   and push instructions.  */</i></td></tr>
<tr><th id="168">168</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PUSH_MEMORY," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PUSH_MEMORY" title='X86_TUNE_PUSH_MEMORY' data-ref="X86_TUNE_PUSH_MEMORY" data-ref-filename="X86_TUNE_PUSH_MEMORY">X86_TUNE_PUSH_MEMORY</dfn>, <q>"push_memory"</q>,</td></tr>
<tr><th id="169">169</th><td>          m_386 | m_P4_NOCONA | m_CORE_ALL | m_K6_GEODE | m_AMD_MULTIPLE</td></tr>
<tr><th id="170">170</th><td>          | m_GENERIC)</td></tr>
<tr><th id="171">171</th><td></td></tr>
<tr><th id="172">172</th><td><i>/* X86_TUNE_SINGLE_PUSH: Enable if single push insn is preferred</i></td></tr>
<tr><th id="173">173</th><td><i>   over esp subtraction.  */</i></td></tr>
<tr><th id="174">174</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SINGLE_PUSH," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SINGLE_PUSH" title='X86_TUNE_SINGLE_PUSH' data-ref="X86_TUNE_SINGLE_PUSH" data-ref-filename="X86_TUNE_SINGLE_PUSH">X86_TUNE_SINGLE_PUSH</dfn>, <q>"single_push"</q>, m_386 | m_486 | m_PENT</td></tr>
<tr><th id="175">175</th><td>	  | m_LAKEMONT | m_K6_GEODE)</td></tr>
<tr><th id="176">176</th><td></td></tr>
<tr><th id="177">177</th><td><i>/* X86_TUNE_DOUBLE_PUSH. Enable if double push insn is preferred</i></td></tr>
<tr><th id="178">178</th><td><i>   over esp subtraction.  */</i></td></tr>
<tr><th id="179">179</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_DOUBLE_PUSH," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_DOUBLE_PUSH" title='X86_TUNE_DOUBLE_PUSH' data-ref="X86_TUNE_DOUBLE_PUSH" data-ref-filename="X86_TUNE_DOUBLE_PUSH">X86_TUNE_DOUBLE_PUSH</dfn>, <q>"double_push"</q>, m_PENT | m_LAKEMONT</td></tr>
<tr><th id="180">180</th><td>	  | m_K6_GEODE)</td></tr>
<tr><th id="181">181</th><td></td></tr>
<tr><th id="182">182</th><td><i>/* X86_TUNE_SINGLE_POP: Enable if single pop insn is preferred</i></td></tr>
<tr><th id="183">183</th><td><i>   over esp addition.  */</i></td></tr>
<tr><th id="184">184</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SINGLE_POP," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SINGLE_POP" title='X86_TUNE_SINGLE_POP' data-ref="X86_TUNE_SINGLE_POP" data-ref-filename="X86_TUNE_SINGLE_POP">X86_TUNE_SINGLE_POP</dfn>, <q>"single_pop"</q>, m_386 | m_486 | m_PENT</td></tr>
<tr><th id="185">185</th><td>	  | m_LAKEMONT | m_PPRO)</td></tr>
<tr><th id="186">186</th><td></td></tr>
<tr><th id="187">187</th><td><i>/* X86_TUNE_DOUBLE_POP: Enable if double pop insn is preferred</i></td></tr>
<tr><th id="188">188</th><td><i>   over esp addition.  */</i></td></tr>
<tr><th id="189">189</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_DOUBLE_POP," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_DOUBLE_POP" title='X86_TUNE_DOUBLE_POP' data-ref="X86_TUNE_DOUBLE_POP" data-ref-filename="X86_TUNE_DOUBLE_POP">X86_TUNE_DOUBLE_POP</dfn>, <q>"double_pop"</q>, m_PENT | m_LAKEMONT)</td></tr>
<tr><th id="190">190</th><td></td></tr>
<tr><th id="191">191</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="192">192</th><td><i>/* Branch predictor tuning  		                                     */</i></td></tr>
<tr><th id="193">193</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="194">194</th><td></td></tr>
<tr><th id="195">195</th><td><i>/* X86_TUNE_PAD_SHORT_FUNCTION: Make every function to be at least 4</i></td></tr>
<tr><th id="196">196</th><td><i>   instructions long.  */</i></td></tr>
<tr><th id="197">197</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PAD_SHORT_FUNCTION," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PAD_SHORT_FUNCTION" title='X86_TUNE_PAD_SHORT_FUNCTION' data-ref="X86_TUNE_PAD_SHORT_FUNCTION" data-ref-filename="X86_TUNE_PAD_SHORT_FUNCTION">X86_TUNE_PAD_SHORT_FUNCTION</dfn>, <q>"pad_short_function"</q>, m_BONNELL)</td></tr>
<tr><th id="198">198</th><td></td></tr>
<tr><th id="199">199</th><td><i>/* X86_TUNE_PAD_RETURNS: Place NOP before every RET that is a destination</i></td></tr>
<tr><th id="200">200</th><td><i>   of conditional jump or directly preceded by other jump instruction.</i></td></tr>
<tr><th id="201">201</th><td><i>   This is important for AND K8-AMDFAM10 because the branch prediction</i></td></tr>
<tr><th id="202">202</th><td><i>   architecture expect at most one jump per 2 byte window.  Failing to</i></td></tr>
<tr><th id="203">203</th><td><i>   pad returns leads to misaligned return stack.  */</i></td></tr>
<tr><th id="204">204</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PAD_RETURNS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PAD_RETURNS" title='X86_TUNE_PAD_RETURNS' data-ref="X86_TUNE_PAD_RETURNS" data-ref-filename="X86_TUNE_PAD_RETURNS">X86_TUNE_PAD_RETURNS</dfn>, <q>"pad_returns"</q>,</td></tr>
<tr><th id="205">205</th><td>          m_ATHLON_K8 | m_AMDFAM10 | m_GENERIC)</td></tr>
<tr><th id="206">206</th><td></td></tr>
<tr><th id="207">207</th><td><i>/* X86_TUNE_FOUR_JUMP_LIMIT: Some CPU cores are not able to predict more</i></td></tr>
<tr><th id="208">208</th><td><i>   than 4 branch instructions in the 16 byte window.  */</i></td></tr>
<tr><th id="209">209</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_FOUR_JUMP_LIMIT," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_FOUR_JUMP_LIMIT" title='X86_TUNE_FOUR_JUMP_LIMIT' data-ref="X86_TUNE_FOUR_JUMP_LIMIT" data-ref-filename="X86_TUNE_FOUR_JUMP_LIMIT">X86_TUNE_FOUR_JUMP_LIMIT</dfn>, <q>"four_jump_limit"</q>,</td></tr>
<tr><th id="210">210</th><td>          m_PPRO | m_P4_NOCONA | m_BONNELL | m_SILVERMONT | m_KNL |m_INTEL |</td></tr>
<tr><th id="211">211</th><td>	  m_ATHLON_K8 | m_AMDFAM10)</td></tr>
<tr><th id="212">212</th><td></td></tr>
<tr><th id="213">213</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="214">214</th><td><i>/* Integer instruction selection tuning                                      */</i></td></tr>
<tr><th id="215">215</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="216">216</th><td></td></tr>
<tr><th id="217">217</th><td><i>/* X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL: Enable software prefetching</i></td></tr>
<tr><th id="218">218</th><td><i>   at -O3.  For the moment, the prefetching seems badly tuned for Intel</i></td></tr>
<tr><th id="219">219</th><td><i>   chips.  */</i></td></tr>
<tr><th id="220">220</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL" title='X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL' data-ref="X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL" data-ref-filename="X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL">X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL</dfn>, <q>"software_prefetching_beneficial"</q>,</td></tr>
<tr><th id="221">221</th><td>          m_K6_GEODE | m_ATHLON_K8 | m_AMDFAM10 | m_BDVER | m_BTVER)</td></tr>
<tr><th id="222">222</th><td></td></tr>
<tr><th id="223">223</th><td><i>/* X86_TUNE_LCP_STALL: Avoid an expensive length-changing prefix stall</i></td></tr>
<tr><th id="224">224</th><td><i>   on 16-bit immediate moves into memory on Core2 and Corei7.  */</i></td></tr>
<tr><th id="225">225</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_LCP_STALL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_LCP_STALL" title='X86_TUNE_LCP_STALL' data-ref="X86_TUNE_LCP_STALL" data-ref-filename="X86_TUNE_LCP_STALL">X86_TUNE_LCP_STALL</dfn>, <q>"lcp_stall"</q>, m_CORE_ALL | m_GENERIC)</td></tr>
<tr><th id="226">226</th><td></td></tr>
<tr><th id="227">227</th><td><i>/* X86_TUNE_READ_MODIFY: Enable use of read-modify instructions such</i></td></tr>
<tr><th id="228">228</th><td><i>   as "add mem, reg".  */</i></td></tr>
<tr><th id="229">229</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_READ_MODIFY," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_READ_MODIFY" title='X86_TUNE_READ_MODIFY' data-ref="X86_TUNE_READ_MODIFY" data-ref-filename="X86_TUNE_READ_MODIFY">X86_TUNE_READ_MODIFY</dfn>, <q>"read_modify"</q>, ~(m_PENT | m_LAKEMONT | m_PPRO))</td></tr>
<tr><th id="230">230</th><td></td></tr>
<tr><th id="231">231</th><td><i>/* X86_TUNE_USE_INCDEC: Enable use of inc/dec instructions.   */</i></td></tr>
<tr><th id="232">232</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_INCDEC," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_INCDEC" title='X86_TUNE_USE_INCDEC' data-ref="X86_TUNE_USE_INCDEC" data-ref-filename="X86_TUNE_USE_INCDEC">X86_TUNE_USE_INCDEC</dfn>, <q>"use_incdec"</q>,</td></tr>
<tr><th id="233">233</th><td>          ~(m_P4_NOCONA | m_CORE_ALL | m_BONNELL | m_SILVERMONT | m_INTEL</td></tr>
<tr><th id="234">234</th><td>	   |  m_KNL | m_GENERIC))</td></tr>
<tr><th id="235">235</th><td></td></tr>
<tr><th id="236">236</th><td><i>/* X86_TUNE_INTEGER_DFMODE_MOVES: Enable if integer moves are preferred</i></td></tr>
<tr><th id="237">237</th><td><i>   for DFmode copies */</i></td></tr>
<tr><th id="238">238</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_INTEGER_DFMODE_MOVES," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_INTEGER_DFMODE_MOVES" title='X86_TUNE_INTEGER_DFMODE_MOVES' data-ref="X86_TUNE_INTEGER_DFMODE_MOVES" data-ref-filename="X86_TUNE_INTEGER_DFMODE_MOVES">X86_TUNE_INTEGER_DFMODE_MOVES</dfn>, <q>"integer_dfmode_moves"</q>,</td></tr>
<tr><th id="239">239</th><td>          ~(m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_BONNELL | m_SILVERMONT</td></tr>
<tr><th id="240">240</th><td>	    | m_KNL | m_INTEL | m_GEODE | m_AMD_MULTIPLE | m_GENERIC))</td></tr>
<tr><th id="241">241</th><td></td></tr>
<tr><th id="242">242</th><td><i>/* X86_TUNE_OPT_AGU: Optimize for Address Generation Unit. This flag</i></td></tr>
<tr><th id="243">243</th><td><i>   will impact LEA instruction selection. */</i></td></tr>
<tr><th id="244">244</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_OPT_AGU," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_OPT_AGU" title='X86_TUNE_OPT_AGU' data-ref="X86_TUNE_OPT_AGU" data-ref-filename="X86_TUNE_OPT_AGU">X86_TUNE_OPT_AGU</dfn>, <q>"opt_agu"</q>, m_BONNELL | m_SILVERMONT | m_KNL</td></tr>
<tr><th id="245">245</th><td>	  | m_INTEL)</td></tr>
<tr><th id="246">246</th><td></td></tr>
<tr><th id="247">247</th><td><i>/* X86_TUNE_AVOID_LEA_FOR_ADDR: Avoid lea for address computation.  */</i></td></tr>
<tr><th id="248">248</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_AVOID_LEA_FOR_ADDR," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_AVOID_LEA_FOR_ADDR" title='X86_TUNE_AVOID_LEA_FOR_ADDR' data-ref="X86_TUNE_AVOID_LEA_FOR_ADDR" data-ref-filename="X86_TUNE_AVOID_LEA_FOR_ADDR">X86_TUNE_AVOID_LEA_FOR_ADDR</dfn>, <q>"avoid_lea_for_addr"</q>,</td></tr>
<tr><th id="249">249</th><td>	  m_BONNELL | m_SILVERMONT | m_KNL)</td></tr>
<tr><th id="250">250</th><td></td></tr>
<tr><th id="251">251</th><td><i>/* X86_TUNE_SLOW_IMUL_IMM32_MEM: Imul of 32-bit constant and memory is</i></td></tr>
<tr><th id="252">252</th><td><i>   vector path on AMD machines.</i></td></tr>
<tr><th id="253">253</th><td><i>   FIXME: Do we need to enable this for core? */</i></td></tr>
<tr><th id="254">254</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SLOW_IMUL_IMM32_MEM," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SLOW_IMUL_IMM32_MEM" title='X86_TUNE_SLOW_IMUL_IMM32_MEM' data-ref="X86_TUNE_SLOW_IMUL_IMM32_MEM" data-ref-filename="X86_TUNE_SLOW_IMUL_IMM32_MEM">X86_TUNE_SLOW_IMUL_IMM32_MEM</dfn>, <q>"slow_imul_imm32_mem"</q>,</td></tr>
<tr><th id="255">255</th><td>          m_K8 | m_AMDFAM10)</td></tr>
<tr><th id="256">256</th><td></td></tr>
<tr><th id="257">257</th><td><i>/* X86_TUNE_SLOW_IMUL_IMM8: Imul of 8-bit constant is vector path on AMD</i></td></tr>
<tr><th id="258">258</th><td><i>   machines.</i></td></tr>
<tr><th id="259">259</th><td><i>   FIXME: Do we need to enable this for core? */</i></td></tr>
<tr><th id="260">260</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SLOW_IMUL_IMM8," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SLOW_IMUL_IMM8" title='X86_TUNE_SLOW_IMUL_IMM8' data-ref="X86_TUNE_SLOW_IMUL_IMM8" data-ref-filename="X86_TUNE_SLOW_IMUL_IMM8">X86_TUNE_SLOW_IMUL_IMM8</dfn>, <q>"slow_imul_imm8"</q>,</td></tr>
<tr><th id="261">261</th><td>          m_K8 | m_AMDFAM10)</td></tr>
<tr><th id="262">262</th><td></td></tr>
<tr><th id="263">263</th><td><i>/* X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE: Try to avoid memory operands for</i></td></tr>
<tr><th id="264">264</th><td><i>   a conditional move.  */</i></td></tr>
<tr><th id="265">265</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE" title='X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE' data-ref="X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE" data-ref-filename="X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE">X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE</dfn>, <q>"avoid_mem_opnd_for_cmove"</q>,</td></tr>
<tr><th id="266">266</th><td>	  m_BONNELL | m_SILVERMONT | m_KNL | m_INTEL)</td></tr>
<tr><th id="267">267</th><td></td></tr>
<tr><th id="268">268</th><td><i>/* X86_TUNE_SINGLE_STRINGOP: Enable use of single string operations, such</i></td></tr>
<tr><th id="269">269</th><td><i>   as MOVS and STOS (without a REP prefix) to move/set sequences of bytes.  */</i></td></tr>
<tr><th id="270">270</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SINGLE_STRINGOP," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SINGLE_STRINGOP" title='X86_TUNE_SINGLE_STRINGOP' data-ref="X86_TUNE_SINGLE_STRINGOP" data-ref-filename="X86_TUNE_SINGLE_STRINGOP">X86_TUNE_SINGLE_STRINGOP</dfn>, <q>"single_stringop"</q>, m_386 | m_P4_NOCONA)</td></tr>
<tr><th id="271">271</th><td></td></tr>
<tr><th id="272">272</th><td><i>/* X86_TUNE_MISALIGNED_MOVE_STRING_PRO_EPILOGUES: Enable generation of</i></td></tr>
<tr><th id="273">273</th><td><i>   compact prologues and epilogues by issuing a misaligned moves.  This</i></td></tr>
<tr><th id="274">274</th><td><i>   requires target to handle misaligned moves and partial memory stalls</i></td></tr>
<tr><th id="275">275</th><td><i>   reasonably well.</i></td></tr>
<tr><th id="276">276</th><td><i>   FIXME: This may actualy be a win on more targets than listed here.  */</i></td></tr>
<tr><th id="277">277</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_MISALIGNED_MOVE_STRING_PRO_EPILOGUES," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_MISALIGNED_MOVE_STRING_PRO_EPILOGUES" title='X86_TUNE_MISALIGNED_MOVE_STRING_PRO_EPILOGUES' data-ref="X86_TUNE_MISALIGNED_MOVE_STRING_PRO_EPILOGUES" data-ref-filename="X86_TUNE_MISALIGNED_MOVE_STRING_PRO_EPILOGUES">X86_TUNE_MISALIGNED_MOVE_STRING_PRO_EPILOGUES</dfn>,</td></tr>
<tr><th id="278">278</th><td>	  <q>"misaligned_move_string_pro_epilogues"</q>,</td></tr>
<tr><th id="279">279</th><td>	  m_386 | m_486 | m_CORE_ALL | m_AMD_MULTIPLE | m_GENERIC)</td></tr>
<tr><th id="280">280</th><td></td></tr>
<tr><th id="281">281</th><td><i>/* X86_TUNE_USE_SAHF: Controls use of SAHF.  */</i></td></tr>
<tr><th id="282">282</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_SAHF," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_SAHF" title='X86_TUNE_USE_SAHF' data-ref="X86_TUNE_USE_SAHF" data-ref-filename="X86_TUNE_USE_SAHF">X86_TUNE_USE_SAHF</dfn>, <q>"use_sahf"</q>,</td></tr>
<tr><th id="283">283</th><td>          m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_BONNELL | m_SILVERMONT</td></tr>
<tr><th id="284">284</th><td>	  | m_KNL | m_INTEL | m_K6_GEODE | m_K8 | m_AMDFAM10 | m_BDVER</td></tr>
<tr><th id="285">285</th><td>	  | m_BTVER | m_ZNVER1 | m_GENERIC)</td></tr>
<tr><th id="286">286</th><td></td></tr>
<tr><th id="287">287</th><td><i>/* X86_TUNE_USE_CLTD: Controls use of CLTD and CTQO instructions.  */</i></td></tr>
<tr><th id="288">288</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_CLTD," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_CLTD" title='X86_TUNE_USE_CLTD' data-ref="X86_TUNE_USE_CLTD" data-ref-filename="X86_TUNE_USE_CLTD">X86_TUNE_USE_CLTD</dfn>, <q>"use_cltd"</q>,</td></tr>
<tr><th id="289">289</th><td>	  ~(m_PENT | m_LAKEMONT | m_BONNELL | m_SILVERMONT | m_KNL | m_INTEL</td></tr>
<tr><th id="290">290</th><td>	    | m_K6))</td></tr>
<tr><th id="291">291</th><td></td></tr>
<tr><th id="292">292</th><td><i>/* X86_TUNE_USE_BT: Enable use of BT (bit test) instructions.  */</i></td></tr>
<tr><th id="293">293</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_BT," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_BT" title='X86_TUNE_USE_BT' data-ref="X86_TUNE_USE_BT" data-ref-filename="X86_TUNE_USE_BT">X86_TUNE_USE_BT</dfn>, <q>"use_bt"</q>,</td></tr>
<tr><th id="294">294</th><td>          m_CORE_ALL | m_BONNELL | m_SILVERMONT | m_KNL | m_INTEL</td></tr>
<tr><th id="295">295</th><td>	  | m_LAKEMONT | m_AMD_MULTIPLE | m_GENERIC)</td></tr>
<tr><th id="296">296</th><td></td></tr>
<tr><th id="297">297</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="298">298</th><td><i>/* 387 instruction selection tuning                                          */</i></td></tr>
<tr><th id="299">299</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="300">300</th><td></td></tr>
<tr><th id="301">301</th><td><i>/* X86_TUNE_USE_HIMODE_FIOP: Enables use of x87 instructions with 16bit</i></td></tr>
<tr><th id="302">302</th><td><i>   integer operand.</i></td></tr>
<tr><th id="303">303</th><td><i>   FIXME: Why this is disabled for modern chips?  */</i></td></tr>
<tr><th id="304">304</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_HIMODE_FIOP," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_HIMODE_FIOP" title='X86_TUNE_USE_HIMODE_FIOP' data-ref="X86_TUNE_USE_HIMODE_FIOP" data-ref-filename="X86_TUNE_USE_HIMODE_FIOP">X86_TUNE_USE_HIMODE_FIOP</dfn>, <q>"use_himode_fiop"</q>,</td></tr>
<tr><th id="305">305</th><td>          m_386 | m_486 | m_K6_GEODE)</td></tr>
<tr><th id="306">306</th><td></td></tr>
<tr><th id="307">307</th><td><i>/* X86_TUNE_USE_SIMODE_FIOP: Enables use of x87 instructions with 32bit</i></td></tr>
<tr><th id="308">308</th><td><i>   integer operand.  */</i></td></tr>
<tr><th id="309">309</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_SIMODE_FIOP," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_SIMODE_FIOP" title='X86_TUNE_USE_SIMODE_FIOP' data-ref="X86_TUNE_USE_SIMODE_FIOP" data-ref-filename="X86_TUNE_USE_SIMODE_FIOP">X86_TUNE_USE_SIMODE_FIOP</dfn>, <q>"use_simode_fiop"</q>,</td></tr>
<tr><th id="310">310</th><td>          ~(m_PENT | m_LAKEMONT | m_PPRO | m_CORE_ALL | m_BONNELL</td></tr>
<tr><th id="311">311</th><td>	    | m_SILVERMONT | m_KNL | m_INTEL | m_AMD_MULTIPLE | m_GENERIC))</td></tr>
<tr><th id="312">312</th><td></td></tr>
<tr><th id="313">313</th><td><i>/* X86_TUNE_USE_FFREEP: Use freep instruction instead of fstp.  */</i></td></tr>
<tr><th id="314">314</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_FFREEP," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_FFREEP" title='X86_TUNE_USE_FFREEP' data-ref="X86_TUNE_USE_FFREEP" data-ref-filename="X86_TUNE_USE_FFREEP">X86_TUNE_USE_FFREEP</dfn>, <q>"use_ffreep"</q>, m_AMD_MULTIPLE)</td></tr>
<tr><th id="315">315</th><td></td></tr>
<tr><th id="316">316</th><td><i>/* X86_TUNE_EXT_80387_CONSTANTS: Use fancy 80387 constants, such as PI.  */</i></td></tr>
<tr><th id="317">317</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_EXT_80387_CONSTANTS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_EXT_80387_CONSTANTS" title='X86_TUNE_EXT_80387_CONSTANTS' data-ref="X86_TUNE_EXT_80387_CONSTANTS" data-ref-filename="X86_TUNE_EXT_80387_CONSTANTS">X86_TUNE_EXT_80387_CONSTANTS</dfn>, <q>"ext_80387_constants"</q>,</td></tr>
<tr><th id="318">318</th><td>          m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_BONNELL | m_SILVERMONT</td></tr>
<tr><th id="319">319</th><td>	  | m_KNL | m_INTEL | m_K6_GEODE | m_ATHLON_K8 | m_GENERIC)</td></tr>
<tr><th id="320">320</th><td></td></tr>
<tr><th id="321">321</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="322">322</th><td><i>/* SSE instruction selection tuning                                          */</i></td></tr>
<tr><th id="323">323</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="324">324</th><td></td></tr>
<tr><th id="325">325</th><td><i>/* X86_TUNE_GENERAL_REGS_SSE_SPILL: Try to spill general regs to SSE</i></td></tr>
<tr><th id="326">326</th><td><i>   regs instead of memory.  */</i></td></tr>
<tr><th id="327">327</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_GENERAL_REGS_SSE_SPILL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_GENERAL_REGS_SSE_SPILL" title='X86_TUNE_GENERAL_REGS_SSE_SPILL' data-ref="X86_TUNE_GENERAL_REGS_SSE_SPILL" data-ref-filename="X86_TUNE_GENERAL_REGS_SSE_SPILL">X86_TUNE_GENERAL_REGS_SSE_SPILL</dfn>, <q>"general_regs_sse_spill"</q>,</td></tr>
<tr><th id="328">328</th><td>          m_CORE_ALL)</td></tr>
<tr><th id="329">329</th><td></td></tr>
<tr><th id="330">330</th><td><i>/* X86_TUNE_SSE_UNALIGNED_LOAD_OPTIMAL: Use movups for misaligned loads instead</i></td></tr>
<tr><th id="331">331</th><td><i>   of a sequence loading registers by parts.  */</i></td></tr>
<tr><th id="332">332</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SSE_UNALIGNED_LOAD_OPTIMAL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SSE_UNALIGNED_LOAD_OPTIMAL" title='X86_TUNE_SSE_UNALIGNED_LOAD_OPTIMAL' data-ref="X86_TUNE_SSE_UNALIGNED_LOAD_OPTIMAL" data-ref-filename="X86_TUNE_SSE_UNALIGNED_LOAD_OPTIMAL">X86_TUNE_SSE_UNALIGNED_LOAD_OPTIMAL</dfn>, <q>"sse_unaligned_load_optimal"</q>,</td></tr>
<tr><th id="333">333</th><td>	  m_NEHALEM | m_SANDYBRIDGE | m_HASWELL | m_SILVERMONT | m_KNL</td></tr>
<tr><th id="334">334</th><td>	  | m_INTEL | m_AMDFAM10 | m_BDVER | m_BTVER | m_ZNVER1 | m_GENERIC)</td></tr>
<tr><th id="335">335</th><td></td></tr>
<tr><th id="336">336</th><td><i>/* X86_TUNE_SSE_UNALIGNED_STORE_OPTIMAL: Use movups for misaligned stores instead</i></td></tr>
<tr><th id="337">337</th><td><i>   of a sequence loading registers by parts.  */</i></td></tr>
<tr><th id="338">338</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SSE_UNALIGNED_STORE_OPTIMAL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SSE_UNALIGNED_STORE_OPTIMAL" title='X86_TUNE_SSE_UNALIGNED_STORE_OPTIMAL' data-ref="X86_TUNE_SSE_UNALIGNED_STORE_OPTIMAL" data-ref-filename="X86_TUNE_SSE_UNALIGNED_STORE_OPTIMAL">X86_TUNE_SSE_UNALIGNED_STORE_OPTIMAL</dfn>, <q>"sse_unaligned_store_optimal"</q>,</td></tr>
<tr><th id="339">339</th><td>	  m_NEHALEM | m_SANDYBRIDGE | m_HASWELL | m_SILVERMONT | m_KNL</td></tr>
<tr><th id="340">340</th><td>	  | m_INTEL | m_BDVER | m_ZNVER1 | m_GENERIC)</td></tr>
<tr><th id="341">341</th><td></td></tr>
<tr><th id="342">342</th><td><i>/* Use packed single precision instructions where posisble.  I.e. movups instead</i></td></tr>
<tr><th id="343">343</th><td><i>   of movupd.  */</i></td></tr>
<tr><th id="344">344</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SSE_PACKED_SINGLE_INSN_OPTIMAL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SSE_PACKED_SINGLE_INSN_OPTIMAL" title='X86_TUNE_SSE_PACKED_SINGLE_INSN_OPTIMAL' data-ref="X86_TUNE_SSE_PACKED_SINGLE_INSN_OPTIMAL" data-ref-filename="X86_TUNE_SSE_PACKED_SINGLE_INSN_OPTIMAL">X86_TUNE_SSE_PACKED_SINGLE_INSN_OPTIMAL</dfn>, <q>"sse_packed_single_insn_optimal"</q>,</td></tr>
<tr><th id="345">345</th><td>	  m_BDVER | m_ZNVER1)</td></tr>
<tr><th id="346">346</th><td></td></tr>
<tr><th id="347">347</th><td><i>/* X86_TUNE_SSE_TYPELESS_STORES: Always movaps/movups for 128bit stores.   */</i></td></tr>
<tr><th id="348">348</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SSE_TYPELESS_STORES," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SSE_TYPELESS_STORES" title='X86_TUNE_SSE_TYPELESS_STORES' data-ref="X86_TUNE_SSE_TYPELESS_STORES" data-ref-filename="X86_TUNE_SSE_TYPELESS_STORES">X86_TUNE_SSE_TYPELESS_STORES</dfn>, <q>"sse_typeless_stores"</q>,</td></tr>
<tr><th id="349">349</th><td>	  m_AMD_MULTIPLE | m_CORE_ALL | m_GENERIC)</td></tr>
<tr><th id="350">350</th><td></td></tr>
<tr><th id="351">351</th><td><i>/* X86_TUNE_SSE_LOAD0_BY_PXOR: Always use pxor to load0 as opposed to</i></td></tr>
<tr><th id="352">352</th><td><i>   xorps/xorpd and other variants.  */</i></td></tr>
<tr><th id="353">353</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SSE_LOAD0_BY_PXOR," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SSE_LOAD0_BY_PXOR" title='X86_TUNE_SSE_LOAD0_BY_PXOR' data-ref="X86_TUNE_SSE_LOAD0_BY_PXOR" data-ref-filename="X86_TUNE_SSE_LOAD0_BY_PXOR">X86_TUNE_SSE_LOAD0_BY_PXOR</dfn>, <q>"sse_load0_by_pxor"</q>,</td></tr>
<tr><th id="354">354</th><td>	  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_BDVER | m_BTVER | m_ZNVER1</td></tr>
<tr><th id="355">355</th><td>	  | m_GENERIC)</td></tr>
<tr><th id="356">356</th><td></td></tr>
<tr><th id="357">357</th><td><i>/* X86_TUNE_INTER_UNIT_MOVES_TO_VEC: Enable moves in from integer</i></td></tr>
<tr><th id="358">358</th><td><i>   to SSE registers.  If disabled, the moves will be done by storing</i></td></tr>
<tr><th id="359">359</th><td><i>   the value to memory and reloading.  */</i></td></tr>
<tr><th id="360">360</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_INTER_UNIT_MOVES_TO_VEC," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_INTER_UNIT_MOVES_TO_VEC" title='X86_TUNE_INTER_UNIT_MOVES_TO_VEC' data-ref="X86_TUNE_INTER_UNIT_MOVES_TO_VEC" data-ref-filename="X86_TUNE_INTER_UNIT_MOVES_TO_VEC">X86_TUNE_INTER_UNIT_MOVES_TO_VEC</dfn>, <q>"inter_unit_moves_to_vec"</q>,</td></tr>
<tr><th id="361">361</th><td>          ~(m_AMD_MULTIPLE | m_GENERIC))</td></tr>
<tr><th id="362">362</th><td></td></tr>
<tr><th id="363">363</th><td><i>/* X86_TUNE_INTER_UNIT_MOVES_TO_VEC: Enable moves in from SSE</i></td></tr>
<tr><th id="364">364</th><td><i>   to integer registers.  If disabled, the moves will be done by storing</i></td></tr>
<tr><th id="365">365</th><td><i>   the value to memory and reloading.  */</i></td></tr>
<tr><th id="366">366</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_INTER_UNIT_MOVES_FROM_VEC," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_INTER_UNIT_MOVES_FROM_VEC" title='X86_TUNE_INTER_UNIT_MOVES_FROM_VEC' data-ref="X86_TUNE_INTER_UNIT_MOVES_FROM_VEC" data-ref-filename="X86_TUNE_INTER_UNIT_MOVES_FROM_VEC">X86_TUNE_INTER_UNIT_MOVES_FROM_VEC</dfn>, <q>"inter_unit_moves_from_vec"</q>,</td></tr>
<tr><th id="367">367</th><td>          ~m_ATHLON_K8)</td></tr>
<tr><th id="368">368</th><td></td></tr>
<tr><th id="369">369</th><td><i>/* X86_TUNE_INTER_UNIT_CONVERSIONS: Enable float&lt;-&gt;integer conversions</i></td></tr>
<tr><th id="370">370</th><td><i>   to use both SSE and integer registers at a same time.</i></td></tr>
<tr><th id="371">371</th><td><i>   FIXME: revisit importance of this for generic.  */</i></td></tr>
<tr><th id="372">372</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_INTER_UNIT_CONVERSIONS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_INTER_UNIT_CONVERSIONS" title='X86_TUNE_INTER_UNIT_CONVERSIONS' data-ref="X86_TUNE_INTER_UNIT_CONVERSIONS" data-ref-filename="X86_TUNE_INTER_UNIT_CONVERSIONS">X86_TUNE_INTER_UNIT_CONVERSIONS</dfn>, <q>"inter_unit_conversions"</q>,</td></tr>
<tr><th id="373">373</th><td>          ~(m_AMDFAM10 | m_BDVER))</td></tr>
<tr><th id="374">374</th><td></td></tr>
<tr><th id="375">375</th><td><i>/* X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS: Try to split memory operand for</i></td></tr>
<tr><th id="376">376</th><td><i>   fp converts to destination register.  */</i></td></tr>
<tr><th id="377">377</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS" title='X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS' data-ref="X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS" data-ref-filename="X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS">X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS</dfn>, <q>"split_mem_opnd_for_fp_converts"</q>,</td></tr>
<tr><th id="378">378</th><td>          m_SILVERMONT | m_KNL | m_INTEL)</td></tr>
<tr><th id="379">379</th><td></td></tr>
<tr><th id="380">380</th><td><i>/* X86_TUNE_USE_VECTOR_FP_CONVERTS: Prefer vector packed SSE conversion</i></td></tr>
<tr><th id="381">381</th><td><i>   from FP to FP.  This form of instructions avoids partial write to the</i></td></tr>
<tr><th id="382">382</th><td><i>   destination.  */</i></td></tr>
<tr><th id="383">383</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_VECTOR_FP_CONVERTS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_VECTOR_FP_CONVERTS" title='X86_TUNE_USE_VECTOR_FP_CONVERTS' data-ref="X86_TUNE_USE_VECTOR_FP_CONVERTS" data-ref-filename="X86_TUNE_USE_VECTOR_FP_CONVERTS">X86_TUNE_USE_VECTOR_FP_CONVERTS</dfn>, <q>"use_vector_fp_converts"</q>,</td></tr>
<tr><th id="384">384</th><td>          m_AMDFAM10)</td></tr>
<tr><th id="385">385</th><td></td></tr>
<tr><th id="386">386</th><td><i>/* X86_TUNE_USE_VECTOR_CONVERTS: Prefer vector packed SSE conversion</i></td></tr>
<tr><th id="387">387</th><td><i>   from integer to FP. */</i></td></tr>
<tr><th id="388">388</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_VECTOR_CONVERTS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_VECTOR_CONVERTS" title='X86_TUNE_USE_VECTOR_CONVERTS' data-ref="X86_TUNE_USE_VECTOR_CONVERTS" data-ref-filename="X86_TUNE_USE_VECTOR_CONVERTS">X86_TUNE_USE_VECTOR_CONVERTS</dfn>, <q>"use_vector_converts"</q>, m_AMDFAM10)</td></tr>
<tr><th id="389">389</th><td></td></tr>
<tr><th id="390">390</th><td><i>/* X86_TUNE_SLOW_SHUFB: Indicates tunings with slow pshufb instruction.  */</i></td></tr>
<tr><th id="391">391</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SLOW_PSHUFB," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SLOW_PSHUFB" title='X86_TUNE_SLOW_PSHUFB' data-ref="X86_TUNE_SLOW_PSHUFB" data-ref-filename="X86_TUNE_SLOW_PSHUFB">X86_TUNE_SLOW_PSHUFB</dfn>, <q>"slow_pshufb"</q>,</td></tr>
<tr><th id="392">392</th><td>          m_BONNELL | m_SILVERMONT | m_KNL | m_INTEL)</td></tr>
<tr><th id="393">393</th><td></td></tr>
<tr><th id="394">394</th><td><i>/* X86_TUNE_VECTOR_PARALLEL_EXECUTION: Indicates tunings with ability to</i></td></tr>
<tr><th id="395">395</th><td><i>   execute 2 or more vector instructions in parallel.  */</i></td></tr>
<tr><th id="396">396</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_VECTOR_PARALLEL_EXECUTION," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_VECTOR_PARALLEL_EXECUTION" title='X86_TUNE_VECTOR_PARALLEL_EXECUTION' data-ref="X86_TUNE_VECTOR_PARALLEL_EXECUTION" data-ref-filename="X86_TUNE_VECTOR_PARALLEL_EXECUTION">X86_TUNE_VECTOR_PARALLEL_EXECUTION</dfn>, <q>"vec_parallel"</q>,</td></tr>
<tr><th id="397">397</th><td>          m_NEHALEM | m_SANDYBRIDGE | m_HASWELL)</td></tr>
<tr><th id="398">398</th><td></td></tr>
<tr><th id="399">399</th><td><i>/* X86_TUNE_AVOID_4BYTE_PREFIXES: Avoid instructions requiring 4+ bytes of prefixes.  */</i></td></tr>
<tr><th id="400">400</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_AVOID_4BYTE_PREFIXES," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_AVOID_4BYTE_PREFIXES" title='X86_TUNE_AVOID_4BYTE_PREFIXES' data-ref="X86_TUNE_AVOID_4BYTE_PREFIXES" data-ref-filename="X86_TUNE_AVOID_4BYTE_PREFIXES">X86_TUNE_AVOID_4BYTE_PREFIXES</dfn>, <q>"avoid_4byte_prefixes"</q>,</td></tr>
<tr><th id="401">401</th><td>          m_SILVERMONT | m_INTEL)</td></tr>
<tr><th id="402">402</th><td></td></tr>
<tr><th id="403">403</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="404">404</th><td><i>/* AVX instruction selection tuning (some of SSE flags affects AVX, too)     */</i></td></tr>
<tr><th id="405">405</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="406">406</th><td></td></tr>
<tr><th id="407">407</th><td><i>/* X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL: if false, unaligned loads are</i></td></tr>
<tr><th id="408">408</th><td><i>   split.  */</i></td></tr>
<tr><th id="409">409</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL" title='X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL' data-ref="X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL" data-ref-filename="X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL">X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL</dfn>, <q>"256_unaligned_load_optimal"</q>,</td></tr>
<tr><th id="410">410</th><td>          ~(m_NEHALEM | m_SANDYBRIDGE | m_GENERIC))</td></tr>
<tr><th id="411">411</th><td></td></tr>
<tr><th id="412">412</th><td><i>/* X86_TUNE_AVX256_UNALIGNED_STORE_OPTIMAL: if false, unaligned stores are</i></td></tr>
<tr><th id="413">413</th><td><i>   split.  */</i></td></tr>
<tr><th id="414">414</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_AVX256_UNALIGNED_STORE_OPTIMAL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_AVX256_UNALIGNED_STORE_OPTIMAL" title='X86_TUNE_AVX256_UNALIGNED_STORE_OPTIMAL' data-ref="X86_TUNE_AVX256_UNALIGNED_STORE_OPTIMAL" data-ref-filename="X86_TUNE_AVX256_UNALIGNED_STORE_OPTIMAL">X86_TUNE_AVX256_UNALIGNED_STORE_OPTIMAL</dfn>, <q>"256_unaligned_store_optimal"</q>,</td></tr>
<tr><th id="415">415</th><td>	  ~(m_NEHALEM | m_SANDYBRIDGE | m_BDVER | m_ZNVER1 | m_GENERIC))</td></tr>
<tr><th id="416">416</th><td></td></tr>
<tr><th id="417">417</th><td><i>/* X86_TUNE_AVX128_OPTIMAL: Enable 128-bit AVX instruction generation for</i></td></tr>
<tr><th id="418">418</th><td><i>   the auto-vectorizer.  */</i></td></tr>
<tr><th id="419">419</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_AVX128_OPTIMAL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_AVX128_OPTIMAL" title='X86_TUNE_AVX128_OPTIMAL' data-ref="X86_TUNE_AVX128_OPTIMAL" data-ref-filename="X86_TUNE_AVX128_OPTIMAL">X86_TUNE_AVX128_OPTIMAL</dfn>, <q>"avx128_optimal"</q>, m_BDVER | m_BTVER2</td></tr>
<tr><th id="420">420</th><td>	  | m_ZNVER1)</td></tr>
<tr><th id="421">421</th><td></td></tr>
<tr><th id="422">422</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="423">423</th><td><i>/* Historical relics: tuning flags that helps a specific old CPU designs     */</i></td></tr>
<tr><th id="424">424</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="425">425</th><td></td></tr>
<tr><th id="426">426</th><td><i>/* X86_TUNE_DOUBLE_WITH_ADD: Use add instead of sal to double value in</i></td></tr>
<tr><th id="427">427</th><td><i>   an integer register.  */</i></td></tr>
<tr><th id="428">428</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_DOUBLE_WITH_ADD," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_DOUBLE_WITH_ADD" title='X86_TUNE_DOUBLE_WITH_ADD' data-ref="X86_TUNE_DOUBLE_WITH_ADD" data-ref-filename="X86_TUNE_DOUBLE_WITH_ADD">X86_TUNE_DOUBLE_WITH_ADD</dfn>, <q>"double_with_add"</q>, ~m_386)</td></tr>
<tr><th id="429">429</th><td></td></tr>
<tr><th id="430">430</th><td><i>/* X86_TUNE_ALWAYS_FANCY_MATH_387: controls use of fancy 387 operations,</i></td></tr>
<tr><th id="431">431</th><td><i>   such as fsqrt, fprem, fsin, fcos, fsincos etc.</i></td></tr>
<tr><th id="432">432</th><td><i>   Should be enabled for all targets that always has coprocesor.  */</i></td></tr>
<tr><th id="433">433</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_ALWAYS_FANCY_MATH_387," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_ALWAYS_FANCY_MATH_387" title='X86_TUNE_ALWAYS_FANCY_MATH_387' data-ref="X86_TUNE_ALWAYS_FANCY_MATH_387" data-ref-filename="X86_TUNE_ALWAYS_FANCY_MATH_387">X86_TUNE_ALWAYS_FANCY_MATH_387</dfn>, <q>"always_fancy_math_387"</q>,</td></tr>
<tr><th id="434">434</th><td>          ~(m_386 | m_486 | m_LAKEMONT))</td></tr>
<tr><th id="435">435</th><td></td></tr>
<tr><th id="436">436</th><td><i>/* X86_TUNE_UNROLL_STRLEN: Produce (quite lame) unrolled sequence for</i></td></tr>
<tr><th id="437">437</th><td><i>   inline strlen.  This affects only -minline-all-stringops mode. By</i></td></tr>
<tr><th id="438">438</th><td><i>   default we always dispatch to a library since our internal strlen</i></td></tr>
<tr><th id="439">439</th><td><i>   is bad.  */</i></td></tr>
<tr><th id="440">440</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_UNROLL_STRLEN," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_UNROLL_STRLEN" title='X86_TUNE_UNROLL_STRLEN' data-ref="X86_TUNE_UNROLL_STRLEN" data-ref-filename="X86_TUNE_UNROLL_STRLEN">X86_TUNE_UNROLL_STRLEN</dfn>, <q>"unroll_strlen"</q>, ~m_386)</td></tr>
<tr><th id="441">441</th><td></td></tr>
<tr><th id="442">442</th><td><i>/* X86_TUNE_SHIFT1: Enables use of short encoding of "sal reg" instead of</i></td></tr>
<tr><th id="443">443</th><td><i>   longer "sal $1, reg".  */</i></td></tr>
<tr><th id="444">444</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SHIFT1," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SHIFT1" title='X86_TUNE_SHIFT1' data-ref="X86_TUNE_SHIFT1" data-ref-filename="X86_TUNE_SHIFT1">X86_TUNE_SHIFT1</dfn>, <q>"shift1"</q>, ~m_486)</td></tr>
<tr><th id="445">445</th><td></td></tr>
<tr><th id="446">446</th><td><i>/* X86_TUNE_ZERO_EXTEND_WITH_AND: Use AND instruction instead</i></td></tr>
<tr><th id="447">447</th><td><i>   of mozbl/movwl.  */</i></td></tr>
<tr><th id="448">448</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_ZERO_EXTEND_WITH_AND," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_ZERO_EXTEND_WITH_AND" title='X86_TUNE_ZERO_EXTEND_WITH_AND' data-ref="X86_TUNE_ZERO_EXTEND_WITH_AND" data-ref-filename="X86_TUNE_ZERO_EXTEND_WITH_AND">X86_TUNE_ZERO_EXTEND_WITH_AND</dfn>, <q>"zero_extend_with_and"</q>,</td></tr>
<tr><th id="449">449</th><td>	  m_486 | m_PENT)</td></tr>
<tr><th id="450">450</th><td></td></tr>
<tr><th id="451">451</th><td><i>/* X86_TUNE_PROMOTE_HIMODE_IMUL: Modern CPUs have same latency for HImode</i></td></tr>
<tr><th id="452">452</th><td><i>   and SImode multiply, but 386 and 486 do HImode multiply faster.  */</i></td></tr>
<tr><th id="453">453</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PROMOTE_HIMODE_IMUL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PROMOTE_HIMODE_IMUL" title='X86_TUNE_PROMOTE_HIMODE_IMUL' data-ref="X86_TUNE_PROMOTE_HIMODE_IMUL" data-ref-filename="X86_TUNE_PROMOTE_HIMODE_IMUL">X86_TUNE_PROMOTE_HIMODE_IMUL</dfn>, <q>"promote_himode_imul"</q>,</td></tr>
<tr><th id="454">454</th><td>          ~(m_386 | m_486))</td></tr>
<tr><th id="455">455</th><td></td></tr>
<tr><th id="456">456</th><td><i>/* X86_TUNE_FAST_PREFIX: Enable demoting some 32bit or 64bit arithmetic</i></td></tr>
<tr><th id="457">457</th><td><i>   into 16bit/8bit when resulting sequence is shorter.  For example</i></td></tr>
<tr><th id="458">458</th><td><i>   for "and $-65536, reg" to 16bit store of 0.  */</i></td></tr>
<tr><th id="459">459</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_FAST_PREFIX," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_FAST_PREFIX" title='X86_TUNE_FAST_PREFIX' data-ref="X86_TUNE_FAST_PREFIX" data-ref-filename="X86_TUNE_FAST_PREFIX">X86_TUNE_FAST_PREFIX</dfn>, <q>"fast_prefix"</q>,</td></tr>
<tr><th id="460">460</th><td>	  ~(m_386 | m_486 | m_PENT | m_LAKEMONT))</td></tr>
<tr><th id="461">461</th><td></td></tr>
<tr><th id="462">462</th><td><i>/* X86_TUNE_READ_MODIFY_WRITE: Enable use of read modify write instructions</i></td></tr>
<tr><th id="463">463</th><td><i>   such as "add $1, mem".  */</i></td></tr>
<tr><th id="464">464</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_READ_MODIFY_WRITE," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_READ_MODIFY_WRITE" title='X86_TUNE_READ_MODIFY_WRITE' data-ref="X86_TUNE_READ_MODIFY_WRITE" data-ref-filename="X86_TUNE_READ_MODIFY_WRITE">X86_TUNE_READ_MODIFY_WRITE</dfn>, <q>"read_modify_write"</q>,</td></tr>
<tr><th id="465">465</th><td>	  ~(m_PENT | m_LAKEMONT))</td></tr>
<tr><th id="466">466</th><td></td></tr>
<tr><th id="467">467</th><td><i>/* X86_TUNE_MOVE_M1_VIA_OR: On pentiums, it is faster to load -1 via OR</i></td></tr>
<tr><th id="468">468</th><td><i>   than a MOV.  */</i></td></tr>
<tr><th id="469">469</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_MOVE_M1_VIA_OR," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_MOVE_M1_VIA_OR" title='X86_TUNE_MOVE_M1_VIA_OR' data-ref="X86_TUNE_MOVE_M1_VIA_OR" data-ref-filename="X86_TUNE_MOVE_M1_VIA_OR">X86_TUNE_MOVE_M1_VIA_OR</dfn>, <q>"move_m1_via_or"</q>, m_PENT | m_LAKEMONT)</td></tr>
<tr><th id="470">470</th><td></td></tr>
<tr><th id="471">471</th><td><i>/* X86_TUNE_NOT_UNPAIRABLE: NOT is not pairable on Pentium, while XOR is,</i></td></tr>
<tr><th id="472">472</th><td><i>   but one byte longer.  */</i></td></tr>
<tr><th id="473">473</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_NOT_UNPAIRABLE," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_NOT_UNPAIRABLE" title='X86_TUNE_NOT_UNPAIRABLE' data-ref="X86_TUNE_NOT_UNPAIRABLE" data-ref-filename="X86_TUNE_NOT_UNPAIRABLE">X86_TUNE_NOT_UNPAIRABLE</dfn>, <q>"not_unpairable"</q>, m_PENT | m_LAKEMONT)</td></tr>
<tr><th id="474">474</th><td></td></tr>
<tr><th id="475">475</th><td><i>/* X86_TUNE_PARTIAL_REG_STALL: Pentium pro, unlike later chips, handled</i></td></tr>
<tr><th id="476">476</th><td><i>   use of partial registers by renaming.  This improved performance of 16bit</i></td></tr>
<tr><th id="477">477</th><td><i>   code where upper halves of registers are not used.  It also leads to</i></td></tr>
<tr><th id="478">478</th><td><i>   an penalty whenever a 16bit store is followed by 32bit use.  This flag</i></td></tr>
<tr><th id="479">479</th><td><i>   disables production of such sequences in common cases.</i></td></tr>
<tr><th id="480">480</th><td><i>   See also X86_TUNE_HIMODE_MATH.</i></td></tr>
<tr><th id="481">481</th><td><i></i></td></tr>
<tr><th id="482">482</th><td><i>   In current implementation the partial register stalls are not eliminated</i></td></tr>
<tr><th id="483">483</th><td><i>   very well - they can be introduced via subregs synthesized by combine</i></td></tr>
<tr><th id="484">484</th><td><i>   and can happen in caller/callee saving sequences.  */</i></td></tr>
<tr><th id="485">485</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PARTIAL_REG_STALL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PARTIAL_REG_STALL" title='X86_TUNE_PARTIAL_REG_STALL' data-ref="X86_TUNE_PARTIAL_REG_STALL" data-ref-filename="X86_TUNE_PARTIAL_REG_STALL">X86_TUNE_PARTIAL_REG_STALL</dfn>, <q>"partial_reg_stall"</q>, m_PPRO)</td></tr>
<tr><th id="486">486</th><td></td></tr>
<tr><th id="487">487</th><td><i>/* X86_TUNE_PROMOTE_QIMODE: When it is cheap, turn 8bit arithmetic to</i></td></tr>
<tr><th id="488">488</th><td><i>   corresponding 32bit arithmetic.  */</i></td></tr>
<tr><th id="489">489</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PROMOTE_QIMODE," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PROMOTE_QIMODE" title='X86_TUNE_PROMOTE_QIMODE' data-ref="X86_TUNE_PROMOTE_QIMODE" data-ref-filename="X86_TUNE_PROMOTE_QIMODE">X86_TUNE_PROMOTE_QIMODE</dfn>, <q>"promote_qimode"</q>,</td></tr>
<tr><th id="490">490</th><td>	  ~m_PPRO)</td></tr>
<tr><th id="491">491</th><td></td></tr>
<tr><th id="492">492</th><td><i>/* X86_TUNE_PROMOTE_HI_REGS: Same, but for 16bit artihmetic.  Again we avoid</i></td></tr>
<tr><th id="493">493</th><td><i>   partial register stalls on PentiumPro targets. */</i></td></tr>
<tr><th id="494">494</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PROMOTE_HI_REGS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PROMOTE_HI_REGS" title='X86_TUNE_PROMOTE_HI_REGS' data-ref="X86_TUNE_PROMOTE_HI_REGS" data-ref-filename="X86_TUNE_PROMOTE_HI_REGS">X86_TUNE_PROMOTE_HI_REGS</dfn>, <q>"promote_hi_regs"</q>, m_PPRO)</td></tr>
<tr><th id="495">495</th><td></td></tr>
<tr><th id="496">496</th><td><i>/* X86_TUNE_HIMODE_MATH: Enable use of 16bit arithmetic.</i></td></tr>
<tr><th id="497">497</th><td><i>   On PPro this flag is meant to avoid partial register stalls.  */</i></td></tr>
<tr><th id="498">498</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_HIMODE_MATH," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_HIMODE_MATH" title='X86_TUNE_HIMODE_MATH' data-ref="X86_TUNE_HIMODE_MATH" data-ref-filename="X86_TUNE_HIMODE_MATH">X86_TUNE_HIMODE_MATH</dfn>, <q>"himode_math"</q>, ~m_PPRO)</td></tr>
<tr><th id="499">499</th><td></td></tr>
<tr><th id="500">500</th><td><i>/* X86_TUNE_SPLIT_LONG_MOVES: Avoid instructions moving immediates</i></td></tr>
<tr><th id="501">501</th><td><i>   directly to memory.  */</i></td></tr>
<tr><th id="502">502</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_SPLIT_LONG_MOVES," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_SPLIT_LONG_MOVES" title='X86_TUNE_SPLIT_LONG_MOVES' data-ref="X86_TUNE_SPLIT_LONG_MOVES" data-ref-filename="X86_TUNE_SPLIT_LONG_MOVES">X86_TUNE_SPLIT_LONG_MOVES</dfn>, <q>"split_long_moves"</q>, m_PPRO)</td></tr>
<tr><th id="503">503</th><td></td></tr>
<tr><th id="504">504</th><td><i>/* X86_TUNE_USE_XCHGB: Use xchgb %rh,%rl instead of rolw/rorw $8,rx.  */</i></td></tr>
<tr><th id="505">505</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_XCHGB," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_XCHGB" title='X86_TUNE_USE_XCHGB' data-ref="X86_TUNE_USE_XCHGB" data-ref-filename="X86_TUNE_USE_XCHGB">X86_TUNE_USE_XCHGB</dfn>, <q>"use_xchgb"</q>, m_PENT4)</td></tr>
<tr><th id="506">506</th><td></td></tr>
<tr><th id="507">507</th><td><i>/* X86_TUNE_USE_MOV0: Use "mov $0, reg" instead of "xor reg, reg" to clear</i></td></tr>
<tr><th id="508">508</th><td><i>   integer register.  */</i></td></tr>
<tr><th id="509">509</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_USE_MOV0," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_USE_MOV0" title='X86_TUNE_USE_MOV0' data-ref="X86_TUNE_USE_MOV0" data-ref-filename="X86_TUNE_USE_MOV0">X86_TUNE_USE_MOV0</dfn>, <q>"use_mov0"</q>, m_K6)</td></tr>
<tr><th id="510">510</th><td></td></tr>
<tr><th id="511">511</th><td><i>/* X86_TUNE_NOT_VECTORMODE: On AMD K6, NOT is vector decoded with memory</i></td></tr>
<tr><th id="512">512</th><td><i>   operand that cannot be represented using a modRM byte.  The XOR</i></td></tr>
<tr><th id="513">513</th><td><i>   replacement is long decoded, so this split helps here as well.  */</i></td></tr>
<tr><th id="514">514</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_NOT_VECTORMODE," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_NOT_VECTORMODE" title='X86_TUNE_NOT_VECTORMODE' data-ref="X86_TUNE_NOT_VECTORMODE" data-ref-filename="X86_TUNE_NOT_VECTORMODE">X86_TUNE_NOT_VECTORMODE</dfn>, <q>"not_vectormode"</q>, m_K6)</td></tr>
<tr><th id="515">515</th><td></td></tr>
<tr><th id="516">516</th><td><i>/* X86_TUNE_AVOID_VECTOR_DECODE: Enable splitters that avoid vector decoded</i></td></tr>
<tr><th id="517">517</th><td><i>   forms of instructions on K8 targets.  */</i></td></tr>
<tr><th id="518">518</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_AVOID_VECTOR_DECODE," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_AVOID_VECTOR_DECODE" title='X86_TUNE_AVOID_VECTOR_DECODE' data-ref="X86_TUNE_AVOID_VECTOR_DECODE" data-ref-filename="X86_TUNE_AVOID_VECTOR_DECODE">X86_TUNE_AVOID_VECTOR_DECODE</dfn>, <q>"avoid_vector_decode"</q>,</td></tr>
<tr><th id="519">519</th><td>          m_K8)</td></tr>
<tr><th id="520">520</th><td></td></tr>
<tr><th id="521">521</th><td><i>/* X86_TUNE_AVOID_FALSE_DEP_FOR_BMI: Avoid false dependency</i></td></tr>
<tr><th id="522">522</th><td><i>   for bit-manipulation instructions.  */</i></td></tr>
<tr><th id="523">523</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_AVOID_FALSE_DEP_FOR_BMI," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_AVOID_FALSE_DEP_FOR_BMI" title='X86_TUNE_AVOID_FALSE_DEP_FOR_BMI' data-ref="X86_TUNE_AVOID_FALSE_DEP_FOR_BMI" data-ref-filename="X86_TUNE_AVOID_FALSE_DEP_FOR_BMI">X86_TUNE_AVOID_FALSE_DEP_FOR_BMI</dfn>, <q>"avoid_false_dep_for_bmi"</q>,</td></tr>
<tr><th id="524">524</th><td>	  m_SANDYBRIDGE | m_HASWELL | m_GENERIC)</td></tr>
<tr><th id="525">525</th><td></td></tr>
<tr><th id="526">526</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="527">527</th><td><i>/* This never worked well before.                                            */</i></td></tr>
<tr><th id="528">528</th><td><i>/*****************************************************************************/</i></td></tr>
<tr><th id="529">529</th><td></td></tr>
<tr><th id="530">530</th><td><i>/* X86_TUNE_BRANCH_PREDICTION_HINTS: Branch hints were put in P4 based</i></td></tr>
<tr><th id="531">531</th><td><i>   on simulation result. But after P4 was made, no performance benefit</i></td></tr>
<tr><th id="532">532</th><td><i>   was observed with branch hints.  It also increases the code size.</i></td></tr>
<tr><th id="533">533</th><td><i>   As a result, icc never generates branch hints.  */</i></td></tr>
<tr><th id="534">534</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_BRANCH_PREDICTION_HINTS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_BRANCH_PREDICTION_HINTS" title='X86_TUNE_BRANCH_PREDICTION_HINTS' data-ref="X86_TUNE_BRANCH_PREDICTION_HINTS" data-ref-filename="X86_TUNE_BRANCH_PREDICTION_HINTS">X86_TUNE_BRANCH_PREDICTION_HINTS</dfn>, <q>"branch_prediction_hints"</q>, <var>0U</var>)</td></tr>
<tr><th id="535">535</th><td></td></tr>
<tr><th id="536">536</th><td><i>/* X86_TUNE_QIMODE_MATH: Enable use of 8bit arithmetic.  */</i></td></tr>
<tr><th id="537">537</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_QIMODE_MATH," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_QIMODE_MATH" title='X86_TUNE_QIMODE_MATH' data-ref="X86_TUNE_QIMODE_MATH" data-ref-filename="X86_TUNE_QIMODE_MATH">X86_TUNE_QIMODE_MATH</dfn>, <q>"qimode_math"</q>, ~<var>0U</var>)</td></tr>
<tr><th id="538">538</th><td></td></tr>
<tr><th id="539">539</th><td><i>/* X86_TUNE_PROMOTE_QI_REGS: This enables generic code that promotes all 8bit</i></td></tr>
<tr><th id="540">540</th><td><i>   arithmetic to 32bit via PROMOTE_MODE macro.  This code generation scheme</i></td></tr>
<tr><th id="541">541</th><td><i>   is usually used for RISC targets.  */</i></td></tr>
<tr><th id="542">542</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_PROMOTE_QI_REGS," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_PROMOTE_QI_REGS" title='X86_TUNE_PROMOTE_QI_REGS' data-ref="X86_TUNE_PROMOTE_QI_REGS" data-ref-filename="X86_TUNE_PROMOTE_QI_REGS">X86_TUNE_PROMOTE_QI_REGS</dfn>, <q>"promote_qi_regs"</q>, <var>0U</var>)</td></tr>
<tr><th id="543">543</th><td></td></tr>
<tr><th id="544">544</th><td><i>/* X86_TUNE_ADJUST_UNROLL: This enables adjusting the unroll factor based</i></td></tr>
<tr><th id="545">545</th><td><i>   on hardware capabilities. Bdver3 hardware has a loop buffer which makes</i></td></tr>
<tr><th id="546">546</th><td><i>   unrolling small loop less important. For, such architectures we adjust</i></td></tr>
<tr><th id="547">547</th><td><i>   the unroll factor so that the unrolled loop fits the loop buffer.  */</i></td></tr>
<tr><th id="548">548</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_ADJUST_UNROLL," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_ADJUST_UNROLL" title='X86_TUNE_ADJUST_UNROLL' data-ref="X86_TUNE_ADJUST_UNROLL" data-ref-filename="X86_TUNE_ADJUST_UNROLL">X86_TUNE_ADJUST_UNROLL</dfn>, <q>"adjust_unroll_factor"</q>, m_BDVER3 | m_BDVER4)</td></tr>
<tr><th id="549">549</th><td></td></tr>
<tr><th id="550">550</th><td><i>/* X86_TUNE_ONE_IF_CONV_INSNS: Restrict a number of cmov insns in</i></td></tr>
<tr><th id="551">551</th><td><i>   if-converted sequence to one.  */</i></td></tr>
<tr><th id="552">552</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_ONE_IF_CONV_INSN," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_ONE_IF_CONV_INSN" title='X86_TUNE_ONE_IF_CONV_INSN' data-ref="X86_TUNE_ONE_IF_CONV_INSN" data-ref-filename="X86_TUNE_ONE_IF_CONV_INSN">X86_TUNE_ONE_IF_CONV_INSN</dfn>, <q>"one_if_conv_insn"</q>,</td></tr>
<tr><th id="553">553</th><td>	  m_SILVERMONT | m_KNL | m_INTEL | m_CORE_ALL | m_GENERIC)</td></tr>
<tr><th id="554">554</th><td></td></tr>
<tr><th id="555">555</th><td><i>/* X86_TUNE_EMIT_VZEROUPPER: This enables vzeroupper instruction insertion</i></td></tr>
<tr><th id="556">556</th><td><i>   before a transfer of control flow out of the function.  */</i></td></tr>
<tr><th id="557">557</th><td><a class="macro" href="i386.h.html#374" title="X86_TUNE_EMIT_VZEROUPPER," data-ref="_M/DEF_TUNE">DEF_TUNE</a> (<dfn class="enum" id="X86_TUNE_EMIT_VZEROUPPER" title='X86_TUNE_EMIT_VZEROUPPER' data-ref="X86_TUNE_EMIT_VZEROUPPER" data-ref-filename="X86_TUNE_EMIT_VZEROUPPER">X86_TUNE_EMIT_VZEROUPPER</dfn>, <q>"emit_vzeroupper"</q>, ~m_KNL)</td></tr>
<tr><th id="558">558</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../../libgcc/emutls.c.html'>netbsd/external/gpl3/gcc/dist/libgcc/emutls.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
