<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>operators.def source code [netbsd/external/gpl3/gcc/dist/gcc/cp/operators.def] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/external/gpl3/gcc/dist/gcc/cp/operators.def'; var root_path = '../../../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../../..'>netbsd</a>/<a href='../../../../..'>external</a>/<a href='../../../..'>gpl3</a>/<a href='../../..'>gcc</a>/<a href='../..'>dist</a>/<a href='..'>gcc</a>/<a href='./'>cp</a>/<a href='operators.def.html'>operators.def</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* -*-C-*-</i></td></tr>
<tr><th id="2">2</th><td><i></i></td></tr>
<tr><th id="3">3</th><td><i>   This file contains definitions of the various C++ operators,</i></td></tr>
<tr><th id="4">4</th><td><i>   including both overloadable operators (like `+') and</i></td></tr>
<tr><th id="5">5</th><td><i>   non-overloadable operators (like the `?:' ternary operator).</i></td></tr>
<tr><th id="6">6</th><td><i>   Written by Mark Mitchell &lt;mark@codesourcery.com&gt;</i></td></tr>
<tr><th id="7">7</th><td><i></i></td></tr>
<tr><th id="8">8</th><td><i>   Copyright (C) 2000-2017 Free Software Foundation, Inc.</i></td></tr>
<tr><th id="9">9</th><td><i></i></td></tr>
<tr><th id="10">10</th><td><i>This file is part of GCC.</i></td></tr>
<tr><th id="11">11</th><td><i></i></td></tr>
<tr><th id="12">12</th><td><i>GCC is free software; you can redistribute it and/or modify</i></td></tr>
<tr><th id="13">13</th><td><i>it under the terms of the GNU General Public License as published by</i></td></tr>
<tr><th id="14">14</th><td><i>the Free Software Foundation; either version 3, or (at your option)</i></td></tr>
<tr><th id="15">15</th><td><i>any later version.</i></td></tr>
<tr><th id="16">16</th><td><i></i></td></tr>
<tr><th id="17">17</th><td><i>GCC is distributed in the hope that it will be useful,</i></td></tr>
<tr><th id="18">18</th><td><i>but WITHOUT ANY WARRANTY; without even the implied warranty of</i></td></tr>
<tr><th id="19">19</th><td><i>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</i></td></tr>
<tr><th id="20">20</th><td><i>GNU General Public License for more details.</i></td></tr>
<tr><th id="21">21</th><td><i></i></td></tr>
<tr><th id="22">22</th><td><i>You should have received a copy of the GNU General Public License</i></td></tr>
<tr><th id="23">23</th><td><i>along with GCC; see the file COPYING3.  If not see</i></td></tr>
<tr><th id="24">24</th><td><i>&lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.  */</i></td></tr>
<tr><th id="25">25</th><td></td></tr>
<tr><th id="26">26</th><td><i>/* The DEF_OPERATOR macro takes the following arguments:</i></td></tr>
<tr><th id="27">27</th><td><i></i></td></tr>
<tr><th id="28">28</th><td><i>   NAME</i></td></tr>
<tr><th id="29">29</th><td><i></i></td></tr>
<tr><th id="30">30</th><td><i>     The name of the operator, as a C string, but without the</i></td></tr>
<tr><th id="31">31</th><td><i>     preceding `operator'.  This is the name that would be given in</i></td></tr>
<tr><th id="32">32</th><td><i>     the source program.  For `operator +', for example, this would be</i></td></tr>
<tr><th id="33">33</th><td><i>     `+'.</i></td></tr>
<tr><th id="34">34</th><td><i></i></td></tr>
<tr><th id="35">35</th><td><i>   CODE</i></td></tr>
<tr><th id="36">36</th><td><i></i></td></tr>
<tr><th id="37">37</th><td><i>     The tree_code for this operator.  For `operator +', for example,</i></td></tr>
<tr><th id="38">38</th><td><i>     this would be PLUS_EXPR.  Because there are no tree codes for</i></td></tr>
<tr><th id="39">39</th><td><i>     assignment operators, the same tree-codes are reused; i.e.,</i></td></tr>
<tr><th id="40">40</th><td><i>     `operator +' will also have PLUS_EXPR as its CODE.</i></td></tr>
<tr><th id="41">41</th><td><i></i></td></tr>
<tr><th id="42">42</th><td><i>   MANGLING</i></td></tr>
<tr><th id="43">43</th><td><i></i></td></tr>
<tr><th id="44">44</th><td><i>     The mangling prefix for the operator, as a C string, and as</i></td></tr>
<tr><th id="45">45</th><td><i>     mangled under the new ABI.  For `operator +', for example, this</i></td></tr>
<tr><th id="46">46</th><td><i>     would be "pl".</i></td></tr>
<tr><th id="47">47</th><td><i></i></td></tr>
<tr><th id="48">48</th><td><i>   ARITY</i></td></tr>
<tr><th id="49">49</th><td><i></i></td></tr>
<tr><th id="50">50</th><td><i>     The arity of the operator, or -1 if any arity is allowed.  (As</i></td></tr>
<tr><th id="51">51</th><td><i>     for `operator ()'.)  Postincrement and postdecrement operators</i></td></tr>
<tr><th id="52">52</th><td><i>     are marked as binary.</i></td></tr>
<tr><th id="53">53</th><td><i></i></td></tr>
<tr><th id="54">54</th><td><i>   ASSN_P</i></td></tr>
<tr><th id="55">55</th><td><i></i></td></tr>
<tr><th id="56">56</th><td><i>     A boolean value.  If nonzero, this is an assignment operator.</i></td></tr>
<tr><th id="57">57</th><td><i></i></td></tr>
<tr><th id="58">58</th><td><i>   Before including this file, you should define DEF_OPERATOR</i></td></tr>
<tr><th id="59">59</th><td><i>   to take these arguments.</i></td></tr>
<tr><th id="60">60</th><td><i></i></td></tr>
<tr><th id="61">61</th><td><i>   There is code (such as in grok_op_properties) that depends on the</i></td></tr>
<tr><th id="62">62</th><td><i>   order the operators are presented in this file.  In particular,</i></td></tr>
<tr><th id="63">63</th><td><i>   unary operators must precede binary operators.  */</i></td></tr>
<tr><th id="64">64</th><td></td></tr>
<tr><th id="65">65</th><td><i>/* Use DEF_SIMPLE_OPERATOR to define a non-assignment operator.  Its</i></td></tr>
<tr><th id="66">66</th><td><i>   arguments are as for DEF_OPERATOR, but there is no need to provide</i></td></tr>
<tr><th id="67">67</th><td><i>   an ASSIGNMENT_P argument; it is always zero.  */</i></td></tr>
<tr><th id="68">68</th><td></td></tr>
<tr><th id="69">69</th><td><u>#define <dfn class="macro" id="_M/DEF_SIMPLE_OPERATOR" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</dfn>(NAME, CODE, MANGLING, ARITY) \</u></td></tr>
<tr><th id="70">70</th><td><u>  DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, 0)</u></td></tr>
<tr><th id="71">71</th><td></td></tr>
<tr><th id="72">72</th><td><i>/* Use DEF_ASSN_OPERATOR to define an assignment operator.  Its</i></td></tr>
<tr><th id="73">73</th><td><i>   arguments are as for DEF_OPERATOR, but there is no need to provide</i></td></tr>
<tr><th id="74">74</th><td><i>   an ASSIGNMENT_P argument; it is always one.  */</i></td></tr>
<tr><th id="75">75</th><td></td></tr>
<tr><th id="76">76</th><td><u>#define <dfn class="macro" id="_M/DEF_ASSN_OPERATOR" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</dfn>(NAME, CODE, MANGLING, ARITY) \</u></td></tr>
<tr><th id="77">77</th><td><u>  DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, 1)</u></td></tr>
<tr><th id="78">78</th><td></td></tr>
<tr><th id="79">79</th><td><i>/* Memory allocation operators.  */</i></td></tr>
<tr><th id="80">80</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (NEW_EXPR)].identifier) == name) { operator_code = (NEW_EXPR); break; } else if ((assignment_operator_name_info[(int) (NEW_EXPR)].identifier) == name) { operator_code = (NEW_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"new"</q>, <a class="enum" href="cp-tree.def.html#52" title='NEW_EXPR' data-ref="NEW_EXPR" data-ref-filename="NEW_EXPR">NEW_EXPR</a>, <q>"nw"</q>, -<var>1</var>)</td></tr>
<tr><th id="81">81</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (VEC_NEW_EXPR)].identifier) == name) { operator_code = (VEC_NEW_EXPR); break; } else if ((assignment_operator_name_info[(int) (VEC_NEW_EXPR)].identifier) == name) { operator_code = (VEC_NEW_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"new []"</q>, <a class="enum" href="cp-tree.def.html#53" title='VEC_NEW_EXPR' data-ref="VEC_NEW_EXPR" data-ref-filename="VEC_NEW_EXPR">VEC_NEW_EXPR</a>, <q>"na"</q>, -<var>1</var>)</td></tr>
<tr><th id="82">82</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (DELETE_EXPR)].identifier) == name) { operator_code = (DELETE_EXPR); break; } else if ((assignment_operator_name_info[(int) (DELETE_EXPR)].identifier) == name) { operator_code = (DELETE_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"delete"</q>, <a class="enum" href="cp-tree.def.html#58" title='DELETE_EXPR' data-ref="DELETE_EXPR" data-ref-filename="DELETE_EXPR">DELETE_EXPR</a>, <q>"dl"</q>, -<var>1</var>)</td></tr>
<tr><th id="83">83</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (VEC_DELETE_EXPR)].identifier) == name) { operator_code = (VEC_DELETE_EXPR); break; } else if ((assignment_operator_name_info[(int) (VEC_DELETE_EXPR)].identifier) == name) { operator_code = (VEC_DELETE_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"delete []"</q>, <a class="enum" href="cp-tree.def.html#59" title='VEC_DELETE_EXPR' data-ref="VEC_DELETE_EXPR" data-ref-filename="VEC_DELETE_EXPR">VEC_DELETE_EXPR</a>, <q>"da"</q>, -<var>1</var>)</td></tr>
<tr><th id="84">84</th><td></td></tr>
<tr><th id="85">85</th><td><i>/* Unary operators.  */</i></td></tr>
<tr><th id="86">86</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (UNARY_PLUS_EXPR)].identifier) == name) { operator_code = (UNARY_PLUS_EXPR); break; } else if ((assignment_operator_name_info[(int) (UNARY_PLUS_EXPR)].identifier) == name) { operator_code = (UNARY_PLUS_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"+"</q>, <a class="enum" href="cp-tree.def.html#361" title='UNARY_PLUS_EXPR' data-ref="UNARY_PLUS_EXPR" data-ref-filename="UNARY_PLUS_EXPR">UNARY_PLUS_EXPR</a>, <q>"ps"</q>, <var>1</var>)</td></tr>
<tr><th id="87">87</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (NEGATE_EXPR)].identifier) == name) { operator_code = (NEGATE_EXPR); break; } else if ((assignment_operator_name_info[(int) (NEGATE_EXPR)].identifier) == name) { operator_code = (NEGATE_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"-"</q>, <a class="enum" href="../tree.def.html#725" title='NEGATE_EXPR' data-ref="NEGATE_EXPR" data-ref-filename="NEGATE_EXPR">NEGATE_EXPR</a>, <q>"ng"</q>, <var>1</var>)</td></tr>
<tr><th id="88">88</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (ADDR_EXPR)].identifier) == name) { operator_code = (ADDR_EXPR); break; } else if ((assignment_operator_name_info[(int) (ADDR_EXPR)].identifier) == name) { operator_code = (ADDR_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"&amp;"</q>, <a class="enum" href="../tree.def.html#849" title='ADDR_EXPR' data-ref="ADDR_EXPR" data-ref-filename="ADDR_EXPR">ADDR_EXPR</a>, <q>"ad"</q>, <var>1</var>)</td></tr>
<tr><th id="89">89</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (INDIRECT_REF)].identifier) == name) { operator_code = (INDIRECT_REF); break; } else if ((assignment_operator_name_info[(int) (INDIRECT_REF)].identifier) == name) { operator_code = (INDIRECT_REF); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"*"</q>, <a class="enum" href="../tree.def.html#469" title='INDIRECT_REF' data-ref="INDIRECT_REF" data-ref-filename="INDIRECT_REF">INDIRECT_REF</a>, <q>"de"</q>, <var>1</var>)</td></tr>
<tr><th id="90">90</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (BIT_NOT_EXPR)].identifier) == name) { operator_code = (BIT_NOT_EXPR); break; } else if ((assignment_operator_name_info[(int) (BIT_NOT_EXPR)].identifier) == name) { operator_code = (BIT_NOT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"~"</q>, <a class="enum" href="../tree.def.html#761" title='BIT_NOT_EXPR' data-ref="BIT_NOT_EXPR" data-ref-filename="BIT_NOT_EXPR">BIT_NOT_EXPR</a>, <q>"co"</q>, <var>1</var>)</td></tr>
<tr><th id="91">91</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (TRUTH_NOT_EXPR)].identifier) == name) { operator_code = (TRUTH_NOT_EXPR); break; } else if ((assignment_operator_name_info[(int) (TRUTH_NOT_EXPR)].identifier) == name) { operator_code = (TRUTH_NOT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"!"</q>, <a class="enum" href="../tree.def.html#777" title='TRUTH_NOT_EXPR' data-ref="TRUTH_NOT_EXPR" data-ref-filename="TRUTH_NOT_EXPR">TRUTH_NOT_EXPR</a>, <q>"nt"</q>, <var>1</var>)</td></tr>
<tr><th id="92">92</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (PREINCREMENT_EXPR)].identifier) == name) { operator_code = (PREINCREMENT_EXPR); break; } else if ((assignment_operator_name_info[(int) (PREINCREMENT_EXPR)].identifier) == name) { operator_code = (PREINCREMENT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"++"</q>, <a class="enum" href="../tree.def.html#881" title='PREINCREMENT_EXPR' data-ref="PREINCREMENT_EXPR" data-ref-filename="PREINCREMENT_EXPR">PREINCREMENT_EXPR</a>, <q>"pp"</q>, <var>1</var>)</td></tr>
<tr><th id="93">93</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (PREDECREMENT_EXPR)].identifier) == name) { operator_code = (PREDECREMENT_EXPR); break; } else if ((assignment_operator_name_info[(int) (PREDECREMENT_EXPR)].identifier) == name) { operator_code = (PREDECREMENT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"--"</q>, <a class="enum" href="../tree.def.html#880" title='PREDECREMENT_EXPR' data-ref="PREDECREMENT_EXPR" data-ref-filename="PREDECREMENT_EXPR">PREDECREMENT_EXPR</a>, <q>"mm"</q>, <var>1</var>)</td></tr>
<tr><th id="94">94</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (SIZEOF_EXPR)].identifier) == name) { operator_code = (SIZEOF_EXPR); break; } else if ((assignment_operator_name_info[(int) (SIZEOF_EXPR)].identifier) == name) { operator_code = (SIZEOF_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"sizeof"</q>, <a class="enum" href="../c-family/c-common.def.html#56" title='SIZEOF_EXPR' data-ref="SIZEOF_EXPR" data-ref-filename="SIZEOF_EXPR">SIZEOF_EXPR</a>, <q>"sz"</q>, <var>1</var>)</td></tr>
<tr><th id="95">95</th><td><i>/* These are extensions.  */</i></td></tr>
<tr><th id="96">96</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (ALIGNOF_EXPR)].identifier) == name) { operator_code = (ALIGNOF_EXPR); break; } else if ((assignment_operator_name_info[(int) (ALIGNOF_EXPR)].identifier) == name) { operator_code = (ALIGNOF_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"alignof"</q>, <a class="enum" href="cp-tree.def.html#348" title='ALIGNOF_EXPR' data-ref="ALIGNOF_EXPR" data-ref-filename="ALIGNOF_EXPR">ALIGNOF_EXPR</a>, <q>"az"</q>, <var>1</var>)</td></tr>
<tr><th id="97">97</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (IMAGPART_EXPR)].identifier) == name) { operator_code = (IMAGPART_EXPR); break; } else if ((assignment_operator_name_info[(int) (IMAGPART_EXPR)].identifier) == name) { operator_code = (IMAGPART_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"__imag__"</q>, <a class="enum" href="../tree.def.html#454" title='IMAGPART_EXPR' data-ref="IMAGPART_EXPR" data-ref-filename="IMAGPART_EXPR">IMAGPART_EXPR</a>, <q>"v18__imag__"</q>, <var>1</var>)</td></tr>
<tr><th id="98">98</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (REALPART_EXPR)].identifier) == name) { operator_code = (REALPART_EXPR); break; } else if ((assignment_operator_name_info[(int) (REALPART_EXPR)].identifier) == name) { operator_code = (REALPART_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"__real__"</q>, <a class="enum" href="../tree.def.html#453" title='REALPART_EXPR' data-ref="REALPART_EXPR" data-ref-filename="REALPART_EXPR">REALPART_EXPR</a>, <q>"v18__real__"</q>, <var>1</var>)</td></tr>
<tr><th id="99">99</th><td></td></tr>
<tr><th id="100">100</th><td><i>/* The cast operator.  */</i></td></tr>
<tr><th id="101">101</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (TYPE_EXPR)].identifier) == name) { operator_code = (TYPE_EXPR); break; } else if ((assignment_operator_name_info[(int) (TYPE_EXPR)].identifier) == name) { operator_code = (TYPE_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>""</q>, <a class="enum" href="cp-tree.def.html#73" title='TYPE_EXPR' data-ref="TYPE_EXPR" data-ref-filename="TYPE_EXPR">TYPE_EXPR</a>, <q>"cv"</q>, <var>1</var>)</td></tr>
<tr><th id="102">102</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (CAST_EXPR)].identifier) == name) { operator_code = (CAST_EXPR); break; } else if ((assignment_operator_name_info[(int) (CAST_EXPR)].identifier) == name) { operator_code = (CAST_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>""</q>, <a class="enum" href="cp-tree.def.html#250" title='CAST_EXPR' data-ref="CAST_EXPR" data-ref-filename="CAST_EXPR">CAST_EXPR</a>, <q>"cv"</q>, <var>1</var>)</td></tr>
<tr><th id="103">103</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (DYNAMIC_CAST_EXPR)].identifier) == name) { operator_code = (DYNAMIC_CAST_EXPR); break; } else if ((assignment_operator_name_info[(int) (DYNAMIC_CAST_EXPR)].identifier) == name) { operator_code = (DYNAMIC_CAST_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"dynamic_cast"</q>, <a class="enum" href="cp-tree.def.html#254" title='DYNAMIC_CAST_EXPR' data-ref="DYNAMIC_CAST_EXPR" data-ref-filename="DYNAMIC_CAST_EXPR">DYNAMIC_CAST_EXPR</a>, <q>"dc"</q>, <var>1</var>)</td></tr>
<tr><th id="104">104</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (REINTERPRET_CAST_EXPR)].identifier) == name) { operator_code = (REINTERPRET_CAST_EXPR); break; } else if ((assignment_operator_name_info[(int) (REINTERPRET_CAST_EXPR)].identifier) == name) { operator_code = (REINTERPRET_CAST_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"reinterpret_cast"</q>, <a class="enum" href="cp-tree.def.html#251" title='REINTERPRET_CAST_EXPR' data-ref="REINTERPRET_CAST_EXPR" data-ref-filename="REINTERPRET_CAST_EXPR">REINTERPRET_CAST_EXPR</a>, <q>"rc"</q>, <var>1</var>)</td></tr>
<tr><th id="105">105</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (CONST_CAST_EXPR)].identifier) == name) { operator_code = (CONST_CAST_EXPR); break; } else if ((assignment_operator_name_info[(int) (CONST_CAST_EXPR)].identifier) == name) { operator_code = (CONST_CAST_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"const_cast"</q>, <a class="enum" href="cp-tree.def.html#252" title='CONST_CAST_EXPR' data-ref="CONST_CAST_EXPR" data-ref-filename="CONST_CAST_EXPR">CONST_CAST_EXPR</a>, <q>"cc"</q>, <var>1</var>)</td></tr>
<tr><th id="106">106</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (STATIC_CAST_EXPR)].identifier) == name) { operator_code = (STATIC_CAST_EXPR); break; } else if ((assignment_operator_name_info[(int) (STATIC_CAST_EXPR)].identifier) == name) { operator_code = (STATIC_CAST_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"static_cast"</q>, <a class="enum" href="cp-tree.def.html#253" title='STATIC_CAST_EXPR' data-ref="STATIC_CAST_EXPR" data-ref-filename="STATIC_CAST_EXPR">STATIC_CAST_EXPR</a>, <q>"sc"</q>, <var>1</var>)</td></tr>
<tr><th id="107">107</th><td></td></tr>
<tr><th id="108">108</th><td><i>/* Binary operators.  */</i></td></tr>
<tr><th id="109">109</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (PLUS_EXPR)].identifier) == name) { operator_code = (PLUS_EXPR); break; } else if ((assignment_operator_name_info[(int) (PLUS_EXPR)].identifier) == name) { operator_code = (PLUS_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"+"</q>, <a class="enum" href="../tree.def.html#673" title='PLUS_EXPR' data-ref="PLUS_EXPR" data-ref-filename="PLUS_EXPR">PLUS_EXPR</a>, <q>"pl"</q>, <var>2</var>)</td></tr>
<tr><th id="110">110</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (MINUS_EXPR)].identifier) == name) { operator_code = (MINUS_EXPR); break; } else if ((assignment_operator_name_info[(int) (MINUS_EXPR)].identifier) == name) { operator_code = (MINUS_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"-"</q>, <a class="enum" href="../tree.def.html#674" title='MINUS_EXPR' data-ref="MINUS_EXPR" data-ref-filename="MINUS_EXPR">MINUS_EXPR</a>, <q>"mi"</q>, <var>2</var>)</td></tr>
<tr><th id="111">111</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (MULT_EXPR)].identifier) == name) { operator_code = (MULT_EXPR); break; } else if ((assignment_operator_name_info[(int) (MULT_EXPR)].identifier) == name) { operator_code = (MULT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"*"</q>, <a class="enum" href="../tree.def.html#675" title='MULT_EXPR' data-ref="MULT_EXPR" data-ref-filename="MULT_EXPR">MULT_EXPR</a>, <q>"ml"</q>, <var>2</var>)</td></tr>
<tr><th id="112">112</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (TRUNC_DIV_EXPR)].identifier) == name) { operator_code = (TRUNC_DIV_EXPR); break; } else if ((assignment_operator_name_info[(int) (TRUNC_DIV_EXPR)].identifier) == name) { operator_code = (TRUNC_DIV_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"/"</q>, <a class="enum" href="../tree.def.html#686" title='TRUNC_DIV_EXPR' data-ref="TRUNC_DIV_EXPR" data-ref-filename="TRUNC_DIV_EXPR">TRUNC_DIV_EXPR</a>, <q>"dv"</q>, <var>2</var>)</td></tr>
<tr><th id="113">113</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (TRUNC_MOD_EXPR)].identifier) == name) { operator_code = (TRUNC_MOD_EXPR); break; } else if ((assignment_operator_name_info[(int) (TRUNC_MOD_EXPR)].identifier) == name) { operator_code = (TRUNC_MOD_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"%"</q>, <a class="enum" href="../tree.def.html#700" title='TRUNC_MOD_EXPR' data-ref="TRUNC_MOD_EXPR" data-ref-filename="TRUNC_MOD_EXPR">TRUNC_MOD_EXPR</a>, <q>"rm"</q>, <var>2</var>)</td></tr>
<tr><th id="114">114</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (BIT_AND_EXPR)].identifier) == name) { operator_code = (BIT_AND_EXPR); break; } else if ((assignment_operator_name_info[(int) (BIT_AND_EXPR)].identifier) == name) { operator_code = (BIT_AND_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"&amp;"</q>, <a class="enum" href="../tree.def.html#760" title='BIT_AND_EXPR' data-ref="BIT_AND_EXPR" data-ref-filename="BIT_AND_EXPR">BIT_AND_EXPR</a>, <q>"an"</q>, <var>2</var>)</td></tr>
<tr><th id="115">115</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (BIT_IOR_EXPR)].identifier) == name) { operator_code = (BIT_IOR_EXPR); break; } else if ((assignment_operator_name_info[(int) (BIT_IOR_EXPR)].identifier) == name) { operator_code = (BIT_IOR_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"|"</q>, <a class="enum" href="../tree.def.html#758" title='BIT_IOR_EXPR' data-ref="BIT_IOR_EXPR" data-ref-filename="BIT_IOR_EXPR">BIT_IOR_EXPR</a>, <q>"or"</q>, <var>2</var>)</td></tr>
<tr><th id="116">116</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (BIT_XOR_EXPR)].identifier) == name) { operator_code = (BIT_XOR_EXPR); break; } else if ((assignment_operator_name_info[(int) (BIT_XOR_EXPR)].identifier) == name) { operator_code = (BIT_XOR_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"^"</q>, <a class="enum" href="../tree.def.html#759" title='BIT_XOR_EXPR' data-ref="BIT_XOR_EXPR" data-ref-filename="BIT_XOR_EXPR">BIT_XOR_EXPR</a>, <q>"eo"</q>, <var>2</var>)</td></tr>
<tr><th id="117">117</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (LSHIFT_EXPR)].identifier) == name) { operator_code = (LSHIFT_EXPR); break; } else if ((assignment_operator_name_info[(int) (LSHIFT_EXPR)].identifier) == name) { operator_code = (LSHIFT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"&lt;&lt;"</q>, <a class="enum" href="../tree.def.html#752" title='LSHIFT_EXPR' data-ref="LSHIFT_EXPR" data-ref-filename="LSHIFT_EXPR">LSHIFT_EXPR</a>, <q>"ls"</q>, <var>2</var>)</td></tr>
<tr><th id="118">118</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (RSHIFT_EXPR)].identifier) == name) { operator_code = (RSHIFT_EXPR); break; } else if ((assignment_operator_name_info[(int) (RSHIFT_EXPR)].identifier) == name) { operator_code = (RSHIFT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"&gt;&gt;"</q>, <a class="enum" href="../tree.def.html#753" title='RSHIFT_EXPR' data-ref="RSHIFT_EXPR" data-ref-filename="RSHIFT_EXPR">RSHIFT_EXPR</a>, <q>"rs"</q>, <var>2</var>)</td></tr>
<tr><th id="119">119</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (EQ_EXPR)].identifier) == name) { operator_code = (EQ_EXPR); break; } else if ((assignment_operator_name_info[(int) (EQ_EXPR)].identifier) == name) { operator_code = (EQ_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"=="</q>, <a class="enum" href="../tree.def.html#792" title='EQ_EXPR' data-ref="EQ_EXPR" data-ref-filename="EQ_EXPR">EQ_EXPR</a>, <q>"eq"</q>, <var>2</var>)</td></tr>
<tr><th id="120">120</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (NE_EXPR)].identifier) == name) { operator_code = (NE_EXPR); break; } else if ((assignment_operator_name_info[(int) (NE_EXPR)].identifier) == name) { operator_code = (NE_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"!="</q>, <a class="enum" href="../tree.def.html#793" title='NE_EXPR' data-ref="NE_EXPR" data-ref-filename="NE_EXPR">NE_EXPR</a>, <q>"ne"</q>, <var>2</var>)</td></tr>
<tr><th id="121">121</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (LT_EXPR)].identifier) == name) { operator_code = (LT_EXPR); break; } else if ((assignment_operator_name_info[(int) (LT_EXPR)].identifier) == name) { operator_code = (LT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"&lt;"</q>, <a class="enum" href="../tree.def.html#788" title='LT_EXPR' data-ref="LT_EXPR" data-ref-filename="LT_EXPR">LT_EXPR</a>, <q>"lt"</q>, <var>2</var>)</td></tr>
<tr><th id="122">122</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (GT_EXPR)].identifier) == name) { operator_code = (GT_EXPR); break; } else if ((assignment_operator_name_info[(int) (GT_EXPR)].identifier) == name) { operator_code = (GT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"&gt;"</q>, <a class="enum" href="../tree.def.html#790" title='GT_EXPR' data-ref="GT_EXPR" data-ref-filename="GT_EXPR">GT_EXPR</a>, <q>"gt"</q>, <var>2</var>)</td></tr>
<tr><th id="123">123</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (LE_EXPR)].identifier) == name) { operator_code = (LE_EXPR); break; } else if ((assignment_operator_name_info[(int) (LE_EXPR)].identifier) == name) { operator_code = (LE_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"&lt;="</q>, <a class="enum" href="../tree.def.html#789" title='LE_EXPR' data-ref="LE_EXPR" data-ref-filename="LE_EXPR">LE_EXPR</a>, <q>"le"</q>, <var>2</var>)</td></tr>
<tr><th id="124">124</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (GE_EXPR)].identifier) == name) { operator_code = (GE_EXPR); break; } else if ((assignment_operator_name_info[(int) (GE_EXPR)].identifier) == name) { operator_code = (GE_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"&gt;="</q>, <a class="enum" href="../tree.def.html#791" title='GE_EXPR' data-ref="GE_EXPR" data-ref-filename="GE_EXPR">GE_EXPR</a>, <q>"ge"</q>, <var>2</var>)</td></tr>
<tr><th id="125">125</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (TRUTH_ANDIF_EXPR)].identifier) == name) { operator_code = (TRUTH_ANDIF_EXPR); break; } else if ((assignment_operator_name_info[(int) (TRUTH_ANDIF_EXPR)].identifier) == name) { operator_code = (TRUTH_ANDIF_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"&amp;&amp;"</q>, <a class="enum" href="../tree.def.html#772" title='TRUTH_ANDIF_EXPR' data-ref="TRUTH_ANDIF_EXPR" data-ref-filename="TRUTH_ANDIF_EXPR">TRUTH_ANDIF_EXPR</a>, <q>"aa"</q>, <var>2</var>)</td></tr>
<tr><th id="126">126</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (TRUTH_ORIF_EXPR)].identifier) == name) { operator_code = (TRUTH_ORIF_EXPR); break; } else if ((assignment_operator_name_info[(int) (TRUTH_ORIF_EXPR)].identifier) == name) { operator_code = (TRUTH_ORIF_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"||"</q>, <a class="enum" href="../tree.def.html#773" title='TRUTH_ORIF_EXPR' data-ref="TRUTH_ORIF_EXPR" data-ref-filename="TRUTH_ORIF_EXPR">TRUTH_ORIF_EXPR</a>, <q>"oo"</q>, <var>2</var>)</td></tr>
<tr><th id="127">127</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (COMPOUND_EXPR)].identifier) == name) { operator_code = (COMPOUND_EXPR); break; } else if ((assignment_operator_name_info[(int) (COMPOUND_EXPR)].identifier) == name) { operator_code = (COMPOUND_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>","</q>, <a class="enum" href="../tree.def.html#507" title='COMPOUND_EXPR' data-ref="COMPOUND_EXPR" data-ref-filename="COMPOUND_EXPR">COMPOUND_EXPR</a>, <q>"cm"</q>, <var>2</var>)</td></tr>
<tr><th id="128">128</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (MEMBER_REF)].identifier) == name) { operator_code = (MEMBER_REF); break; } else if ((assignment_operator_name_info[(int) (MEMBER_REF)].identifier) == name) { operator_code = (MEMBER_REF); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"-&gt;*"</q>, <a class="enum" href="cp-tree.def.html#69" title='MEMBER_REF' data-ref="MEMBER_REF" data-ref-filename="MEMBER_REF">MEMBER_REF</a>, <q>"pm"</q>, <var>2</var>)</td></tr>
<tr><th id="129">129</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (DOTSTAR_EXPR)].identifier) == name) { operator_code = (DOTSTAR_EXPR); break; } else if ((assignment_operator_name_info[(int) (DOTSTAR_EXPR)].identifier) == name) { operator_code = (DOTSTAR_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>".*"</q>, <a class="enum" href="cp-tree.def.html#256" title='DOTSTAR_EXPR' data-ref="DOTSTAR_EXPR" data-ref-filename="DOTSTAR_EXPR">DOTSTAR_EXPR</a>, <q>"ds"</q>, <var>2</var>)</td></tr>
<tr><th id="130">130</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (COMPONENT_REF)].identifier) == name) { operator_code = (COMPONENT_REF); break; } else if ((assignment_operator_name_info[(int) (COMPONENT_REF)].identifier) == name) { operator_code = (COMPONENT_REF); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"-&gt;"</q>, <a class="enum" href="../tree.def.html#427" title='COMPONENT_REF' data-ref="COMPONENT_REF" data-ref-filename="COMPONENT_REF">COMPONENT_REF</a>, <q>"pt"</q>, <var>2</var>)</td></tr>
<tr><th id="131">131</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (ARRAY_REF)].identifier) == name) { operator_code = (ARRAY_REF); break; } else if ((assignment_operator_name_info[(int) (ARRAY_REF)].identifier) == name) { operator_code = (ARRAY_REF); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"[]"</q>, <a class="enum" href="../tree.def.html#444" title='ARRAY_REF' data-ref="ARRAY_REF" data-ref-filename="ARRAY_REF">ARRAY_REF</a>, <q>"ix"</q>, <var>2</var>)</td></tr>
<tr><th id="132">132</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (POSTINCREMENT_EXPR)].identifier) == name) { operator_code = (POSTINCREMENT_EXPR); break; } else if ((assignment_operator_name_info[(int) (POSTINCREMENT_EXPR)].identifier) == name) { operator_code = (POSTINCREMENT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"++"</q>, <a class="enum" href="../tree.def.html#883" title='POSTINCREMENT_EXPR' data-ref="POSTINCREMENT_EXPR" data-ref-filename="POSTINCREMENT_EXPR">POSTINCREMENT_EXPR</a>, <q>"pp"</q>, <var>2</var>)</td></tr>
<tr><th id="133">133</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (POSTDECREMENT_EXPR)].identifier) == name) { operator_code = (POSTDECREMENT_EXPR); break; } else if ((assignment_operator_name_info[(int) (POSTDECREMENT_EXPR)].identifier) == name) { operator_code = (POSTDECREMENT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"--"</q>, <a class="enum" href="../tree.def.html#882" title='POSTDECREMENT_EXPR' data-ref="POSTDECREMENT_EXPR" data-ref-filename="POSTDECREMENT_EXPR">POSTDECREMENT_EXPR</a>, <q>"mm"</q>, <var>2</var>)</td></tr>
<tr><th id="134">134</th><td><i>/* This one is needed for mangling.  */</i></td></tr>
<tr><th id="135">135</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (SCOPE_REF)].identifier) == name) { operator_code = (SCOPE_REF); break; } else if ((assignment_operator_name_info[(int) (SCOPE_REF)].identifier) == name) { operator_code = (SCOPE_REF); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"::"</q>, <a class="enum" href="cp-tree.def.html#64" title='SCOPE_REF' data-ref="SCOPE_REF" data-ref-filename="SCOPE_REF">SCOPE_REF</a>, <q>"sr"</q>, <var>2</var>)</td></tr>
<tr><th id="136">136</th><td></td></tr>
<tr><th id="137">137</th><td><i>/* Assignment operators.  */</i></td></tr>
<tr><th id="138">138</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (NOP_EXPR)].identifier) == name) { operator_code = (NOP_EXPR); break; } else if ((assignment_operator_name_info[(int) (NOP_EXPR)].identifier) == name) { operator_code = (NOP_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"="</q>, <a class="enum" href="../tree.def.html#830" title='NOP_EXPR' data-ref="NOP_EXPR" data-ref-filename="NOP_EXPR">NOP_EXPR</a>, <q>"aS"</q>, <var>2</var>)</td></tr>
<tr><th id="139">139</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (PLUS_EXPR)].identifier) == name) { operator_code = (PLUS_EXPR); break; } else if ((assignment_operator_name_info[(int) (PLUS_EXPR)].identifier) == name) { operator_code = (PLUS_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"+="</q>, <a class="enum" href="../tree.def.html#673" title='PLUS_EXPR' data-ref="PLUS_EXPR" data-ref-filename="PLUS_EXPR">PLUS_EXPR</a>, <q>"pL"</q>, <var>2</var>)</td></tr>
<tr><th id="140">140</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (MINUS_EXPR)].identifier) == name) { operator_code = (MINUS_EXPR); break; } else if ((assignment_operator_name_info[(int) (MINUS_EXPR)].identifier) == name) { operator_code = (MINUS_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"-="</q>, <a class="enum" href="../tree.def.html#674" title='MINUS_EXPR' data-ref="MINUS_EXPR" data-ref-filename="MINUS_EXPR">MINUS_EXPR</a>, <q>"mI"</q>, <var>2</var>)</td></tr>
<tr><th id="141">141</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (MULT_EXPR)].identifier) == name) { operator_code = (MULT_EXPR); break; } else if ((assignment_operator_name_info[(int) (MULT_EXPR)].identifier) == name) { operator_code = (MULT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"*="</q>, <a class="enum" href="../tree.def.html#675" title='MULT_EXPR' data-ref="MULT_EXPR" data-ref-filename="MULT_EXPR">MULT_EXPR</a>, <q>"mL"</q>, <var>2</var>)</td></tr>
<tr><th id="142">142</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (TRUNC_DIV_EXPR)].identifier) == name) { operator_code = (TRUNC_DIV_EXPR); break; } else if ((assignment_operator_name_info[(int) (TRUNC_DIV_EXPR)].identifier) == name) { operator_code = (TRUNC_DIV_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"/="</q>, <a class="enum" href="../tree.def.html#686" title='TRUNC_DIV_EXPR' data-ref="TRUNC_DIV_EXPR" data-ref-filename="TRUNC_DIV_EXPR">TRUNC_DIV_EXPR</a>, <q>"dV"</q>, <var>2</var>)</td></tr>
<tr><th id="143">143</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (TRUNC_MOD_EXPR)].identifier) == name) { operator_code = (TRUNC_MOD_EXPR); break; } else if ((assignment_operator_name_info[(int) (TRUNC_MOD_EXPR)].identifier) == name) { operator_code = (TRUNC_MOD_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"%="</q>, <a class="enum" href="../tree.def.html#700" title='TRUNC_MOD_EXPR' data-ref="TRUNC_MOD_EXPR" data-ref-filename="TRUNC_MOD_EXPR">TRUNC_MOD_EXPR</a>, <q>"rM"</q>, <var>2</var>)</td></tr>
<tr><th id="144">144</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (BIT_AND_EXPR)].identifier) == name) { operator_code = (BIT_AND_EXPR); break; } else if ((assignment_operator_name_info[(int) (BIT_AND_EXPR)].identifier) == name) { operator_code = (BIT_AND_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"&amp;="</q>, <a class="enum" href="../tree.def.html#760" title='BIT_AND_EXPR' data-ref="BIT_AND_EXPR" data-ref-filename="BIT_AND_EXPR">BIT_AND_EXPR</a>, <q>"aN"</q>, <var>2</var>)</td></tr>
<tr><th id="145">145</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (BIT_IOR_EXPR)].identifier) == name) { operator_code = (BIT_IOR_EXPR); break; } else if ((assignment_operator_name_info[(int) (BIT_IOR_EXPR)].identifier) == name) { operator_code = (BIT_IOR_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"|="</q>, <a class="enum" href="../tree.def.html#758" title='BIT_IOR_EXPR' data-ref="BIT_IOR_EXPR" data-ref-filename="BIT_IOR_EXPR">BIT_IOR_EXPR</a>, <q>"oR"</q>, <var>2</var>)</td></tr>
<tr><th id="146">146</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (BIT_XOR_EXPR)].identifier) == name) { operator_code = (BIT_XOR_EXPR); break; } else if ((assignment_operator_name_info[(int) (BIT_XOR_EXPR)].identifier) == name) { operator_code = (BIT_XOR_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"^="</q>, <a class="enum" href="../tree.def.html#759" title='BIT_XOR_EXPR' data-ref="BIT_XOR_EXPR" data-ref-filename="BIT_XOR_EXPR">BIT_XOR_EXPR</a>, <q>"eO"</q>, <var>2</var>)</td></tr>
<tr><th id="147">147</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (LSHIFT_EXPR)].identifier) == name) { operator_code = (LSHIFT_EXPR); break; } else if ((assignment_operator_name_info[(int) (LSHIFT_EXPR)].identifier) == name) { operator_code = (LSHIFT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"&lt;&lt;="</q>, <a class="enum" href="../tree.def.html#752" title='LSHIFT_EXPR' data-ref="LSHIFT_EXPR" data-ref-filename="LSHIFT_EXPR">LSHIFT_EXPR</a>, <q>"lS"</q>, <var>2</var>)</td></tr>
<tr><th id="148">148</th><td><a class="macro" href="#76" title="if ((operator_name_info[(int) (RSHIFT_EXPR)].identifier) == name) { operator_code = (RSHIFT_EXPR); break; } else if ((assignment_operator_name_info[(int) (RSHIFT_EXPR)].identifier) == name) { operator_code = (RSHIFT_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_ASSN_OPERATOR">DEF_ASSN_OPERATOR</a> (<q>"&gt;&gt;="</q>, <a class="enum" href="../tree.def.html#753" title='RSHIFT_EXPR' data-ref="RSHIFT_EXPR" data-ref-filename="RSHIFT_EXPR">RSHIFT_EXPR</a>, <q>"rS"</q>, <var>2</var>)</td></tr>
<tr><th id="149">149</th><td></td></tr>
<tr><th id="150">150</th><td><i>/* Ternary operators.  */</i></td></tr>
<tr><th id="151">151</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (COND_EXPR)].identifier) == name) { operator_code = (COND_EXPR); break; } else if ((assignment_operator_name_info[(int) (COND_EXPR)].identifier) == name) { operator_code = (COND_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"?:"</q>, <a class="enum" href="../tree.def.html#537" title='COND_EXPR' data-ref="COND_EXPR" data-ref-filename="COND_EXPR">COND_EXPR</a>, <q>"qu"</q>, <var>3</var>)</td></tr>
<tr><th id="152">152</th><td></td></tr>
<tr><th id="153">153</th><td><i>/* Miscellaneous.  */</i></td></tr>
<tr><th id="154">154</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (CALL_EXPR)].identifier) == name) { operator_code = (CALL_EXPR); break; } else if ((assignment_operator_name_info[(int) (CALL_EXPR)].identifier) == name) { operator_code = (CALL_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"()"</q>, <a class="enum" href="../tree.def.html#594" title='CALL_EXPR' data-ref="CALL_EXPR" data-ref-filename="CALL_EXPR">CALL_EXPR</a>, <q>"cl"</q>, -<var>1</var>)</td></tr>
<tr><th id="155">155</th><td></td></tr>
<tr><th id="156">156</th><td><i>/* Variadic templates extension. */</i></td></tr>
<tr><th id="157">157</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (EXPR_PACK_EXPANSION)].identifier) == name) { operator_code = (EXPR_PACK_EXPANSION); break; } else if ((assignment_operator_name_info[(int) (EXPR_PACK_EXPANSION)].identifier) == name) { operator_code = (EXPR_PACK_EXPANSION); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"..."</q>, <a class="enum" href="cp-tree.def.html#427" title='EXPR_PACK_EXPANSION' data-ref="EXPR_PACK_EXPANSION" data-ref-filename="EXPR_PACK_EXPANSION">EXPR_PACK_EXPANSION</a>, <q>"sp"</q>, <var>1</var>)</td></tr>
<tr><th id="158">158</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (UNARY_LEFT_FOLD_EXPR)].identifier) == name) { operator_code = (UNARY_LEFT_FOLD_EXPR); break; } else if ((assignment_operator_name_info[(int) (UNARY_LEFT_FOLD_EXPR)].identifier) == name) { operator_code = (UNARY_LEFT_FOLD_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"... +"</q>, <a class="enum" href="cp-tree.def.html#455" title='UNARY_LEFT_FOLD_EXPR' data-ref="UNARY_LEFT_FOLD_EXPR" data-ref-filename="UNARY_LEFT_FOLD_EXPR">UNARY_LEFT_FOLD_EXPR</a>, <q>"fl"</q>, <var>2</var>)</td></tr>
<tr><th id="159">159</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (UNARY_RIGHT_FOLD_EXPR)].identifier) == name) { operator_code = (UNARY_RIGHT_FOLD_EXPR); break; } else if ((assignment_operator_name_info[(int) (UNARY_RIGHT_FOLD_EXPR)].identifier) == name) { operator_code = (UNARY_RIGHT_FOLD_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"+ ..."</q>, <a class="enum" href="cp-tree.def.html#456" title='UNARY_RIGHT_FOLD_EXPR' data-ref="UNARY_RIGHT_FOLD_EXPR" data-ref-filename="UNARY_RIGHT_FOLD_EXPR">UNARY_RIGHT_FOLD_EXPR</a>, <q>"fr"</q>, <var>2</var>)</td></tr>
<tr><th id="160">160</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (BINARY_LEFT_FOLD_EXPR)].identifier) == name) { operator_code = (BINARY_LEFT_FOLD_EXPR); break; } else if ((assignment_operator_name_info[(int) (BINARY_LEFT_FOLD_EXPR)].identifier) == name) { operator_code = (BINARY_LEFT_FOLD_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"+ ... +"</q>, <a class="enum" href="cp-tree.def.html#457" title='BINARY_LEFT_FOLD_EXPR' data-ref="BINARY_LEFT_FOLD_EXPR" data-ref-filename="BINARY_LEFT_FOLD_EXPR">BINARY_LEFT_FOLD_EXPR</a>, <q>"fL"</q>, <var>3</var>)</td></tr>
<tr><th id="161">161</th><td><a class="macro" href="#69" title="if ((operator_name_info[(int) (BINARY_RIGHT_FOLD_EXPR)].identifier) == name) { operator_code = (BINARY_RIGHT_FOLD_EXPR); break; } else if ((assignment_operator_name_info[(int) (BINARY_RIGHT_FOLD_EXPR)].identifier) == name) { operator_code = (BINARY_RIGHT_FOLD_EXPR); ((&amp;(((((enum tree_code) (decl)-&gt;base.code) == TEMPLATE_DECL ? ((struct tree_template_decl *)(const_cast&lt;union tree_node *&gt; ((((decl))))))-&gt;result : decl))-&gt;decl_common.lang_specific)-&gt;u.fn)-&gt;assignment_operator_p) = 1; break; }" data-ref="_M/DEF_SIMPLE_OPERATOR">DEF_SIMPLE_OPERATOR</a> (<q>"+ ... +"</q>, <a class="enum" href="cp-tree.def.html#458" title='BINARY_RIGHT_FOLD_EXPR' data-ref="BINARY_RIGHT_FOLD_EXPR" data-ref-filename="BINARY_RIGHT_FOLD_EXPR">BINARY_RIGHT_FOLD_EXPR</a>, <q>"fR"</q>, <var>3</var>)</td></tr>
<tr><th id="162">162</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='decl.c.html'>netbsd/external/gpl3/gcc/dist/gcc/cp/decl.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
