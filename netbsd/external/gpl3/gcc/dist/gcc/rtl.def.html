<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>rtl.def source code [netbsd/external/gpl3/gcc/dist/gcc/rtl.def] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/external/gpl3/gcc/dist/gcc/rtl.def'; var root_path = '../../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../..'>netbsd</a>/<a href='../../../..'>external</a>/<a href='../../..'>gpl3</a>/<a href='../..'>gcc</a>/<a href='..'>dist</a>/<a href='./'>gcc</a>/<a href='rtl.def.html'>rtl.def</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* This file contains the definitions and documentation for the</i></td></tr>
<tr><th id="2">2</th><td><i>   Register Transfer Expressions (rtx's) that make up the</i></td></tr>
<tr><th id="3">3</th><td><i>   Register Transfer Language (rtl) used in the Back End of the GNU compiler.</i></td></tr>
<tr><th id="4">4</th><td><i>   Copyright (C) 1987-2017 Free Software Foundation, Inc.</i></td></tr>
<tr><th id="5">5</th><td><i></i></td></tr>
<tr><th id="6">6</th><td><i>This file is part of GCC.</i></td></tr>
<tr><th id="7">7</th><td><i></i></td></tr>
<tr><th id="8">8</th><td><i>GCC is free software; you can redistribute it and/or modify it under</i></td></tr>
<tr><th id="9">9</th><td><i>the terms of the GNU General Public License as published by the Free</i></td></tr>
<tr><th id="10">10</th><td><i>Software Foundation; either version 3, or (at your option) any later</i></td></tr>
<tr><th id="11">11</th><td><i>version.</i></td></tr>
<tr><th id="12">12</th><td><i></i></td></tr>
<tr><th id="13">13</th><td><i>GCC is distributed in the hope that it will be useful, but WITHOUT ANY</i></td></tr>
<tr><th id="14">14</th><td><i>WARRANTY; without even the implied warranty of MERCHANTABILITY or</i></td></tr>
<tr><th id="15">15</th><td><i>FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</i></td></tr>
<tr><th id="16">16</th><td><i>for more details.</i></td></tr>
<tr><th id="17">17</th><td><i></i></td></tr>
<tr><th id="18">18</th><td><i>You should have received a copy of the GNU General Public License</i></td></tr>
<tr><th id="19">19</th><td><i>along with GCC; see the file COPYING3.  If not see</i></td></tr>
<tr><th id="20">20</th><td><i>&lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.  */</i></td></tr>
<tr><th id="21">21</th><td></td></tr>
<tr><th id="22">22</th><td></td></tr>
<tr><th id="23">23</th><td><i>/* Expression definitions and descriptions for all targets are in this file.</i></td></tr>
<tr><th id="24">24</th><td><i>   Some will not be used for some targets.</i></td></tr>
<tr><th id="25">25</th><td><i></i></td></tr>
<tr><th id="26">26</th><td><i>   The fields in the cpp macro call "DEF_RTL_EXPR()"</i></td></tr>
<tr><th id="27">27</th><td><i>   are used to create declarations in the C source of the compiler.</i></td></tr>
<tr><th id="28">28</th><td><i></i></td></tr>
<tr><th id="29">29</th><td><i>   The fields are:</i></td></tr>
<tr><th id="30">30</th><td><i></i></td></tr>
<tr><th id="31">31</th><td><i>   1.  The internal name of the rtx used in the C source.</i></td></tr>
<tr><th id="32">32</th><td><i>   It is a tag in the enumeration "enum rtx_code" defined in "rtl.h".</i></td></tr>
<tr><th id="33">33</th><td><i>   By convention these are in UPPER_CASE.</i></td></tr>
<tr><th id="34">34</th><td><i></i></td></tr>
<tr><th id="35">35</th><td><i>   2.  The name of the rtx in the external ASCII format read by</i></td></tr>
<tr><th id="36">36</th><td><i>   read_rtx(), and printed by print_rtx().</i></td></tr>
<tr><th id="37">37</th><td><i>   These names are stored in rtx_name[].</i></td></tr>
<tr><th id="38">38</th><td><i>   By convention these are the internal (field 1) names in lower_case.</i></td></tr>
<tr><th id="39">39</th><td><i></i></td></tr>
<tr><th id="40">40</th><td><i>   3.  The print format, and type of each rtx-&gt;u.fld[] (field) in this rtx.</i></td></tr>
<tr><th id="41">41</th><td><i>   These formats are stored in rtx_format[].</i></td></tr>
<tr><th id="42">42</th><td><i>   The meaning of the formats is documented in front of this array in rtl.c</i></td></tr>
<tr><th id="43">43</th><td><i></i></td></tr>
<tr><th id="44">44</th><td><i>   4.  The class of the rtx.  These are stored in rtx_class and are accessed</i></td></tr>
<tr><th id="45">45</th><td><i>   via the GET_RTX_CLASS macro.  They are defined as follows:</i></td></tr>
<tr><th id="46">46</th><td><i></i></td></tr>
<tr><th id="47">47</th><td><i>     RTX_CONST_OBJ</i></td></tr>
<tr><th id="48">48</th><td><i>         an rtx code that can be used to represent a constant object</i></td></tr>
<tr><th id="49">49</th><td><i>         (e.g, CONST_INT)</i></td></tr>
<tr><th id="50">50</th><td><i>     RTX_OBJ</i></td></tr>
<tr><th id="51">51</th><td><i>         an rtx code that can be used to represent an object (e.g, REG, MEM)</i></td></tr>
<tr><th id="52">52</th><td><i>     RTX_COMPARE</i></td></tr>
<tr><th id="53">53</th><td><i>         an rtx code for a comparison (e.g, LT, GT)</i></td></tr>
<tr><th id="54">54</th><td><i>     RTX_COMM_COMPARE</i></td></tr>
<tr><th id="55">55</th><td><i>         an rtx code for a commutative comparison (e.g, EQ, NE, ORDERED)</i></td></tr>
<tr><th id="56">56</th><td><i>     RTX_UNARY</i></td></tr>
<tr><th id="57">57</th><td><i>         an rtx code for a unary arithmetic expression (e.g, NEG, NOT)</i></td></tr>
<tr><th id="58">58</th><td><i>     RTX_COMM_ARITH</i></td></tr>
<tr><th id="59">59</th><td><i>         an rtx code for a commutative binary operation (e.g,, PLUS, MULT)</i></td></tr>
<tr><th id="60">60</th><td><i>     RTX_TERNARY</i></td></tr>
<tr><th id="61">61</th><td><i>         an rtx code for a non-bitfield three input operation (IF_THEN_ELSE)</i></td></tr>
<tr><th id="62">62</th><td><i>     RTX_BIN_ARITH</i></td></tr>
<tr><th id="63">63</th><td><i>         an rtx code for a non-commutative binary operation (e.g., MINUS, DIV)</i></td></tr>
<tr><th id="64">64</th><td><i>     RTX_BITFIELD_OPS</i></td></tr>
<tr><th id="65">65</th><td><i>         an rtx code for a bit-field operation (ZERO_EXTRACT, SIGN_EXTRACT)</i></td></tr>
<tr><th id="66">66</th><td><i>     RTX_INSN</i></td></tr>
<tr><th id="67">67</th><td><i>         an rtx code for a machine insn (INSN, JUMP_INSN, CALL_INSN) or</i></td></tr>
<tr><th id="68">68</th><td><i>	 data that will be output as assembly pseudo-ops (DEBUG_INSN)</i></td></tr>
<tr><th id="69">69</th><td><i>     RTX_MATCH</i></td></tr>
<tr><th id="70">70</th><td><i>         an rtx code for something that matches in insns (e.g, MATCH_DUP)</i></td></tr>
<tr><th id="71">71</th><td><i>     RTX_AUTOINC</i></td></tr>
<tr><th id="72">72</th><td><i>         an rtx code for autoincrement addressing modes (e.g. POST_DEC)</i></td></tr>
<tr><th id="73">73</th><td><i>     RTX_EXTRA</i></td></tr>
<tr><th id="74">74</th><td><i>         everything else</i></td></tr>
<tr><th id="75">75</th><td><i></i></td></tr>
<tr><th id="76">76</th><td><i>   All of the expressions that appear only in machine descriptions,</i></td></tr>
<tr><th id="77">77</th><td><i>   not in RTL used by the compiler itself, are at the end of the file.  */</i></td></tr>
<tr><th id="78">78</th><td></td></tr>
<tr><th id="79">79</th><td><i>/* Unknown, or no such operation; the enumeration constant should have</i></td></tr>
<tr><th id="80">80</th><td><i>   value zero.  */</i></td></tr>
<tr><th id="81">81</th><td><a class="macro" href="rtl.h.html#52" title="UNKNOWN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNKNOWN" title='UNKNOWN' data-ref="UNKNOWN" data-ref-filename="UNKNOWN">UNKNOWN</dfn>, <q>"UnKnown"</q>, <q>"*"</q>, RTX_EXTRA)</td></tr>
<tr><th id="82">82</th><td></td></tr>
<tr><th id="83">83</th><td><i>/* Used in the cselib routines to describe a value.  Objects of this</i></td></tr>
<tr><th id="84">84</th><td><i>   kind are only allocated in cselib.c, in an alloc pool instead of in</i></td></tr>
<tr><th id="85">85</th><td><i>   GC memory.  The only operand of a VALUE is a cselib_val.</i></td></tr>
<tr><th id="86">86</th><td><i>   var-tracking requires this to have a distinct integral value from</i></td></tr>
<tr><th id="87">87</th><td><i>   DECL codes in trees.  */</i></td></tr>
<tr><th id="88">88</th><td><a class="macro" href="rtl.h.html#52" title="VALUE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="VALUE" title='VALUE' data-ref="VALUE" data-ref-filename="VALUE">VALUE</dfn>, <q>"value"</q>, <q>"0"</q>, RTX_OBJ)</td></tr>
<tr><th id="89">89</th><td></td></tr>
<tr><th id="90">90</th><td><i>/* The RTL generated for a DEBUG_EXPR_DECL.  It links back to the</i></td></tr>
<tr><th id="91">91</th><td><i>   DEBUG_EXPR_DECL in the first operand.  */</i></td></tr>
<tr><th id="92">92</th><td><a class="macro" href="rtl.h.html#52" title="DEBUG_EXPR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEBUG_EXPR" title='DEBUG_EXPR' data-ref="DEBUG_EXPR" data-ref-filename="DEBUG_EXPR">DEBUG_EXPR</dfn>, <q>"debug_expr"</q>, <q>"0"</q>, RTX_OBJ)</td></tr>
<tr><th id="93">93</th><td></td></tr>
<tr><th id="94">94</th><td><i>/* ---------------------------------------------------------------------</i></td></tr>
<tr><th id="95">95</th><td><i>   Expressions used in constructing lists.</i></td></tr>
<tr><th id="96">96</th><td><i>   --------------------------------------------------------------------- */</i></td></tr>
<tr><th id="97">97</th><td></td></tr>
<tr><th id="98">98</th><td><i>/* A linked list of expressions.  */</i></td></tr>
<tr><th id="99">99</th><td><a class="macro" href="rtl.h.html#52" title="EXPR_LIST ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="EXPR_LIST" title='EXPR_LIST' data-ref="EXPR_LIST" data-ref-filename="EXPR_LIST">EXPR_LIST</dfn>, <q>"expr_list"</q>, <q>"ee"</q>, RTX_EXTRA)</td></tr>
<tr><th id="100">100</th><td></td></tr>
<tr><th id="101">101</th><td><i>/* A linked list of instructions.</i></td></tr>
<tr><th id="102">102</th><td><i>   The insns are represented in print by their uids.  */</i></td></tr>
<tr><th id="103">103</th><td><a class="macro" href="rtl.h.html#52" title="INSN_LIST ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="INSN_LIST" title='INSN_LIST' data-ref="INSN_LIST" data-ref-filename="INSN_LIST">INSN_LIST</dfn>, <q>"insn_list"</q>, <q>"ue"</q>, RTX_EXTRA)</td></tr>
<tr><th id="104">104</th><td></td></tr>
<tr><th id="105">105</th><td><i>/* A linked list of integers.  */</i></td></tr>
<tr><th id="106">106</th><td><a class="macro" href="rtl.h.html#52" title="INT_LIST ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="INT_LIST" title='INT_LIST' data-ref="INT_LIST" data-ref-filename="INT_LIST">INT_LIST</dfn>, <q>"int_list"</q>, <q>"ie"</q>, RTX_EXTRA)</td></tr>
<tr><th id="107">107</th><td></td></tr>
<tr><th id="108">108</th><td><i>/* SEQUENCE is used in late passes of the compiler to group insns for</i></td></tr>
<tr><th id="109">109</th><td><i>   one reason or another.</i></td></tr>
<tr><th id="110">110</th><td><i></i></td></tr>
<tr><th id="111">111</th><td><i>   For example, after delay slot filling, branch instructions with filled</i></td></tr>
<tr><th id="112">112</th><td><i>   delay slots are represented as a SEQUENCE of length 1 + n_delay_slots,</i></td></tr>
<tr><th id="113">113</th><td><i>   with the branch instruction in XEXPVEC(seq, 0, 0) and the instructions</i></td></tr>
<tr><th id="114">114</th><td><i>   occupying the delay slots in the remaining XEXPVEC slots.</i></td></tr>
<tr><th id="115">115</th><td><i></i></td></tr>
<tr><th id="116">116</th><td><i>   Another place where a SEQUENCE may appear, is in REG_FRAME_RELATED_EXPR</i></td></tr>
<tr><th id="117">117</th><td><i>   notes, to express complex operations that are not obvious from the insn</i></td></tr>
<tr><th id="118">118</th><td><i>   to which the REG_FRAME_RELATED_EXPR note is attached.  In this usage of</i></td></tr>
<tr><th id="119">119</th><td><i>   SEQUENCE, the sequence vector slots do not hold real instructions but</i></td></tr>
<tr><th id="120">120</th><td><i>   only pseudo-instructions that can be translated to DWARF CFA expressions.</i></td></tr>
<tr><th id="121">121</th><td><i></i></td></tr>
<tr><th id="122">122</th><td><i>   Some back ends also use SEQUENCE to group insns in bundles.</i></td></tr>
<tr><th id="123">123</th><td><i></i></td></tr>
<tr><th id="124">124</th><td><i>   Much of the compiler infrastructure is not prepared to handle SEQUENCE</i></td></tr>
<tr><th id="125">125</th><td><i>   objects.  Only passes after pass_free_cfg are expected to handle them.  */</i></td></tr>
<tr><th id="126">126</th><td><a class="macro" href="rtl.h.html#52" title="SEQUENCE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SEQUENCE" title='SEQUENCE' data-ref="SEQUENCE" data-ref-filename="SEQUENCE">SEQUENCE</dfn>, <q>"sequence"</q>, <q>"E"</q>, RTX_EXTRA)</td></tr>
<tr><th id="127">127</th><td></td></tr>
<tr><th id="128">128</th><td><i>/* Represents a non-global base address.  This is only used in alias.c.  */</i></td></tr>
<tr><th id="129">129</th><td><a class="macro" href="rtl.h.html#52" title="ADDRESS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ADDRESS" title='ADDRESS' data-ref="ADDRESS" data-ref-filename="ADDRESS">ADDRESS</dfn>, <q>"address"</q>, <q>"i"</q>, RTX_EXTRA)</td></tr>
<tr><th id="130">130</th><td></td></tr>
<tr><th id="131">131</th><td><i>/* ----------------------------------------------------------------------</i></td></tr>
<tr><th id="132">132</th><td><i>   Expression types used for things in the instruction chain.</i></td></tr>
<tr><th id="133">133</th><td><i></i></td></tr>
<tr><th id="134">134</th><td><i>   All formats must start with "uu" to handle the chain.</i></td></tr>
<tr><th id="135">135</th><td><i>   Each insn expression holds an rtl instruction and its semantics</i></td></tr>
<tr><th id="136">136</th><td><i>   during back-end processing.</i></td></tr>
<tr><th id="137">137</th><td><i>   See macros in "rtl.h" for the meaning of each rtx-&gt;u.fld[].</i></td></tr>
<tr><th id="138">138</th><td><i></i></td></tr>
<tr><th id="139">139</th><td><i>   ---------------------------------------------------------------------- */</i></td></tr>
<tr><th id="140">140</th><td></td></tr>
<tr><th id="141">141</th><td><i>/* An annotation for variable assignment tracking.  */</i></td></tr>
<tr><th id="142">142</th><td><a class="macro" href="rtl.h.html#52" title="DEBUG_INSN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEBUG_INSN" title='DEBUG_INSN' data-ref="DEBUG_INSN" data-ref-filename="DEBUG_INSN">DEBUG_INSN</dfn>, <q>"debug_insn"</q>, <q>"uuBeiie"</q>, RTX_INSN)</td></tr>
<tr><th id="143">143</th><td></td></tr>
<tr><th id="144">144</th><td><i>/* An instruction that cannot jump.  */</i></td></tr>
<tr><th id="145">145</th><td><a class="macro" href="rtl.h.html#52" title="INSN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="INSN" title='INSN' data-ref="INSN" data-ref-filename="INSN">INSN</dfn>, <q>"insn"</q>, <q>"uuBeiie"</q>, RTX_INSN)</td></tr>
<tr><th id="146">146</th><td></td></tr>
<tr><th id="147">147</th><td><i>/* An instruction that can possibly jump.</i></td></tr>
<tr><th id="148">148</th><td><i>   Fields ( rtx-&gt;u.fld[] ) have exact same meaning as INSN's.  */</i></td></tr>
<tr><th id="149">149</th><td><a class="macro" href="rtl.h.html#52" title="JUMP_INSN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="JUMP_INSN" title='JUMP_INSN' data-ref="JUMP_INSN" data-ref-filename="JUMP_INSN">JUMP_INSN</dfn>, <q>"jump_insn"</q>, <q>"uuBeiie0"</q>, RTX_INSN)</td></tr>
<tr><th id="150">150</th><td></td></tr>
<tr><th id="151">151</th><td><i>/* An instruction that can possibly call a subroutine</i></td></tr>
<tr><th id="152">152</th><td><i>   but which will not change which instruction comes next</i></td></tr>
<tr><th id="153">153</th><td><i>   in the current function.</i></td></tr>
<tr><th id="154">154</th><td><i>   Field ( rtx-&gt;u.fld[8] ) is CALL_INSN_FUNCTION_USAGE.</i></td></tr>
<tr><th id="155">155</th><td><i>   All other fields ( rtx-&gt;u.fld[] ) have exact same meaning as INSN's.  */</i></td></tr>
<tr><th id="156">156</th><td><a class="macro" href="rtl.h.html#52" title="CALL_INSN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CALL_INSN" title='CALL_INSN' data-ref="CALL_INSN" data-ref-filename="CALL_INSN">CALL_INSN</dfn>, <q>"call_insn"</q>, <q>"uuBeiiee"</q>, RTX_INSN)</td></tr>
<tr><th id="157">157</th><td></td></tr>
<tr><th id="158">158</th><td><i>/* Placeholder for tablejump JUMP_INSNs.  The pattern of this kind</i></td></tr>
<tr><th id="159">159</th><td><i>   of rtx is always either an ADDR_VEC or an ADDR_DIFF_VEC.  These</i></td></tr>
<tr><th id="160">160</th><td><i>   placeholders do not appear as real instructions inside a basic</i></td></tr>
<tr><th id="161">161</th><td><i>   block, but are considered active_insn_p instructions for historical</i></td></tr>
<tr><th id="162">162</th><td><i>   reasons, when jump table data was represented with JUMP_INSNs.  */</i></td></tr>
<tr><th id="163">163</th><td><a class="macro" href="rtl.h.html#52" title="JUMP_TABLE_DATA ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="JUMP_TABLE_DATA" title='JUMP_TABLE_DATA' data-ref="JUMP_TABLE_DATA" data-ref-filename="JUMP_TABLE_DATA">JUMP_TABLE_DATA</dfn>, <q>"jump_table_data"</q>, <q>"uuBe0000"</q>, RTX_INSN)</td></tr>
<tr><th id="164">164</th><td></td></tr>
<tr><th id="165">165</th><td><i>/* A marker that indicates that control will not flow through.  */</i></td></tr>
<tr><th id="166">166</th><td><a class="macro" href="rtl.h.html#52" title="BARRIER ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="BARRIER" title='BARRIER' data-ref="BARRIER" data-ref-filename="BARRIER">BARRIER</dfn>, <q>"barrier"</q>, <q>"uu00000"</q>, RTX_EXTRA)</td></tr>
<tr><th id="167">167</th><td></td></tr>
<tr><th id="168">168</th><td><i>/* Holds a label that is followed by instructions.</i></td></tr>
<tr><th id="169">169</th><td><i>   Operand:</i></td></tr>
<tr><th id="170">170</th><td><i>   3: is used in jump.c for the use-count of the label.</i></td></tr>
<tr><th id="171">171</th><td><i>   4: is used in the sh backend.</i></td></tr>
<tr><th id="172">172</th><td><i>   5: is a number that is unique in the entire compilation.</i></td></tr>
<tr><th id="173">173</th><td><i>   6: is the user-given name of the label, if any.  */</i></td></tr>
<tr><th id="174">174</th><td><a class="macro" href="rtl.h.html#52" title="CODE_LABEL ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CODE_LABEL" title='CODE_LABEL' data-ref="CODE_LABEL" data-ref-filename="CODE_LABEL">CODE_LABEL</dfn>, <q>"code_label"</q>, <q>"uuB00is"</q>, RTX_EXTRA)</td></tr>
<tr><th id="175">175</th><td></td></tr>
<tr><th id="176">176</th><td><i>/* Say where in the code a source line starts, for symbol table's sake.</i></td></tr>
<tr><th id="177">177</th><td><i>   Operand:</i></td></tr>
<tr><th id="178">178</th><td><i>   3: note-specific data</i></td></tr>
<tr><th id="179">179</th><td><i>   4: enum insn_note</i></td></tr>
<tr><th id="180">180</th><td><i>   5: unique number if insn_note == note_insn_deleted_label.  */</i></td></tr>
<tr><th id="181">181</th><td><a class="macro" href="rtl.h.html#52" title="NOTE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="NOTE" title='NOTE' data-ref="NOTE" data-ref-filename="NOTE">NOTE</dfn>, <q>"note"</q>, <q>"uuB0ni"</q>, RTX_EXTRA)</td></tr>
<tr><th id="182">182</th><td></td></tr>
<tr><th id="183">183</th><td><i>/* ----------------------------------------------------------------------</i></td></tr>
<tr><th id="184">184</th><td><i>   Top level constituents of INSN, JUMP_INSN and CALL_INSN.</i></td></tr>
<tr><th id="185">185</th><td><i>   ---------------------------------------------------------------------- */</i></td></tr>
<tr><th id="186">186</th><td></td></tr>
<tr><th id="187">187</th><td><i>/* Conditionally execute code.</i></td></tr>
<tr><th id="188">188</th><td><i>   Operand 0 is the condition that if true, the code is executed.</i></td></tr>
<tr><th id="189">189</th><td><i>   Operand 1 is the code to be executed (typically a SET).</i></td></tr>
<tr><th id="190">190</th><td><i></i></td></tr>
<tr><th id="191">191</th><td><i>   Semantics are that there are no side effects if the condition</i></td></tr>
<tr><th id="192">192</th><td><i>   is false.  This pattern is created automatically by the if_convert</i></td></tr>
<tr><th id="193">193</th><td><i>   pass run after reload or by target-specific splitters.  */</i></td></tr>
<tr><th id="194">194</th><td><a class="macro" href="rtl.h.html#52" title="COND_EXEC ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="COND_EXEC" title='COND_EXEC' data-ref="COND_EXEC" data-ref-filename="COND_EXEC">COND_EXEC</dfn>, <q>"cond_exec"</q>, <q>"ee"</q>, RTX_EXTRA)</td></tr>
<tr><th id="195">195</th><td></td></tr>
<tr><th id="196">196</th><td><i>/* Several operations to be done in parallel (perhaps under COND_EXEC).  */</i></td></tr>
<tr><th id="197">197</th><td><a class="macro" href="rtl.h.html#52" title="PARALLEL ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="PARALLEL" title='PARALLEL' data-ref="PARALLEL" data-ref-filename="PARALLEL">PARALLEL</dfn>, <q>"parallel"</q>, <q>"E"</q>, RTX_EXTRA)</td></tr>
<tr><th id="198">198</th><td></td></tr>
<tr><th id="199">199</th><td><i>/* A string that is passed through to the assembler as input.</i></td></tr>
<tr><th id="200">200</th><td><i>     One can obviously pass comments through by using the</i></td></tr>
<tr><th id="201">201</th><td><i>     assembler comment syntax.</i></td></tr>
<tr><th id="202">202</th><td><i>     These occur in an insn all by themselves as the PATTERN.</i></td></tr>
<tr><th id="203">203</th><td><i>     They also appear inside an ASM_OPERANDS</i></td></tr>
<tr><th id="204">204</th><td><i>     as a convenient way to hold a string.  */</i></td></tr>
<tr><th id="205">205</th><td><a class="macro" href="rtl.h.html#52" title="ASM_INPUT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ASM_INPUT" title='ASM_INPUT' data-ref="ASM_INPUT" data-ref-filename="ASM_INPUT">ASM_INPUT</dfn>, <q>"asm_input"</q>, <q>"si"</q>, RTX_EXTRA)</td></tr>
<tr><th id="206">206</th><td></td></tr>
<tr><th id="207">207</th><td><i>/* An assembler instruction with operands.</i></td></tr>
<tr><th id="208">208</th><td><i>   1st operand is the instruction template.</i></td></tr>
<tr><th id="209">209</th><td><i>   2nd operand is the constraint for the output.</i></td></tr>
<tr><th id="210">210</th><td><i>   3rd operand is the number of the output this expression refers to.</i></td></tr>
<tr><th id="211">211</th><td><i>     When an insn stores more than one value, a separate ASM_OPERANDS</i></td></tr>
<tr><th id="212">212</th><td><i>     is made for each output; this integer distinguishes them.</i></td></tr>
<tr><th id="213">213</th><td><i>   4th is a vector of values of input operands.</i></td></tr>
<tr><th id="214">214</th><td><i>   5th is a vector of modes and constraints for the input operands.</i></td></tr>
<tr><th id="215">215</th><td><i>     Each element is an ASM_INPUT containing a constraint string</i></td></tr>
<tr><th id="216">216</th><td><i>     and whose mode indicates the mode of the input operand.</i></td></tr>
<tr><th id="217">217</th><td><i>   6th is a vector of labels that may be branched to by the asm.</i></td></tr>
<tr><th id="218">218</th><td><i>   7th is the source line number.  */</i></td></tr>
<tr><th id="219">219</th><td><a class="macro" href="rtl.h.html#52" title="ASM_OPERANDS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ASM_OPERANDS" title='ASM_OPERANDS' data-ref="ASM_OPERANDS" data-ref-filename="ASM_OPERANDS">ASM_OPERANDS</dfn>, <q>"asm_operands"</q>, <q>"ssiEEEi"</q>, RTX_EXTRA)</td></tr>
<tr><th id="220">220</th><td></td></tr>
<tr><th id="221">221</th><td><i>/* A machine-specific operation.</i></td></tr>
<tr><th id="222">222</th><td><i>   1st operand is a vector of operands being used by the operation so that</i></td></tr>
<tr><th id="223">223</th><td><i>     any needed reloads can be done.</i></td></tr>
<tr><th id="224">224</th><td><i>   2nd operand is a unique value saying which of a number of machine-specific</i></td></tr>
<tr><th id="225">225</th><td><i>     operations is to be performed.</i></td></tr>
<tr><th id="226">226</th><td><i>   (Note that the vector must be the first operand because of the way that</i></td></tr>
<tr><th id="227">227</th><td><i>   genrecog.c record positions within an insn.)</i></td></tr>
<tr><th id="228">228</th><td><i></i></td></tr>
<tr><th id="229">229</th><td><i>   UNSPEC can occur all by itself in a PATTERN, as a component of a PARALLEL,</i></td></tr>
<tr><th id="230">230</th><td><i>   or inside an expression.</i></td></tr>
<tr><th id="231">231</th><td><i>   UNSPEC by itself or as a component of a PARALLEL</i></td></tr>
<tr><th id="232">232</th><td><i>   is currently considered not deletable.</i></td></tr>
<tr><th id="233">233</th><td><i></i></td></tr>
<tr><th id="234">234</th><td><i>   FIXME: Replace all uses of UNSPEC that appears by itself or as a component</i></td></tr>
<tr><th id="235">235</th><td><i>   of a PARALLEL with USE.</i></td></tr>
<tr><th id="236">236</th><td><i>   */</i></td></tr>
<tr><th id="237">237</th><td><a class="macro" href="rtl.h.html#52" title="UNSPEC ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNSPEC" title='UNSPEC' data-ref="UNSPEC" data-ref-filename="UNSPEC">UNSPEC</dfn>, <q>"unspec"</q>, <q>"Ei"</q>, RTX_EXTRA)</td></tr>
<tr><th id="238">238</th><td></td></tr>
<tr><th id="239">239</th><td><i>/* Similar, but a volatile operation and one which may trap.  */</i></td></tr>
<tr><th id="240">240</th><td><a class="macro" href="rtl.h.html#52" title="UNSPEC_VOLATILE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNSPEC_VOLATILE" title='UNSPEC_VOLATILE' data-ref="UNSPEC_VOLATILE" data-ref-filename="UNSPEC_VOLATILE">UNSPEC_VOLATILE</dfn>, <q>"unspec_volatile"</q>, <q>"Ei"</q>, RTX_EXTRA)</td></tr>
<tr><th id="241">241</th><td></td></tr>
<tr><th id="242">242</th><td><i>/* ----------------------------------------------------------------------</i></td></tr>
<tr><th id="243">243</th><td><i>   Table jump addresses.</i></td></tr>
<tr><th id="244">244</th><td><i>   ---------------------------------------------------------------------- */</i></td></tr>
<tr><th id="245">245</th><td></td></tr>
<tr><th id="246">246</th><td><i>/* Vector of addresses, stored as full words.</i></td></tr>
<tr><th id="247">247</th><td><i>   Each element is a LABEL_REF to a CODE_LABEL whose address we want.  */</i></td></tr>
<tr><th id="248">248</th><td><a class="macro" href="rtl.h.html#52" title="ADDR_VEC ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ADDR_VEC" title='ADDR_VEC' data-ref="ADDR_VEC" data-ref-filename="ADDR_VEC">ADDR_VEC</dfn>, <q>"addr_vec"</q>, <q>"E"</q>, RTX_EXTRA)</td></tr>
<tr><th id="249">249</th><td></td></tr>
<tr><th id="250">250</th><td><i>/* Vector of address differences X0 - BASE, X1 - BASE, ...</i></td></tr>
<tr><th id="251">251</th><td><i>   First operand is BASE; the vector contains the X's.</i></td></tr>
<tr><th id="252">252</th><td><i>   The machine mode of this rtx says how much space to leave</i></td></tr>
<tr><th id="253">253</th><td><i>   for each difference and is adjusted by branch shortening if</i></td></tr>
<tr><th id="254">254</th><td><i>   CASE_VECTOR_SHORTEN_MODE is defined.</i></td></tr>
<tr><th id="255">255</th><td><i>   The third and fourth operands store the target labels with the</i></td></tr>
<tr><th id="256">256</th><td><i>   minimum and maximum addresses respectively.</i></td></tr>
<tr><th id="257">257</th><td><i>   The fifth operand stores flags for use by branch shortening.</i></td></tr>
<tr><th id="258">258</th><td><i>  Set at the start of shorten_branches:</i></td></tr>
<tr><th id="259">259</th><td><i>   min_align: the minimum alignment for any of the target labels.</i></td></tr>
<tr><th id="260">260</th><td><i>   base_after_vec: true iff BASE is after the ADDR_DIFF_VEC.</i></td></tr>
<tr><th id="261">261</th><td><i>   min_after_vec: true iff minimum addr target label is after the ADDR_DIFF_VEC.</i></td></tr>
<tr><th id="262">262</th><td><i>   max_after_vec: true iff maximum addr target label is after the ADDR_DIFF_VEC.</i></td></tr>
<tr><th id="263">263</th><td><i>   min_after_base: true iff minimum address target label is after BASE.</i></td></tr>
<tr><th id="264">264</th><td><i>   max_after_base: true iff maximum address target label is after BASE.</i></td></tr>
<tr><th id="265">265</th><td><i>  Set by the actual branch shortening process:</i></td></tr>
<tr><th id="266">266</th><td><i>   offset_unsigned: true iff offsets have to be treated as unsigned.</i></td></tr>
<tr><th id="267">267</th><td><i>   scale: scaling that is necessary to make offsets fit into the mode.</i></td></tr>
<tr><th id="268">268</th><td><i></i></td></tr>
<tr><th id="269">269</th><td><i>   The third, fourth and fifth operands are only valid when</i></td></tr>
<tr><th id="270">270</th><td><i>   CASE_VECTOR_SHORTEN_MODE is defined, and only in an optimizing</i></td></tr>
<tr><th id="271">271</th><td><i>   compilation.  */</i></td></tr>
<tr><th id="272">272</th><td><a class="macro" href="rtl.h.html#52" title="ADDR_DIFF_VEC ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ADDR_DIFF_VEC" title='ADDR_DIFF_VEC' data-ref="ADDR_DIFF_VEC" data-ref-filename="ADDR_DIFF_VEC">ADDR_DIFF_VEC</dfn>, <q>"addr_diff_vec"</q>, <q>"eEee0"</q>, RTX_EXTRA)</td></tr>
<tr><th id="273">273</th><td></td></tr>
<tr><th id="274">274</th><td><i>/* Memory prefetch, with attributes supported on some targets.</i></td></tr>
<tr><th id="275">275</th><td><i>   Operand 1 is the address of the memory to fetch.</i></td></tr>
<tr><th id="276">276</th><td><i>   Operand 2 is 1 for a write access, 0 otherwise.</i></td></tr>
<tr><th id="277">277</th><td><i>   Operand 3 is the level of temporal locality; 0 means there is no</i></td></tr>
<tr><th id="278">278</th><td><i>   temporal locality and 1, 2, and 3 are for increasing levels of temporal</i></td></tr>
<tr><th id="279">279</th><td><i>   locality.</i></td></tr>
<tr><th id="280">280</th><td><i></i></td></tr>
<tr><th id="281">281</th><td><i>   The attributes specified by operands 2 and 3 are ignored for targets</i></td></tr>
<tr><th id="282">282</th><td><i>   whose prefetch instructions do not support them.  */</i></td></tr>
<tr><th id="283">283</th><td><a class="macro" href="rtl.h.html#52" title="PREFETCH ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="PREFETCH" title='PREFETCH' data-ref="PREFETCH" data-ref-filename="PREFETCH">PREFETCH</dfn>, <q>"prefetch"</q>, <q>"eee"</q>, RTX_EXTRA)</td></tr>
<tr><th id="284">284</th><td></td></tr>
<tr><th id="285">285</th><td><i>/* ----------------------------------------------------------------------</i></td></tr>
<tr><th id="286">286</th><td><i>   At the top level of an instruction (perhaps under PARALLEL).</i></td></tr>
<tr><th id="287">287</th><td><i>   ---------------------------------------------------------------------- */</i></td></tr>
<tr><th id="288">288</th><td></td></tr>
<tr><th id="289">289</th><td><i>/* Assignment.</i></td></tr>
<tr><th id="290">290</th><td><i>   Operand 1 is the location (REG, MEM, PC, CC0 or whatever) assigned to.</i></td></tr>
<tr><th id="291">291</th><td><i>   Operand 2 is the value stored there.</i></td></tr>
<tr><th id="292">292</th><td><i>   ALL assignment must use SET.</i></td></tr>
<tr><th id="293">293</th><td><i>   Instructions that do multiple assignments must use multiple SET,</i></td></tr>
<tr><th id="294">294</th><td><i>   under PARALLEL.  */</i></td></tr>
<tr><th id="295">295</th><td><a class="macro" href="rtl.h.html#52" title="SET ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SET" title='SET' data-ref="SET" data-ref-filename="SET">SET</dfn>, <q>"set"</q>, <q>"ee"</q>, RTX_EXTRA)</td></tr>
<tr><th id="296">296</th><td></td></tr>
<tr><th id="297">297</th><td><i>/* Indicate something is used in a way that we don't want to explain.</i></td></tr>
<tr><th id="298">298</th><td><i>   For example, subroutine calls will use the register</i></td></tr>
<tr><th id="299">299</th><td><i>   in which the static chain is passed.</i></td></tr>
<tr><th id="300">300</th><td><i></i></td></tr>
<tr><th id="301">301</th><td><i>   USE can not appear as an operand of other rtx except for PARALLEL.</i></td></tr>
<tr><th id="302">302</th><td><i>   USE is not deletable, as it indicates that the operand</i></td></tr>
<tr><th id="303">303</th><td><i>   is used in some unknown way.  */</i></td></tr>
<tr><th id="304">304</th><td><a class="macro" href="rtl.h.html#52" title="USE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="USE" title='USE' data-ref="USE" data-ref-filename="USE">USE</dfn>, <q>"use"</q>, <q>"e"</q>, RTX_EXTRA)</td></tr>
<tr><th id="305">305</th><td></td></tr>
<tr><th id="306">306</th><td><i>/* Indicate something is clobbered in a way that we don't want to explain.</i></td></tr>
<tr><th id="307">307</th><td><i>   For example, subroutine calls will clobber some physical registers</i></td></tr>
<tr><th id="308">308</th><td><i>   (the ones that are by convention not saved).</i></td></tr>
<tr><th id="309">309</th><td><i></i></td></tr>
<tr><th id="310">310</th><td><i>   CLOBBER can not appear as an operand of other rtx except for PARALLEL.</i></td></tr>
<tr><th id="311">311</th><td><i>   CLOBBER of a hard register appearing by itself (not within PARALLEL)</i></td></tr>
<tr><th id="312">312</th><td><i>   is considered undeletable before reload.  */</i></td></tr>
<tr><th id="313">313</th><td><a class="macro" href="rtl.h.html#52" title="CLOBBER ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CLOBBER" title='CLOBBER' data-ref="CLOBBER" data-ref-filename="CLOBBER">CLOBBER</dfn>, <q>"clobber"</q>, <q>"e"</q>, RTX_EXTRA)</td></tr>
<tr><th id="314">314</th><td></td></tr>
<tr><th id="315">315</th><td><i>/* Call a subroutine.</i></td></tr>
<tr><th id="316">316</th><td><i>   Operand 1 is the address to call.</i></td></tr>
<tr><th id="317">317</th><td><i>   Operand 2 is the number of arguments.  */</i></td></tr>
<tr><th id="318">318</th><td></td></tr>
<tr><th id="319">319</th><td><a class="macro" href="rtl.h.html#52" title="CALL ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CALL" title='CALL' data-ref="CALL" data-ref-filename="CALL">CALL</dfn>, <q>"call"</q>, <q>"ee"</q>, RTX_EXTRA)</td></tr>
<tr><th id="320">320</th><td></td></tr>
<tr><th id="321">321</th><td><i>/* Return from a subroutine.  */</i></td></tr>
<tr><th id="322">322</th><td></td></tr>
<tr><th id="323">323</th><td><a class="macro" href="rtl.h.html#52" title="RETURN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="RETURN" title='RETURN' data-ref="RETURN" data-ref-filename="RETURN">RETURN</dfn>, <q>"return"</q>, <q>""</q>, RTX_EXTRA)</td></tr>
<tr><th id="324">324</th><td></td></tr>
<tr><th id="325">325</th><td><i>/* Like RETURN, but truly represents only a function return, while</i></td></tr>
<tr><th id="326">326</th><td><i>   RETURN may represent an insn that also performs other functions</i></td></tr>
<tr><th id="327">327</th><td><i>   of the function epilogue.  Like RETURN, this may also occur in</i></td></tr>
<tr><th id="328">328</th><td><i>   conditional jumps.  */</i></td></tr>
<tr><th id="329">329</th><td><a class="macro" href="rtl.h.html#52" title="SIMPLE_RETURN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SIMPLE_RETURN" title='SIMPLE_RETURN' data-ref="SIMPLE_RETURN" data-ref-filename="SIMPLE_RETURN">SIMPLE_RETURN</dfn>, <q>"simple_return"</q>, <q>""</q>, RTX_EXTRA)</td></tr>
<tr><th id="330">330</th><td></td></tr>
<tr><th id="331">331</th><td><i>/* Special for EH return from subroutine.  */</i></td></tr>
<tr><th id="332">332</th><td></td></tr>
<tr><th id="333">333</th><td><a class="macro" href="rtl.h.html#52" title="EH_RETURN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="EH_RETURN" title='EH_RETURN' data-ref="EH_RETURN" data-ref-filename="EH_RETURN">EH_RETURN</dfn>, <q>"eh_return"</q>, <q>""</q>, RTX_EXTRA)</td></tr>
<tr><th id="334">334</th><td></td></tr>
<tr><th id="335">335</th><td><i>/* Conditional trap.</i></td></tr>
<tr><th id="336">336</th><td><i>   Operand 1 is the condition.</i></td></tr>
<tr><th id="337">337</th><td><i>   Operand 2 is the trap code.</i></td></tr>
<tr><th id="338">338</th><td><i>   For an unconditional trap, make the condition (const_int 1).  */</i></td></tr>
<tr><th id="339">339</th><td><a class="macro" href="rtl.h.html#52" title="TRAP_IF ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="TRAP_IF" title='TRAP_IF' data-ref="TRAP_IF" data-ref-filename="TRAP_IF">TRAP_IF</dfn>, <q>"trap_if"</q>, <q>"ee"</q>, RTX_EXTRA)</td></tr>
<tr><th id="340">340</th><td></td></tr>
<tr><th id="341">341</th><td><i>/* ----------------------------------------------------------------------</i></td></tr>
<tr><th id="342">342</th><td><i>   Primitive values for use in expressions.</i></td></tr>
<tr><th id="343">343</th><td><i>   ---------------------------------------------------------------------- */</i></td></tr>
<tr><th id="344">344</th><td></td></tr>
<tr><th id="345">345</th><td><i>/* numeric integer constant */</i></td></tr>
<tr><th id="346">346</th><td><a class="macro" href="rtl.h.html#52" title="CONST_INT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CONST_INT" title='CONST_INT' data-ref="CONST_INT" data-ref-filename="CONST_INT">CONST_INT</dfn>, <q>"const_int"</q>, <q>"w"</q>, RTX_CONST_OBJ)</td></tr>
<tr><th id="347">347</th><td></td></tr>
<tr><th id="348">348</th><td><i>/* numeric integer constant */</i></td></tr>
<tr><th id="349">349</th><td><a class="macro" href="rtl.h.html#52" title="CONST_WIDE_INT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CONST_WIDE_INT" title='CONST_WIDE_INT' data-ref="CONST_WIDE_INT" data-ref-filename="CONST_WIDE_INT">CONST_WIDE_INT</dfn>, <q>"const_wide_int"</q>, <q>""</q>, RTX_CONST_OBJ)</td></tr>
<tr><th id="350">350</th><td></td></tr>
<tr><th id="351">351</th><td><i>/* fixed-point constant */</i></td></tr>
<tr><th id="352">352</th><td><a class="macro" href="rtl.h.html#52" title="CONST_FIXED ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CONST_FIXED" title='CONST_FIXED' data-ref="CONST_FIXED" data-ref-filename="CONST_FIXED">CONST_FIXED</dfn>, <q>"const_fixed"</q>, <q>"www"</q>, RTX_CONST_OBJ)</td></tr>
<tr><th id="353">353</th><td></td></tr>
<tr><th id="354">354</th><td><i>/* numeric floating point or integer constant.  If the mode is</i></td></tr>
<tr><th id="355">355</th><td><i>   VOIDmode it is an int otherwise it has a floating point mode and a</i></td></tr>
<tr><th id="356">356</th><td><i>   floating point value.  Operands hold the value.  They are all 'w'</i></td></tr>
<tr><th id="357">357</th><td><i>   and there may be from 2 to 6; see real.h.  */</i></td></tr>
<tr><th id="358">358</th><td><a class="macro" href="rtl.h.html#52" title="CONST_DOUBLE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CONST_DOUBLE" title='CONST_DOUBLE' data-ref="CONST_DOUBLE" data-ref-filename="CONST_DOUBLE">CONST_DOUBLE</dfn>, <q>"const_double"</q>, CONST_DOUBLE_FORMAT, RTX_CONST_OBJ)</td></tr>
<tr><th id="359">359</th><td></td></tr>
<tr><th id="360">360</th><td><i>/* Describes a vector constant.  */</i></td></tr>
<tr><th id="361">361</th><td><a class="macro" href="rtl.h.html#52" title="CONST_VECTOR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CONST_VECTOR" title='CONST_VECTOR' data-ref="CONST_VECTOR" data-ref-filename="CONST_VECTOR">CONST_VECTOR</dfn>, <q>"const_vector"</q>, <q>"E"</q>, RTX_CONST_OBJ)</td></tr>
<tr><th id="362">362</th><td></td></tr>
<tr><th id="363">363</th><td><i>/* String constant.  Used for attributes in machine descriptions and</i></td></tr>
<tr><th id="364">364</th><td><i>   for special cases in DWARF2 debug output.  NOT used for source-</i></td></tr>
<tr><th id="365">365</th><td><i>   language string constants.  */</i></td></tr>
<tr><th id="366">366</th><td><a class="macro" href="rtl.h.html#52" title="CONST_STRING ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CONST_STRING" title='CONST_STRING' data-ref="CONST_STRING" data-ref-filename="CONST_STRING">CONST_STRING</dfn>, <q>"const_string"</q>, <q>"s"</q>, RTX_OBJ)</td></tr>
<tr><th id="367">367</th><td></td></tr>
<tr><th id="368">368</th><td><i>/* This is used to encapsulate an expression whose value is constant</i></td></tr>
<tr><th id="369">369</th><td><i>   (such as the sum of a SYMBOL_REF and a CONST_INT) so that it will be</i></td></tr>
<tr><th id="370">370</th><td><i>   recognized as a constant operand rather than by arithmetic instructions.  */</i></td></tr>
<tr><th id="371">371</th><td></td></tr>
<tr><th id="372">372</th><td><a class="macro" href="rtl.h.html#52" title="CONST ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CONST" title='CONST' data-ref="CONST" data-ref-filename="CONST">CONST</dfn>, <q>"const"</q>, <q>"e"</q>, RTX_CONST_OBJ)</td></tr>
<tr><th id="373">373</th><td></td></tr>
<tr><th id="374">374</th><td><i>/* program counter.  Ordinary jumps are represented</i></td></tr>
<tr><th id="375">375</th><td><i>   by a SET whose first operand is (PC).  */</i></td></tr>
<tr><th id="376">376</th><td><a class="macro" href="rtl.h.html#52" title="PC ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="PC" title='PC' data-ref="PC" data-ref-filename="PC">PC</dfn>, <q>"pc"</q>, <q>""</q>, RTX_OBJ)</td></tr>
<tr><th id="377">377</th><td></td></tr>
<tr><th id="378">378</th><td><i>/* A register.  The "operand" is the register number, accessed with</i></td></tr>
<tr><th id="379">379</th><td><i>   the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER</i></td></tr>
<tr><th id="380">380</th><td><i>   than a hardware register is being referred to.  The second operand</i></td></tr>
<tr><th id="381">381</th><td><i>   points to a reg_attrs structure.</i></td></tr>
<tr><th id="382">382</th><td><i>   This rtx needs to have as many (or more) fields as a MEM, since we</i></td></tr>
<tr><th id="383">383</th><td><i>   can change REG rtx's into MEMs during reload.  */</i></td></tr>
<tr><th id="384">384</th><td><a class="macro" href="rtl.h.html#52" title="REG ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="REG" title='REG' data-ref="REG" data-ref-filename="REG">REG</dfn>, <q>"reg"</q>, <q>"r"</q>, RTX_OBJ)</td></tr>
<tr><th id="385">385</th><td></td></tr>
<tr><th id="386">386</th><td><i>/* A scratch register.  This represents a register used only within a</i></td></tr>
<tr><th id="387">387</th><td><i>   single insn.  It will be replaced by a REG during register allocation</i></td></tr>
<tr><th id="388">388</th><td><i>   or reload unless the constraint indicates that the register won't be</i></td></tr>
<tr><th id="389">389</th><td><i>   needed, in which case it can remain a SCRATCH.  */</i></td></tr>
<tr><th id="390">390</th><td><a class="macro" href="rtl.h.html#52" title="SCRATCH ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SCRATCH" title='SCRATCH' data-ref="SCRATCH" data-ref-filename="SCRATCH">SCRATCH</dfn>, <q>"scratch"</q>, <q>""</q>, RTX_OBJ)</td></tr>
<tr><th id="391">391</th><td></td></tr>
<tr><th id="392">392</th><td><i>/* A reference to a part of another value.  The first operand is the</i></td></tr>
<tr><th id="393">393</th><td><i>   complete value and the second is the byte offset of the selected part.   */</i></td></tr>
<tr><th id="394">394</th><td><a class="macro" href="rtl.h.html#52" title="SUBREG ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SUBREG" title='SUBREG' data-ref="SUBREG" data-ref-filename="SUBREG">SUBREG</dfn>, <q>"subreg"</q>, <q>"ei"</q>, RTX_EXTRA)</td></tr>
<tr><th id="395">395</th><td></td></tr>
<tr><th id="396">396</th><td><i>/* This one-argument rtx is used for move instructions</i></td></tr>
<tr><th id="397">397</th><td><i>   that are guaranteed to alter only the low part of a destination.</i></td></tr>
<tr><th id="398">398</th><td><i>   Thus, (SET (SUBREG:HI (REG...)) (MEM:HI ...))</i></td></tr>
<tr><th id="399">399</th><td><i>   has an unspecified effect on the high part of REG,</i></td></tr>
<tr><th id="400">400</th><td><i>   but (SET (STRICT_LOW_PART (SUBREG:HI (REG...))) (MEM:HI ...))</i></td></tr>
<tr><th id="401">401</th><td><i>   is guaranteed to alter only the bits of REG that are in HImode.</i></td></tr>
<tr><th id="402">402</th><td><i></i></td></tr>
<tr><th id="403">403</th><td><i>   The actual instruction used is probably the same in both cases,</i></td></tr>
<tr><th id="404">404</th><td><i>   but the register constraints may be tighter when STRICT_LOW_PART</i></td></tr>
<tr><th id="405">405</th><td><i>   is in use.  */</i></td></tr>
<tr><th id="406">406</th><td></td></tr>
<tr><th id="407">407</th><td><a class="macro" href="rtl.h.html#52" title="STRICT_LOW_PART ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="STRICT_LOW_PART" title='STRICT_LOW_PART' data-ref="STRICT_LOW_PART" data-ref-filename="STRICT_LOW_PART">STRICT_LOW_PART</dfn>, <q>"strict_low_part"</q>, <q>"e"</q>, RTX_EXTRA)</td></tr>
<tr><th id="408">408</th><td></td></tr>
<tr><th id="409">409</th><td><i>/* (CONCAT a b) represents the virtual concatenation of a and b</i></td></tr>
<tr><th id="410">410</th><td><i>   to make a value that has as many bits as a and b put together.</i></td></tr>
<tr><th id="411">411</th><td><i>   This is used for complex values.  Normally it appears only</i></td></tr>
<tr><th id="412">412</th><td><i>   in DECL_RTLs and during RTL generation, but not in the insn chain.  */</i></td></tr>
<tr><th id="413">413</th><td><a class="macro" href="rtl.h.html#52" title="CONCAT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CONCAT" title='CONCAT' data-ref="CONCAT" data-ref-filename="CONCAT">CONCAT</dfn>, <q>"concat"</q>, <q>"ee"</q>, RTX_OBJ)</td></tr>
<tr><th id="414">414</th><td></td></tr>
<tr><th id="415">415</th><td><i>/* (CONCATN [a1 a2 ... an]) represents the virtual concatenation of</i></td></tr>
<tr><th id="416">416</th><td><i>   all An to make a value.  This is an extension of CONCAT to larger</i></td></tr>
<tr><th id="417">417</th><td><i>   number of components.  Like CONCAT, it should not appear in the</i></td></tr>
<tr><th id="418">418</th><td><i>   insn chain.  Every element of the CONCATN is the same size.  */</i></td></tr>
<tr><th id="419">419</th><td><a class="macro" href="rtl.h.html#52" title="CONCATN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CONCATN" title='CONCATN' data-ref="CONCATN" data-ref-filename="CONCATN">CONCATN</dfn>, <q>"concatn"</q>, <q>"E"</q>, RTX_OBJ)</td></tr>
<tr><th id="420">420</th><td></td></tr>
<tr><th id="421">421</th><td><i>/* A memory location; operand is the address.  The second operand is the</i></td></tr>
<tr><th id="422">422</th><td><i>   alias set to which this MEM belongs.  We use `0' instead of `w' for this</i></td></tr>
<tr><th id="423">423</th><td><i>   field so that the field need not be specified in machine descriptions.  */</i></td></tr>
<tr><th id="424">424</th><td><a class="macro" href="rtl.h.html#52" title="MEM ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MEM" title='MEM' data-ref="MEM" data-ref-filename="MEM">MEM</dfn>, <q>"mem"</q>, <q>"e0"</q>, RTX_OBJ)</td></tr>
<tr><th id="425">425</th><td></td></tr>
<tr><th id="426">426</th><td><i>/* Reference to an assembler label in the code for this function.</i></td></tr>
<tr><th id="427">427</th><td><i>   The operand is a CODE_LABEL found in the insn chain.  */</i></td></tr>
<tr><th id="428">428</th><td><a class="macro" href="rtl.h.html#52" title="LABEL_REF ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="LABEL_REF" title='LABEL_REF' data-ref="LABEL_REF" data-ref-filename="LABEL_REF">LABEL_REF</dfn>, <q>"label_ref"</q>, <q>"u"</q>, RTX_CONST_OBJ)</td></tr>
<tr><th id="429">429</th><td></td></tr>
<tr><th id="430">430</th><td><i>/* Reference to a named label:</i></td></tr>
<tr><th id="431">431</th><td><i>   Operand 0: label name</i></td></tr>
<tr><th id="432">432</th><td><i>   Operand 1: tree from which this symbol is derived, or null.</i></td></tr>
<tr><th id="433">433</th><td><i>   This is either a DECL node, or some kind of constant.  */</i></td></tr>
<tr><th id="434">434</th><td><a class="macro" href="rtl.h.html#52" title="SYMBOL_REF ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SYMBOL_REF" title='SYMBOL_REF' data-ref="SYMBOL_REF" data-ref-filename="SYMBOL_REF">SYMBOL_REF</dfn>, <q>"symbol_ref"</q>, <q>"s0"</q>, RTX_CONST_OBJ)</td></tr>
<tr><th id="435">435</th><td></td></tr>
<tr><th id="436">436</th><td><i>/* The condition code register is represented, in our imagination,</i></td></tr>
<tr><th id="437">437</th><td><i>   as a register holding a value that can be compared to zero.</i></td></tr>
<tr><th id="438">438</th><td><i>   In fact, the machine has already compared them and recorded the</i></td></tr>
<tr><th id="439">439</th><td><i>   results; but instructions that look at the condition code</i></td></tr>
<tr><th id="440">440</th><td><i>   pretend to be looking at the entire value and comparing it.  */</i></td></tr>
<tr><th id="441">441</th><td><a class="macro" href="rtl.h.html#52" title="CC0 ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CC0" title='CC0' data-ref="CC0" data-ref-filename="CC0">CC0</dfn>, <q>"cc0"</q>, <q>""</q>, RTX_OBJ)</td></tr>
<tr><th id="442">442</th><td></td></tr>
<tr><th id="443">443</th><td><i>/* ----------------------------------------------------------------------</i></td></tr>
<tr><th id="444">444</th><td><i>   Expressions for operators in an rtl pattern</i></td></tr>
<tr><th id="445">445</th><td><i>   ---------------------------------------------------------------------- */</i></td></tr>
<tr><th id="446">446</th><td></td></tr>
<tr><th id="447">447</th><td><i>/* if_then_else.  This is used in representing ordinary</i></td></tr>
<tr><th id="448">448</th><td><i>   conditional jump instructions.</i></td></tr>
<tr><th id="449">449</th><td><i>     Operand:</i></td></tr>
<tr><th id="450">450</th><td><i>     0:  condition</i></td></tr>
<tr><th id="451">451</th><td><i>     1:  then expr</i></td></tr>
<tr><th id="452">452</th><td><i>     2:  else expr */</i></td></tr>
<tr><th id="453">453</th><td><a class="macro" href="rtl.h.html#52" title="IF_THEN_ELSE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="IF_THEN_ELSE" title='IF_THEN_ELSE' data-ref="IF_THEN_ELSE" data-ref-filename="IF_THEN_ELSE">IF_THEN_ELSE</dfn>, <q>"if_then_else"</q>, <q>"eee"</q>, RTX_TERNARY)</td></tr>
<tr><th id="454">454</th><td></td></tr>
<tr><th id="455">455</th><td><i>/* Comparison, produces a condition code result.  */</i></td></tr>
<tr><th id="456">456</th><td><a class="macro" href="rtl.h.html#52" title="COMPARE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="COMPARE" title='COMPARE' data-ref="COMPARE" data-ref-filename="COMPARE">COMPARE</dfn>, <q>"compare"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="457">457</th><td></td></tr>
<tr><th id="458">458</th><td><i>/* plus */</i></td></tr>
<tr><th id="459">459</th><td><a class="macro" href="rtl.h.html#52" title="PLUS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="PLUS" title='PLUS' data-ref="PLUS" data-ref-filename="PLUS">PLUS</dfn>, <q>"plus"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="460">460</th><td></td></tr>
<tr><th id="461">461</th><td><i>/* Operand 0 minus operand 1.  */</i></td></tr>
<tr><th id="462">462</th><td><a class="macro" href="rtl.h.html#52" title="MINUS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MINUS" title='MINUS' data-ref="MINUS" data-ref-filename="MINUS">MINUS</dfn>, <q>"minus"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="463">463</th><td></td></tr>
<tr><th id="464">464</th><td><i>/* Minus operand 0.  */</i></td></tr>
<tr><th id="465">465</th><td><a class="macro" href="rtl.h.html#52" title="NEG ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="NEG" title='NEG' data-ref="NEG" data-ref-filename="NEG">NEG</dfn>, <q>"neg"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="466">466</th><td></td></tr>
<tr><th id="467">467</th><td><a class="macro" href="rtl.h.html#52" title="MULT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MULT" title='MULT' data-ref="MULT" data-ref-filename="MULT">MULT</dfn>, <q>"mult"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="468">468</th><td></td></tr>
<tr><th id="469">469</th><td><i>/* Multiplication with signed saturation */</i></td></tr>
<tr><th id="470">470</th><td><a class="macro" href="rtl.h.html#52" title="SS_MULT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SS_MULT" title='SS_MULT' data-ref="SS_MULT" data-ref-filename="SS_MULT">SS_MULT</dfn>, <q>"ss_mult"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="471">471</th><td><i>/* Multiplication with unsigned saturation */</i></td></tr>
<tr><th id="472">472</th><td><a class="macro" href="rtl.h.html#52" title="US_MULT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="US_MULT" title='US_MULT' data-ref="US_MULT" data-ref-filename="US_MULT">US_MULT</dfn>, <q>"us_mult"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="473">473</th><td></td></tr>
<tr><th id="474">474</th><td><i>/* Operand 0 divided by operand 1.  */</i></td></tr>
<tr><th id="475">475</th><td><a class="macro" href="rtl.h.html#52" title="DIV ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DIV" title='DIV' data-ref="DIV" data-ref-filename="DIV">DIV</dfn>, <q>"div"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="476">476</th><td><i>/* Division with signed saturation */</i></td></tr>
<tr><th id="477">477</th><td><a class="macro" href="rtl.h.html#52" title="SS_DIV ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SS_DIV" title='SS_DIV' data-ref="SS_DIV" data-ref-filename="SS_DIV">SS_DIV</dfn>, <q>"ss_div"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="478">478</th><td><i>/* Division with unsigned saturation */</i></td></tr>
<tr><th id="479">479</th><td><a class="macro" href="rtl.h.html#52" title="US_DIV ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="US_DIV" title='US_DIV' data-ref="US_DIV" data-ref-filename="US_DIV">US_DIV</dfn>, <q>"us_div"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="480">480</th><td></td></tr>
<tr><th id="481">481</th><td><i>/* Remainder of operand 0 divided by operand 1.  */</i></td></tr>
<tr><th id="482">482</th><td><a class="macro" href="rtl.h.html#52" title="MOD ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MOD" title='MOD' data-ref="MOD" data-ref-filename="MOD">MOD</dfn>, <q>"mod"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="483">483</th><td></td></tr>
<tr><th id="484">484</th><td><i>/* Unsigned divide and remainder.  */</i></td></tr>
<tr><th id="485">485</th><td><a class="macro" href="rtl.h.html#52" title="UDIV ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UDIV" title='UDIV' data-ref="UDIV" data-ref-filename="UDIV">UDIV</dfn>, <q>"udiv"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="486">486</th><td><a class="macro" href="rtl.h.html#52" title="UMOD ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UMOD" title='UMOD' data-ref="UMOD" data-ref-filename="UMOD">UMOD</dfn>, <q>"umod"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="487">487</th><td></td></tr>
<tr><th id="488">488</th><td><i>/* Bitwise operations.  */</i></td></tr>
<tr><th id="489">489</th><td><a class="macro" href="rtl.h.html#52" title="AND ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="AND" title='AND' data-ref="AND" data-ref-filename="AND">AND</dfn>, <q>"and"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="490">490</th><td><a class="macro" href="rtl.h.html#52" title="IOR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="IOR" title='IOR' data-ref="IOR" data-ref-filename="IOR">IOR</dfn>, <q>"ior"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="491">491</th><td><a class="macro" href="rtl.h.html#52" title="XOR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="XOR" title='XOR' data-ref="XOR" data-ref-filename="XOR">XOR</dfn>, <q>"xor"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="492">492</th><td><a class="macro" href="rtl.h.html#52" title="NOT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="NOT" title='NOT' data-ref="NOT" data-ref-filename="NOT">NOT</dfn>, <q>"not"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="493">493</th><td></td></tr>
<tr><th id="494">494</th><td><i>/* Operand:</i></td></tr>
<tr><th id="495">495</th><td><i>     0:  value to be shifted.</i></td></tr>
<tr><th id="496">496</th><td><i>     1:  number of bits.  */</i></td></tr>
<tr><th id="497">497</th><td><a class="macro" href="rtl.h.html#52" title="ASHIFT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ASHIFT" title='ASHIFT' data-ref="ASHIFT" data-ref-filename="ASHIFT">ASHIFT</dfn>, <q>"ashift"</q>, <q>"ee"</q>, RTX_BIN_ARITH) <i>/* shift left */</i></td></tr>
<tr><th id="498">498</th><td><a class="macro" href="rtl.h.html#52" title="ROTATE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ROTATE" title='ROTATE' data-ref="ROTATE" data-ref-filename="ROTATE">ROTATE</dfn>, <q>"rotate"</q>, <q>"ee"</q>, RTX_BIN_ARITH) <i>/* rotate left */</i></td></tr>
<tr><th id="499">499</th><td><a class="macro" href="rtl.h.html#52" title="ASHIFTRT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ASHIFTRT" title='ASHIFTRT' data-ref="ASHIFTRT" data-ref-filename="ASHIFTRT">ASHIFTRT</dfn>, <q>"ashiftrt"</q>, <q>"ee"</q>, RTX_BIN_ARITH) <i>/* arithmetic shift right */</i></td></tr>
<tr><th id="500">500</th><td><a class="macro" href="rtl.h.html#52" title="LSHIFTRT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="LSHIFTRT" title='LSHIFTRT' data-ref="LSHIFTRT" data-ref-filename="LSHIFTRT">LSHIFTRT</dfn>, <q>"lshiftrt"</q>, <q>"ee"</q>, RTX_BIN_ARITH) <i>/* logical shift right */</i></td></tr>
<tr><th id="501">501</th><td><a class="macro" href="rtl.h.html#52" title="ROTATERT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ROTATERT" title='ROTATERT' data-ref="ROTATERT" data-ref-filename="ROTATERT">ROTATERT</dfn>, <q>"rotatert"</q>, <q>"ee"</q>, RTX_BIN_ARITH) <i>/* rotate right */</i></td></tr>
<tr><th id="502">502</th><td></td></tr>
<tr><th id="503">503</th><td><i>/* Minimum and maximum values of two operands.  We need both signed and</i></td></tr>
<tr><th id="504">504</th><td><i>   unsigned forms.  (We cannot use MIN for SMIN because it conflicts</i></td></tr>
<tr><th id="505">505</th><td><i>   with a macro of the same name.)   The signed variants should be used</i></td></tr>
<tr><th id="506">506</th><td><i>   with floating point.  Further, if both operands are zeros, or if either</i></td></tr>
<tr><th id="507">507</th><td><i>   operand is NaN, then it is unspecified which of the two operands is</i></td></tr>
<tr><th id="508">508</th><td><i>   returned as the result.  */</i></td></tr>
<tr><th id="509">509</th><td></td></tr>
<tr><th id="510">510</th><td><a class="macro" href="rtl.h.html#52" title="SMIN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SMIN" title='SMIN' data-ref="SMIN" data-ref-filename="SMIN">SMIN</dfn>, <q>"smin"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="511">511</th><td><a class="macro" href="rtl.h.html#52" title="SMAX ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SMAX" title='SMAX' data-ref="SMAX" data-ref-filename="SMAX">SMAX</dfn>, <q>"smax"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="512">512</th><td><a class="macro" href="rtl.h.html#52" title="UMIN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UMIN" title='UMIN' data-ref="UMIN" data-ref-filename="UMIN">UMIN</dfn>, <q>"umin"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="513">513</th><td><a class="macro" href="rtl.h.html#52" title="UMAX ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UMAX" title='UMAX' data-ref="UMAX" data-ref-filename="UMAX">UMAX</dfn>, <q>"umax"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="514">514</th><td></td></tr>
<tr><th id="515">515</th><td><i>/* These unary operations are used to represent incrementation</i></td></tr>
<tr><th id="516">516</th><td><i>   and decrementation as they occur in memory addresses.</i></td></tr>
<tr><th id="517">517</th><td><i>   The amount of increment or decrement are not represented</i></td></tr>
<tr><th id="518">518</th><td><i>   because they can be understood from the machine-mode of the</i></td></tr>
<tr><th id="519">519</th><td><i>   containing MEM.  These operations exist in only two cases:</i></td></tr>
<tr><th id="520">520</th><td><i>   1. pushes onto the stack.</i></td></tr>
<tr><th id="521">521</th><td><i>   2. created automatically by the auto-inc-dec pass.  */</i></td></tr>
<tr><th id="522">522</th><td><a class="macro" href="rtl.h.html#52" title="PRE_DEC ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="PRE_DEC" title='PRE_DEC' data-ref="PRE_DEC" data-ref-filename="PRE_DEC">PRE_DEC</dfn>, <q>"pre_dec"</q>, <q>"e"</q>, RTX_AUTOINC)</td></tr>
<tr><th id="523">523</th><td><a class="macro" href="rtl.h.html#52" title="PRE_INC ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="PRE_INC" title='PRE_INC' data-ref="PRE_INC" data-ref-filename="PRE_INC">PRE_INC</dfn>, <q>"pre_inc"</q>, <q>"e"</q>, RTX_AUTOINC)</td></tr>
<tr><th id="524">524</th><td><a class="macro" href="rtl.h.html#52" title="POST_DEC ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="POST_DEC" title='POST_DEC' data-ref="POST_DEC" data-ref-filename="POST_DEC">POST_DEC</dfn>, <q>"post_dec"</q>, <q>"e"</q>, RTX_AUTOINC)</td></tr>
<tr><th id="525">525</th><td><a class="macro" href="rtl.h.html#52" title="POST_INC ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="POST_INC" title='POST_INC' data-ref="POST_INC" data-ref-filename="POST_INC">POST_INC</dfn>, <q>"post_inc"</q>, <q>"e"</q>, RTX_AUTOINC)</td></tr>
<tr><th id="526">526</th><td></td></tr>
<tr><th id="527">527</th><td><i>/* These binary operations are used to represent generic address</i></td></tr>
<tr><th id="528">528</th><td><i>   side-effects in memory addresses, except for simple incrementation</i></td></tr>
<tr><th id="529">529</th><td><i>   or decrementation which use the above operations.  They are</i></td></tr>
<tr><th id="530">530</th><td><i>   created automatically by the life_analysis pass in flow.c.</i></td></tr>
<tr><th id="531">531</th><td><i>   The first operand is a REG which is used as the address.</i></td></tr>
<tr><th id="532">532</th><td><i>   The second operand is an expression that is assigned to the</i></td></tr>
<tr><th id="533">533</th><td><i>   register, either before (PRE_MODIFY) or after (POST_MODIFY)</i></td></tr>
<tr><th id="534">534</th><td><i>   evaluating the address.</i></td></tr>
<tr><th id="535">535</th><td><i>   Currently, the compiler can only handle second operands of the</i></td></tr>
<tr><th id="536">536</th><td><i>   form (plus (reg) (reg)) and (plus (reg) (const_int)), where</i></td></tr>
<tr><th id="537">537</th><td><i>   the first operand of the PLUS has to be the same register as</i></td></tr>
<tr><th id="538">538</th><td><i>   the first operand of the *_MODIFY.  */</i></td></tr>
<tr><th id="539">539</th><td><a class="macro" href="rtl.h.html#52" title="PRE_MODIFY ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="PRE_MODIFY" title='PRE_MODIFY' data-ref="PRE_MODIFY" data-ref-filename="PRE_MODIFY">PRE_MODIFY</dfn>, <q>"pre_modify"</q>, <q>"ee"</q>, RTX_AUTOINC)</td></tr>
<tr><th id="540">540</th><td><a class="macro" href="rtl.h.html#52" title="POST_MODIFY ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="POST_MODIFY" title='POST_MODIFY' data-ref="POST_MODIFY" data-ref-filename="POST_MODIFY">POST_MODIFY</dfn>, <q>"post_modify"</q>, <q>"ee"</q>, RTX_AUTOINC)</td></tr>
<tr><th id="541">541</th><td></td></tr>
<tr><th id="542">542</th><td><i>/* Comparison operations.  The ordered comparisons exist in two</i></td></tr>
<tr><th id="543">543</th><td><i>   flavors, signed and unsigned.  */</i></td></tr>
<tr><th id="544">544</th><td><a class="macro" href="rtl.h.html#52" title="NE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="NE" title='NE' data-ref="NE" data-ref-filename="NE">NE</dfn>, <q>"ne"</q>, <q>"ee"</q>, RTX_COMM_COMPARE)</td></tr>
<tr><th id="545">545</th><td><a class="macro" href="rtl.h.html#52" title="EQ ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="EQ" title='EQ' data-ref="EQ" data-ref-filename="EQ">EQ</dfn>, <q>"eq"</q>, <q>"ee"</q>, RTX_COMM_COMPARE)</td></tr>
<tr><th id="546">546</th><td><a class="macro" href="rtl.h.html#52" title="GE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="GE" title='GE' data-ref="GE" data-ref-filename="GE">GE</dfn>, <q>"ge"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="547">547</th><td><a class="macro" href="rtl.h.html#52" title="GT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="GT" title='GT' data-ref="GT" data-ref-filename="GT">GT</dfn>, <q>"gt"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="548">548</th><td><a class="macro" href="rtl.h.html#52" title="LE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="LE" title='LE' data-ref="LE" data-ref-filename="LE">LE</dfn>, <q>"le"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="549">549</th><td><a class="macro" href="rtl.h.html#52" title="LT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="LT" title='LT' data-ref="LT" data-ref-filename="LT">LT</dfn>, <q>"lt"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="550">550</th><td><a class="macro" href="rtl.h.html#52" title="GEU ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="GEU" title='GEU' data-ref="GEU" data-ref-filename="GEU">GEU</dfn>, <q>"geu"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="551">551</th><td><a class="macro" href="rtl.h.html#52" title="GTU ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="GTU" title='GTU' data-ref="GTU" data-ref-filename="GTU">GTU</dfn>, <q>"gtu"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="552">552</th><td><a class="macro" href="rtl.h.html#52" title="LEU ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="LEU" title='LEU' data-ref="LEU" data-ref-filename="LEU">LEU</dfn>, <q>"leu"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="553">553</th><td><a class="macro" href="rtl.h.html#52" title="LTU ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="LTU" title='LTU' data-ref="LTU" data-ref-filename="LTU">LTU</dfn>, <q>"ltu"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="554">554</th><td></td></tr>
<tr><th id="555">555</th><td><i>/* Additional floating point unordered comparison flavors.  */</i></td></tr>
<tr><th id="556">556</th><td><a class="macro" href="rtl.h.html#52" title="UNORDERED ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNORDERED" title='UNORDERED' data-ref="UNORDERED" data-ref-filename="UNORDERED">UNORDERED</dfn>, <q>"unordered"</q>, <q>"ee"</q>, RTX_COMM_COMPARE)</td></tr>
<tr><th id="557">557</th><td><a class="macro" href="rtl.h.html#52" title="ORDERED ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ORDERED" title='ORDERED' data-ref="ORDERED" data-ref-filename="ORDERED">ORDERED</dfn>, <q>"ordered"</q>, <q>"ee"</q>, RTX_COMM_COMPARE)</td></tr>
<tr><th id="558">558</th><td></td></tr>
<tr><th id="559">559</th><td><i>/* These are equivalent to unordered or ...  */</i></td></tr>
<tr><th id="560">560</th><td><a class="macro" href="rtl.h.html#52" title="UNEQ ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNEQ" title='UNEQ' data-ref="UNEQ" data-ref-filename="UNEQ">UNEQ</dfn>, <q>"uneq"</q>, <q>"ee"</q>, RTX_COMM_COMPARE)</td></tr>
<tr><th id="561">561</th><td><a class="macro" href="rtl.h.html#52" title="UNGE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNGE" title='UNGE' data-ref="UNGE" data-ref-filename="UNGE">UNGE</dfn>, <q>"unge"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="562">562</th><td><a class="macro" href="rtl.h.html#52" title="UNGT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNGT" title='UNGT' data-ref="UNGT" data-ref-filename="UNGT">UNGT</dfn>, <q>"ungt"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="563">563</th><td><a class="macro" href="rtl.h.html#52" title="UNLE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNLE" title='UNLE' data-ref="UNLE" data-ref-filename="UNLE">UNLE</dfn>, <q>"unle"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="564">564</th><td><a class="macro" href="rtl.h.html#52" title="UNLT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNLT" title='UNLT' data-ref="UNLT" data-ref-filename="UNLT">UNLT</dfn>, <q>"unlt"</q>, <q>"ee"</q>, RTX_COMPARE)</td></tr>
<tr><th id="565">565</th><td></td></tr>
<tr><th id="566">566</th><td><i>/* This is an ordered NE, ie !UNEQ, ie false for NaN.  */</i></td></tr>
<tr><th id="567">567</th><td><a class="macro" href="rtl.h.html#52" title="LTGT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="LTGT" title='LTGT' data-ref="LTGT" data-ref-filename="LTGT">LTGT</dfn>, <q>"ltgt"</q>, <q>"ee"</q>, RTX_COMM_COMPARE)</td></tr>
<tr><th id="568">568</th><td></td></tr>
<tr><th id="569">569</th><td><i>/* Represents the result of sign-extending the sole operand.</i></td></tr>
<tr><th id="570">570</th><td><i>   The machine modes of the operand and of the SIGN_EXTEND expression</i></td></tr>
<tr><th id="571">571</th><td><i>   determine how much sign-extension is going on.  */</i></td></tr>
<tr><th id="572">572</th><td><a class="macro" href="rtl.h.html#52" title="SIGN_EXTEND ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SIGN_EXTEND" title='SIGN_EXTEND' data-ref="SIGN_EXTEND" data-ref-filename="SIGN_EXTEND">SIGN_EXTEND</dfn>, <q>"sign_extend"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="573">573</th><td></td></tr>
<tr><th id="574">574</th><td><i>/* Similar for zero-extension (such as unsigned short to int).  */</i></td></tr>
<tr><th id="575">575</th><td><a class="macro" href="rtl.h.html#52" title="ZERO_EXTEND ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ZERO_EXTEND" title='ZERO_EXTEND' data-ref="ZERO_EXTEND" data-ref-filename="ZERO_EXTEND">ZERO_EXTEND</dfn>, <q>"zero_extend"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="576">576</th><td></td></tr>
<tr><th id="577">577</th><td><i>/* Similar but here the operand has a wider mode.  */</i></td></tr>
<tr><th id="578">578</th><td><a class="macro" href="rtl.h.html#52" title="TRUNCATE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="TRUNCATE" title='TRUNCATE' data-ref="TRUNCATE" data-ref-filename="TRUNCATE">TRUNCATE</dfn>, <q>"truncate"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="579">579</th><td></td></tr>
<tr><th id="580">580</th><td><i>/* Similar for extending floating-point values (such as SFmode to DFmode).  */</i></td></tr>
<tr><th id="581">581</th><td><a class="macro" href="rtl.h.html#52" title="FLOAT_EXTEND ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="FLOAT_EXTEND" title='FLOAT_EXTEND' data-ref="FLOAT_EXTEND" data-ref-filename="FLOAT_EXTEND">FLOAT_EXTEND</dfn>, <q>"float_extend"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="582">582</th><td><a class="macro" href="rtl.h.html#52" title="FLOAT_TRUNCATE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="FLOAT_TRUNCATE" title='FLOAT_TRUNCATE' data-ref="FLOAT_TRUNCATE" data-ref-filename="FLOAT_TRUNCATE">FLOAT_TRUNCATE</dfn>, <q>"float_truncate"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="583">583</th><td></td></tr>
<tr><th id="584">584</th><td><i>/* Conversion of fixed point operand to floating point value.  */</i></td></tr>
<tr><th id="585">585</th><td><a class="macro" href="rtl.h.html#52" title="FLOAT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="FLOAT" title='FLOAT' data-ref="FLOAT" data-ref-filename="FLOAT">FLOAT</dfn>, <q>"float"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="586">586</th><td></td></tr>
<tr><th id="587">587</th><td><i>/* With fixed-point machine mode:</i></td></tr>
<tr><th id="588">588</th><td><i>   Conversion of floating point operand to fixed point value.</i></td></tr>
<tr><th id="589">589</th><td><i>   Value is defined only when the operand's value is an integer.</i></td></tr>
<tr><th id="590">590</th><td><i>   With floating-point machine mode (and operand with same mode):</i></td></tr>
<tr><th id="591">591</th><td><i>   Operand is rounded toward zero to produce an integer value</i></td></tr>
<tr><th id="592">592</th><td><i>   represented in floating point.  */</i></td></tr>
<tr><th id="593">593</th><td><a class="macro" href="rtl.h.html#52" title="FIX ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="FIX" title='FIX' data-ref="FIX" data-ref-filename="FIX">FIX</dfn>, <q>"fix"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="594">594</th><td></td></tr>
<tr><th id="595">595</th><td><i>/* Conversion of unsigned fixed point operand to floating point value.  */</i></td></tr>
<tr><th id="596">596</th><td><a class="macro" href="rtl.h.html#52" title="UNSIGNED_FLOAT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNSIGNED_FLOAT" title='UNSIGNED_FLOAT' data-ref="UNSIGNED_FLOAT" data-ref-filename="UNSIGNED_FLOAT">UNSIGNED_FLOAT</dfn>, <q>"unsigned_float"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="597">597</th><td></td></tr>
<tr><th id="598">598</th><td><i>/* With fixed-point machine mode:</i></td></tr>
<tr><th id="599">599</th><td><i>   Conversion of floating point operand to *unsigned* fixed point value.</i></td></tr>
<tr><th id="600">600</th><td><i>   Value is defined only when the operand's value is an integer.  */</i></td></tr>
<tr><th id="601">601</th><td><a class="macro" href="rtl.h.html#52" title="UNSIGNED_FIX ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNSIGNED_FIX" title='UNSIGNED_FIX' data-ref="UNSIGNED_FIX" data-ref-filename="UNSIGNED_FIX">UNSIGNED_FIX</dfn>, <q>"unsigned_fix"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="602">602</th><td></td></tr>
<tr><th id="603">603</th><td><i>/* Conversions involving fractional fixed-point types without saturation,</i></td></tr>
<tr><th id="604">604</th><td><i>   including:</i></td></tr>
<tr><th id="605">605</th><td><i>     fractional to fractional (of different precision),</i></td></tr>
<tr><th id="606">606</th><td><i>     signed integer to fractional,</i></td></tr>
<tr><th id="607">607</th><td><i>     fractional to signed integer,</i></td></tr>
<tr><th id="608">608</th><td><i>     floating point to fractional,</i></td></tr>
<tr><th id="609">609</th><td><i>     fractional to floating point.</i></td></tr>
<tr><th id="610">610</th><td><i>   NOTE: fractional can be either signed or unsigned for conversions.  */</i></td></tr>
<tr><th id="611">611</th><td><a class="macro" href="rtl.h.html#52" title="FRACT_CONVERT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="FRACT_CONVERT" title='FRACT_CONVERT' data-ref="FRACT_CONVERT" data-ref-filename="FRACT_CONVERT">FRACT_CONVERT</dfn>, <q>"fract_convert"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="612">612</th><td></td></tr>
<tr><th id="613">613</th><td><i>/* Conversions involving fractional fixed-point types and unsigned integer</i></td></tr>
<tr><th id="614">614</th><td><i>   without saturation, including:</i></td></tr>
<tr><th id="615">615</th><td><i>     unsigned integer to fractional,</i></td></tr>
<tr><th id="616">616</th><td><i>     fractional to unsigned integer.</i></td></tr>
<tr><th id="617">617</th><td><i>   NOTE: fractional can be either signed or unsigned for conversions.  */</i></td></tr>
<tr><th id="618">618</th><td><a class="macro" href="rtl.h.html#52" title="UNSIGNED_FRACT_CONVERT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNSIGNED_FRACT_CONVERT" title='UNSIGNED_FRACT_CONVERT' data-ref="UNSIGNED_FRACT_CONVERT" data-ref-filename="UNSIGNED_FRACT_CONVERT">UNSIGNED_FRACT_CONVERT</dfn>, <q>"unsigned_fract_convert"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="619">619</th><td></td></tr>
<tr><th id="620">620</th><td><i>/* Conversions involving fractional fixed-point types with saturation,</i></td></tr>
<tr><th id="621">621</th><td><i>   including:</i></td></tr>
<tr><th id="622">622</th><td><i>     fractional to fractional (of different precision),</i></td></tr>
<tr><th id="623">623</th><td><i>     signed integer to fractional,</i></td></tr>
<tr><th id="624">624</th><td><i>     floating point to fractional.</i></td></tr>
<tr><th id="625">625</th><td><i>   NOTE: fractional can be either signed or unsigned for conversions.  */</i></td></tr>
<tr><th id="626">626</th><td><a class="macro" href="rtl.h.html#52" title="SAT_FRACT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SAT_FRACT" title='SAT_FRACT' data-ref="SAT_FRACT" data-ref-filename="SAT_FRACT">SAT_FRACT</dfn>, <q>"sat_fract"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="627">627</th><td></td></tr>
<tr><th id="628">628</th><td><i>/* Conversions involving fractional fixed-point types and unsigned integer</i></td></tr>
<tr><th id="629">629</th><td><i>   with saturation, including:</i></td></tr>
<tr><th id="630">630</th><td><i>     unsigned integer to fractional.</i></td></tr>
<tr><th id="631">631</th><td><i>   NOTE: fractional can be either signed or unsigned for conversions.  */</i></td></tr>
<tr><th id="632">632</th><td><a class="macro" href="rtl.h.html#52" title="UNSIGNED_SAT_FRACT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="UNSIGNED_SAT_FRACT" title='UNSIGNED_SAT_FRACT' data-ref="UNSIGNED_SAT_FRACT" data-ref-filename="UNSIGNED_SAT_FRACT">UNSIGNED_SAT_FRACT</dfn>, <q>"unsigned_sat_fract"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="633">633</th><td></td></tr>
<tr><th id="634">634</th><td><i>/* Absolute value */</i></td></tr>
<tr><th id="635">635</th><td><a class="macro" href="rtl.h.html#52" title="ABS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ABS" title='ABS' data-ref="ABS" data-ref-filename="ABS">ABS</dfn>, <q>"abs"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="636">636</th><td></td></tr>
<tr><th id="637">637</th><td><i>/* Square root */</i></td></tr>
<tr><th id="638">638</th><td><a class="macro" href="rtl.h.html#52" title="SQRT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SQRT" title='SQRT' data-ref="SQRT" data-ref-filename="SQRT">SQRT</dfn>, <q>"sqrt"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="639">639</th><td></td></tr>
<tr><th id="640">640</th><td><i>/* Swap bytes.  */</i></td></tr>
<tr><th id="641">641</th><td><a class="macro" href="rtl.h.html#52" title="BSWAP ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="BSWAP" title='BSWAP' data-ref="BSWAP" data-ref-filename="BSWAP">BSWAP</dfn>, <q>"bswap"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="642">642</th><td></td></tr>
<tr><th id="643">643</th><td><i>/* Find first bit that is set.</i></td></tr>
<tr><th id="644">644</th><td><i>   Value is 1 + number of trailing zeros in the arg.,</i></td></tr>
<tr><th id="645">645</th><td><i>   or 0 if arg is 0.  */</i></td></tr>
<tr><th id="646">646</th><td><a class="macro" href="rtl.h.html#52" title="FFS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="FFS" title='FFS' data-ref="FFS" data-ref-filename="FFS">FFS</dfn>, <q>"ffs"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="647">647</th><td></td></tr>
<tr><th id="648">648</th><td><i>/* Count number of leading redundant sign bits (number of leading</i></td></tr>
<tr><th id="649">649</th><td><i>   sign bits minus one).  */</i></td></tr>
<tr><th id="650">650</th><td><a class="macro" href="rtl.h.html#52" title="CLRSB ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CLRSB" title='CLRSB' data-ref="CLRSB" data-ref-filename="CLRSB">CLRSB</dfn>, <q>"clrsb"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="651">651</th><td></td></tr>
<tr><th id="652">652</th><td><i>/* Count leading zeros.  */</i></td></tr>
<tr><th id="653">653</th><td><a class="macro" href="rtl.h.html#52" title="CLZ ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CLZ" title='CLZ' data-ref="CLZ" data-ref-filename="CLZ">CLZ</dfn>, <q>"clz"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="654">654</th><td></td></tr>
<tr><th id="655">655</th><td><i>/* Count trailing zeros.  */</i></td></tr>
<tr><th id="656">656</th><td><a class="macro" href="rtl.h.html#52" title="CTZ ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="CTZ" title='CTZ' data-ref="CTZ" data-ref-filename="CTZ">CTZ</dfn>, <q>"ctz"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="657">657</th><td></td></tr>
<tr><th id="658">658</th><td><i>/* Population count (number of 1 bits).  */</i></td></tr>
<tr><th id="659">659</th><td><a class="macro" href="rtl.h.html#52" title="POPCOUNT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="POPCOUNT" title='POPCOUNT' data-ref="POPCOUNT" data-ref-filename="POPCOUNT">POPCOUNT</dfn>, <q>"popcount"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="660">660</th><td></td></tr>
<tr><th id="661">661</th><td><i>/* Population parity (number of 1 bits modulo 2).  */</i></td></tr>
<tr><th id="662">662</th><td><a class="macro" href="rtl.h.html#52" title="PARITY ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="PARITY" title='PARITY' data-ref="PARITY" data-ref-filename="PARITY">PARITY</dfn>, <q>"parity"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="663">663</th><td></td></tr>
<tr><th id="664">664</th><td><i>/* Reference to a signed bit-field of specified size and position.</i></td></tr>
<tr><th id="665">665</th><td><i>   Operand 0 is the memory unit (usually SImode or QImode) which</i></td></tr>
<tr><th id="666">666</th><td><i>   contains the field's first bit.  Operand 1 is the width, in bits.</i></td></tr>
<tr><th id="667">667</th><td><i>   Operand 2 is the number of bits in the memory unit before the</i></td></tr>
<tr><th id="668">668</th><td><i>   first bit of this field.</i></td></tr>
<tr><th id="669">669</th><td><i>   If BITS_BIG_ENDIAN is defined, the first bit is the msb and</i></td></tr>
<tr><th id="670">670</th><td><i>   operand 2 counts from the msb of the memory unit.</i></td></tr>
<tr><th id="671">671</th><td><i>   Otherwise, the first bit is the lsb and operand 2 counts from</i></td></tr>
<tr><th id="672">672</th><td><i>   the lsb of the memory unit.</i></td></tr>
<tr><th id="673">673</th><td><i>   This kind of expression can not appear as an lvalue in RTL.  */</i></td></tr>
<tr><th id="674">674</th><td><a class="macro" href="rtl.h.html#52" title="SIGN_EXTRACT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SIGN_EXTRACT" title='SIGN_EXTRACT' data-ref="SIGN_EXTRACT" data-ref-filename="SIGN_EXTRACT">SIGN_EXTRACT</dfn>, <q>"sign_extract"</q>, <q>"eee"</q>, RTX_BITFIELD_OPS)</td></tr>
<tr><th id="675">675</th><td></td></tr>
<tr><th id="676">676</th><td><i>/* Similar for unsigned bit-field.</i></td></tr>
<tr><th id="677">677</th><td><i>   But note!  This kind of expression _can_ appear as an lvalue.  */</i></td></tr>
<tr><th id="678">678</th><td><a class="macro" href="rtl.h.html#52" title="ZERO_EXTRACT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ZERO_EXTRACT" title='ZERO_EXTRACT' data-ref="ZERO_EXTRACT" data-ref-filename="ZERO_EXTRACT">ZERO_EXTRACT</dfn>, <q>"zero_extract"</q>, <q>"eee"</q>, RTX_BITFIELD_OPS)</td></tr>
<tr><th id="679">679</th><td></td></tr>
<tr><th id="680">680</th><td><i>/* For RISC machines.  These save memory when splitting insns.  */</i></td></tr>
<tr><th id="681">681</th><td></td></tr>
<tr><th id="682">682</th><td><i>/* HIGH are the high-order bits of a constant expression.  */</i></td></tr>
<tr><th id="683">683</th><td><a class="macro" href="rtl.h.html#52" title="HIGH ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="HIGH" title='HIGH' data-ref="HIGH" data-ref-filename="HIGH">HIGH</dfn>, <q>"high"</q>, <q>"e"</q>, RTX_CONST_OBJ)</td></tr>
<tr><th id="684">684</th><td></td></tr>
<tr><th id="685">685</th><td><i>/* LO_SUM is the sum of a register and the low-order bits</i></td></tr>
<tr><th id="686">686</th><td><i>   of a constant expression.  */</i></td></tr>
<tr><th id="687">687</th><td><a class="macro" href="rtl.h.html#52" title="LO_SUM ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="LO_SUM" title='LO_SUM' data-ref="LO_SUM" data-ref-filename="LO_SUM">LO_SUM</dfn>, <q>"lo_sum"</q>, <q>"ee"</q>, RTX_OBJ)</td></tr>
<tr><th id="688">688</th><td></td></tr>
<tr><th id="689">689</th><td><i>/* Describes a merge operation between two vector values.</i></td></tr>
<tr><th id="690">690</th><td><i>   Operands 0 and 1 are the vectors to be merged, operand 2 is a bitmask</i></td></tr>
<tr><th id="691">691</th><td><i>   that specifies where the parts of the result are taken from.  Set bits</i></td></tr>
<tr><th id="692">692</th><td><i>   indicate operand 0, clear bits indicate operand 1.  The parts are defined</i></td></tr>
<tr><th id="693">693</th><td><i>   by the mode of the vectors.  */</i></td></tr>
<tr><th id="694">694</th><td><a class="macro" href="rtl.h.html#52" title="VEC_MERGE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="VEC_MERGE" title='VEC_MERGE' data-ref="VEC_MERGE" data-ref-filename="VEC_MERGE">VEC_MERGE</dfn>, <q>"vec_merge"</q>, <q>"eee"</q>, RTX_TERNARY)</td></tr>
<tr><th id="695">695</th><td></td></tr>
<tr><th id="696">696</th><td><i>/* Describes an operation that selects parts of a vector.</i></td></tr>
<tr><th id="697">697</th><td><i>   Operands 0 is the source vector, operand 1 is a PARALLEL that contains</i></td></tr>
<tr><th id="698">698</th><td><i>   a CONST_INT for each of the subparts of the result vector, giving the</i></td></tr>
<tr><th id="699">699</th><td><i>   number of the source subpart that should be stored into it.  */</i></td></tr>
<tr><th id="700">700</th><td><a class="macro" href="rtl.h.html#52" title="VEC_SELECT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="VEC_SELECT" title='VEC_SELECT' data-ref="VEC_SELECT" data-ref-filename="VEC_SELECT">VEC_SELECT</dfn>, <q>"vec_select"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="701">701</th><td></td></tr>
<tr><th id="702">702</th><td><i>/* Describes a vector concat operation.  Operands 0 and 1 are the source</i></td></tr>
<tr><th id="703">703</th><td><i>   vectors, the result is a vector that is as long as operands 0 and 1</i></td></tr>
<tr><th id="704">704</th><td><i>   combined and is the concatenation of the two source vectors.  */</i></td></tr>
<tr><th id="705">705</th><td><a class="macro" href="rtl.h.html#52" title="VEC_CONCAT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="VEC_CONCAT" title='VEC_CONCAT' data-ref="VEC_CONCAT" data-ref-filename="VEC_CONCAT">VEC_CONCAT</dfn>, <q>"vec_concat"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="706">706</th><td></td></tr>
<tr><th id="707">707</th><td><i>/* Describes an operation that converts a small vector into a larger one by</i></td></tr>
<tr><th id="708">708</th><td><i>   duplicating the input values.  The output vector mode must have the same</i></td></tr>
<tr><th id="709">709</th><td><i>   submodes as the input vector mode, and the number of output parts must be</i></td></tr>
<tr><th id="710">710</th><td><i>   an integer multiple of the number of input parts.  */</i></td></tr>
<tr><th id="711">711</th><td><a class="macro" href="rtl.h.html#52" title="VEC_DUPLICATE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="VEC_DUPLICATE" title='VEC_DUPLICATE' data-ref="VEC_DUPLICATE" data-ref-filename="VEC_DUPLICATE">VEC_DUPLICATE</dfn>, <q>"vec_duplicate"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="712">712</th><td></td></tr>
<tr><th id="713">713</th><td><i>/* Addition with signed saturation */</i></td></tr>
<tr><th id="714">714</th><td><a class="macro" href="rtl.h.html#52" title="SS_PLUS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SS_PLUS" title='SS_PLUS' data-ref="SS_PLUS" data-ref-filename="SS_PLUS">SS_PLUS</dfn>, <q>"ss_plus"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="715">715</th><td></td></tr>
<tr><th id="716">716</th><td><i>/* Addition with unsigned saturation */</i></td></tr>
<tr><th id="717">717</th><td><a class="macro" href="rtl.h.html#52" title="US_PLUS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="US_PLUS" title='US_PLUS' data-ref="US_PLUS" data-ref-filename="US_PLUS">US_PLUS</dfn>, <q>"us_plus"</q>, <q>"ee"</q>, RTX_COMM_ARITH)</td></tr>
<tr><th id="718">718</th><td></td></tr>
<tr><th id="719">719</th><td><i>/* Operand 0 minus operand 1, with signed saturation.  */</i></td></tr>
<tr><th id="720">720</th><td><a class="macro" href="rtl.h.html#52" title="SS_MINUS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SS_MINUS" title='SS_MINUS' data-ref="SS_MINUS" data-ref-filename="SS_MINUS">SS_MINUS</dfn>, <q>"ss_minus"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="721">721</th><td></td></tr>
<tr><th id="722">722</th><td><i>/* Negation with signed saturation.  */</i></td></tr>
<tr><th id="723">723</th><td><a class="macro" href="rtl.h.html#52" title="SS_NEG ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SS_NEG" title='SS_NEG' data-ref="SS_NEG" data-ref-filename="SS_NEG">SS_NEG</dfn>, <q>"ss_neg"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="724">724</th><td><i>/* Negation with unsigned saturation.  */</i></td></tr>
<tr><th id="725">725</th><td><a class="macro" href="rtl.h.html#52" title="US_NEG ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="US_NEG" title='US_NEG' data-ref="US_NEG" data-ref-filename="US_NEG">US_NEG</dfn>, <q>"us_neg"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="726">726</th><td></td></tr>
<tr><th id="727">727</th><td><i>/* Absolute value with signed saturation.  */</i></td></tr>
<tr><th id="728">728</th><td><a class="macro" href="rtl.h.html#52" title="SS_ABS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SS_ABS" title='SS_ABS' data-ref="SS_ABS" data-ref-filename="SS_ABS">SS_ABS</dfn>, <q>"ss_abs"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="729">729</th><td></td></tr>
<tr><th id="730">730</th><td><i>/* Shift left with signed saturation.  */</i></td></tr>
<tr><th id="731">731</th><td><a class="macro" href="rtl.h.html#52" title="SS_ASHIFT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SS_ASHIFT" title='SS_ASHIFT' data-ref="SS_ASHIFT" data-ref-filename="SS_ASHIFT">SS_ASHIFT</dfn>, <q>"ss_ashift"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="732">732</th><td></td></tr>
<tr><th id="733">733</th><td><i>/* Shift left with unsigned saturation.  */</i></td></tr>
<tr><th id="734">734</th><td><a class="macro" href="rtl.h.html#52" title="US_ASHIFT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="US_ASHIFT" title='US_ASHIFT' data-ref="US_ASHIFT" data-ref-filename="US_ASHIFT">US_ASHIFT</dfn>, <q>"us_ashift"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="735">735</th><td></td></tr>
<tr><th id="736">736</th><td><i>/* Operand 0 minus operand 1, with unsigned saturation.  */</i></td></tr>
<tr><th id="737">737</th><td><a class="macro" href="rtl.h.html#52" title="US_MINUS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="US_MINUS" title='US_MINUS' data-ref="US_MINUS" data-ref-filename="US_MINUS">US_MINUS</dfn>, <q>"us_minus"</q>, <q>"ee"</q>, RTX_BIN_ARITH)</td></tr>
<tr><th id="738">738</th><td></td></tr>
<tr><th id="739">739</th><td><i>/* Signed saturating truncate.  */</i></td></tr>
<tr><th id="740">740</th><td><a class="macro" href="rtl.h.html#52" title="SS_TRUNCATE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SS_TRUNCATE" title='SS_TRUNCATE' data-ref="SS_TRUNCATE" data-ref-filename="SS_TRUNCATE">SS_TRUNCATE</dfn>, <q>"ss_truncate"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="741">741</th><td></td></tr>
<tr><th id="742">742</th><td><i>/* Unsigned saturating truncate.  */</i></td></tr>
<tr><th id="743">743</th><td><a class="macro" href="rtl.h.html#52" title="US_TRUNCATE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="US_TRUNCATE" title='US_TRUNCATE' data-ref="US_TRUNCATE" data-ref-filename="US_TRUNCATE">US_TRUNCATE</dfn>, <q>"us_truncate"</q>, <q>"e"</q>, RTX_UNARY)</td></tr>
<tr><th id="744">744</th><td></td></tr>
<tr><th id="745">745</th><td><i>/* Floating point multiply/add combined instruction.  */</i></td></tr>
<tr><th id="746">746</th><td><a class="macro" href="rtl.h.html#52" title="FMA ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="FMA" title='FMA' data-ref="FMA" data-ref-filename="FMA">FMA</dfn>, <q>"fma"</q>, <q>"eee"</q>, RTX_TERNARY)</td></tr>
<tr><th id="747">747</th><td></td></tr>
<tr><th id="748">748</th><td><i>/* Information about the variable and its location.  */</i></td></tr>
<tr><th id="749">749</th><td><a class="macro" href="rtl.h.html#52" title="VAR_LOCATION ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="VAR_LOCATION" title='VAR_LOCATION' data-ref="VAR_LOCATION" data-ref-filename="VAR_LOCATION">VAR_LOCATION</dfn>, <q>"var_location"</q>, <q>"te"</q>, RTX_EXTRA)</td></tr>
<tr><th id="750">750</th><td></td></tr>
<tr><th id="751">751</th><td><i>/* Used in VAR_LOCATION for a pointer to a decl that is no longer</i></td></tr>
<tr><th id="752">752</th><td><i>   addressable.  */</i></td></tr>
<tr><th id="753">753</th><td><a class="macro" href="rtl.h.html#52" title="DEBUG_IMPLICIT_PTR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEBUG_IMPLICIT_PTR" title='DEBUG_IMPLICIT_PTR' data-ref="DEBUG_IMPLICIT_PTR" data-ref-filename="DEBUG_IMPLICIT_PTR">DEBUG_IMPLICIT_PTR</dfn>, <q>"debug_implicit_ptr"</q>, <q>"t"</q>, RTX_OBJ)</td></tr>
<tr><th id="754">754</th><td></td></tr>
<tr><th id="755">755</th><td><i>/* Represents value that argument had on function entry.  The</i></td></tr>
<tr><th id="756">756</th><td><i>   single argument is the DECL_INCOMING_RTL of the corresponding</i></td></tr>
<tr><th id="757">757</th><td><i>   parameter.  */</i></td></tr>
<tr><th id="758">758</th><td><a class="macro" href="rtl.h.html#52" title="ENTRY_VALUE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ENTRY_VALUE" title='ENTRY_VALUE' data-ref="ENTRY_VALUE" data-ref-filename="ENTRY_VALUE">ENTRY_VALUE</dfn>, <q>"entry_value"</q>, <q>"0"</q>, RTX_OBJ)</td></tr>
<tr><th id="759">759</th><td></td></tr>
<tr><th id="760">760</th><td><i>/* Used in VAR_LOCATION for a reference to a parameter that has</i></td></tr>
<tr><th id="761">761</th><td><i>   been optimized away completely.  */</i></td></tr>
<tr><th id="762">762</th><td><a class="macro" href="rtl.h.html#52" title="DEBUG_PARAMETER_REF ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEBUG_PARAMETER_REF" title='DEBUG_PARAMETER_REF' data-ref="DEBUG_PARAMETER_REF" data-ref-filename="DEBUG_PARAMETER_REF">DEBUG_PARAMETER_REF</dfn>, <q>"debug_parameter_ref"</q>, <q>"t"</q>, RTX_OBJ)</td></tr>
<tr><th id="763">763</th><td></td></tr>
<tr><th id="764">764</th><td><i>/* All expressions from this point forward appear only in machine</i></td></tr>
<tr><th id="765">765</th><td><i>   descriptions.  */</i></td></tr>
<tr><th id="766">766</th><td><u>#<span data-ppcond="766">ifdef</span> <span class="macro" data-ref="_M/GENERATOR_FILE">GENERATOR_FILE</span></u></td></tr>
<tr><th id="767">767</th><td></td></tr>
<tr><th id="768">768</th><td><i>/* Pattern-matching operators:  */</i></td></tr>
<tr><th id="769">769</th><td></td></tr>
<tr><th id="770">770</th><td><i>/* Use the function named by the second arg (the string)</i></td></tr>
<tr><th id="771">771</th><td><i>   as a predicate; if matched, store the structure that was matched</i></td></tr>
<tr><th id="772">772</th><td><i>   in the operand table at index specified by the first arg (the integer).</i></td></tr>
<tr><th id="773">773</th><td><i>   If the second arg is the null string, the structure is just stored.</i></td></tr>
<tr><th id="774">774</th><td><i></i></td></tr>
<tr><th id="775">775</th><td><i>   A third string argument indicates to the register allocator restrictions</i></td></tr>
<tr><th id="776">776</th><td><i>   on where the operand can be allocated.</i></td></tr>
<tr><th id="777">777</th><td><i></i></td></tr>
<tr><th id="778">778</th><td><i>   If the target needs no restriction on any instruction this field should</i></td></tr>
<tr><th id="779">779</th><td><i>   be the null string.</i></td></tr>
<tr><th id="780">780</th><td><i></i></td></tr>
<tr><th id="781">781</th><td><i>   The string is prepended by:</i></td></tr>
<tr><th id="782">782</th><td><i>   '=' to indicate the operand is only written to.</i></td></tr>
<tr><th id="783">783</th><td><i>   '+' to indicate the operand is both read and written to.</i></td></tr>
<tr><th id="784">784</th><td><i></i></td></tr>
<tr><th id="785">785</th><td><i>   Each character in the string represents an allocable class for an operand.</i></td></tr>
<tr><th id="786">786</th><td><i>   'g' indicates the operand can be any valid class.</i></td></tr>
<tr><th id="787">787</th><td><i>   'i' indicates the operand can be immediate (in the instruction) data.</i></td></tr>
<tr><th id="788">788</th><td><i>   'r' indicates the operand can be in a register.</i></td></tr>
<tr><th id="789">789</th><td><i>   'm' indicates the operand can be in memory.</i></td></tr>
<tr><th id="790">790</th><td><i>   'o' a subset of the 'm' class.  Those memory addressing modes that</i></td></tr>
<tr><th id="791">791</th><td><i>       can be offset at compile time (have a constant added to them).</i></td></tr>
<tr><th id="792">792</th><td><i></i></td></tr>
<tr><th id="793">793</th><td><i>   Other characters indicate target dependent operand classes and</i></td></tr>
<tr><th id="794">794</th><td><i>   are described in each target's machine description.</i></td></tr>
<tr><th id="795">795</th><td><i></i></td></tr>
<tr><th id="796">796</th><td><i>   For instructions with more than one operand, sets of classes can be</i></td></tr>
<tr><th id="797">797</th><td><i>   separated by a comma to indicate the appropriate multi-operand constraints.</i></td></tr>
<tr><th id="798">798</th><td><i>   There must be a 1 to 1 correspondence between these sets of classes in</i></td></tr>
<tr><th id="799">799</th><td><i>   all operands for an instruction.</i></td></tr>
<tr><th id="800">800</th><td><i>   */</i></td></tr>
<tr><th id="801">801</th><td><a class="macro" href="rtl.h.html#52" title="MATCH_OPERAND ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MATCH_OPERAND" title='MATCH_OPERAND' data-ref="MATCH_OPERAND" data-ref-filename="MATCH_OPERAND">MATCH_OPERAND</dfn>, <q>"match_operand"</q>, <q>"iss"</q>, RTX_MATCH)</td></tr>
<tr><th id="802">802</th><td></td></tr>
<tr><th id="803">803</th><td><i>/* Match a SCRATCH or a register.  When used to generate rtl, a</i></td></tr>
<tr><th id="804">804</th><td><i>   SCRATCH is generated.  As for MATCH_OPERAND, the mode specifies</i></td></tr>
<tr><th id="805">805</th><td><i>   the desired mode and the first argument is the operand number.</i></td></tr>
<tr><th id="806">806</th><td><i>   The second argument is the constraint.  */</i></td></tr>
<tr><th id="807">807</th><td><a class="macro" href="rtl.h.html#52" title="MATCH_SCRATCH ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MATCH_SCRATCH" title='MATCH_SCRATCH' data-ref="MATCH_SCRATCH" data-ref-filename="MATCH_SCRATCH">MATCH_SCRATCH</dfn>, <q>"match_scratch"</q>, <q>"is"</q>, RTX_MATCH)</td></tr>
<tr><th id="808">808</th><td></td></tr>
<tr><th id="809">809</th><td><i>/* Apply a predicate, AND match recursively the operands of the rtx.</i></td></tr>
<tr><th id="810">810</th><td><i>   Operand 0 is the operand-number, as in match_operand.</i></td></tr>
<tr><th id="811">811</th><td><i>   Operand 1 is a predicate to apply (as a string, a function name).</i></td></tr>
<tr><th id="812">812</th><td><i>   Operand 2 is a vector of expressions, each of which must match</i></td></tr>
<tr><th id="813">813</th><td><i>   one subexpression of the rtx this construct is matching.  */</i></td></tr>
<tr><th id="814">814</th><td><a class="macro" href="rtl.h.html#52" title="MATCH_OPERATOR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MATCH_OPERATOR" title='MATCH_OPERATOR' data-ref="MATCH_OPERATOR" data-ref-filename="MATCH_OPERATOR">MATCH_OPERATOR</dfn>, <q>"match_operator"</q>, <q>"isE"</q>, RTX_MATCH)</td></tr>
<tr><th id="815">815</th><td></td></tr>
<tr><th id="816">816</th><td><i>/* Match a PARALLEL of arbitrary length.  The predicate is applied</i></td></tr>
<tr><th id="817">817</th><td><i>   to the PARALLEL and the initial expressions in the PARALLEL are matched.</i></td></tr>
<tr><th id="818">818</th><td><i>   Operand 0 is the operand-number, as in match_operand.</i></td></tr>
<tr><th id="819">819</th><td><i>   Operand 1 is a predicate to apply to the PARALLEL.</i></td></tr>
<tr><th id="820">820</th><td><i>   Operand 2 is a vector of expressions, each of which must match the</i></td></tr>
<tr><th id="821">821</th><td><i>   corresponding element in the PARALLEL.  */</i></td></tr>
<tr><th id="822">822</th><td><a class="macro" href="rtl.h.html#52" title="MATCH_PARALLEL ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MATCH_PARALLEL" title='MATCH_PARALLEL' data-ref="MATCH_PARALLEL" data-ref-filename="MATCH_PARALLEL">MATCH_PARALLEL</dfn>, <q>"match_parallel"</q>, <q>"isE"</q>, RTX_MATCH)</td></tr>
<tr><th id="823">823</th><td></td></tr>
<tr><th id="824">824</th><td><i>/* Match only something equal to what is stored in the operand table</i></td></tr>
<tr><th id="825">825</th><td><i>   at the index specified by the argument.  Use with MATCH_OPERAND.  */</i></td></tr>
<tr><th id="826">826</th><td><a class="macro" href="rtl.h.html#52" title="MATCH_DUP ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MATCH_DUP" title='MATCH_DUP' data-ref="MATCH_DUP" data-ref-filename="MATCH_DUP">MATCH_DUP</dfn>, <q>"match_dup"</q>, <q>"i"</q>, RTX_MATCH)</td></tr>
<tr><th id="827">827</th><td></td></tr>
<tr><th id="828">828</th><td><i>/* Match only something equal to what is stored in the operand table</i></td></tr>
<tr><th id="829">829</th><td><i>   at the index specified by the argument.  Use with MATCH_OPERATOR.  */</i></td></tr>
<tr><th id="830">830</th><td><a class="macro" href="rtl.h.html#52" title="MATCH_OP_DUP ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MATCH_OP_DUP" title='MATCH_OP_DUP' data-ref="MATCH_OP_DUP" data-ref-filename="MATCH_OP_DUP">MATCH_OP_DUP</dfn>, <q>"match_op_dup"</q>, <q>"iE"</q>, RTX_MATCH)</td></tr>
<tr><th id="831">831</th><td></td></tr>
<tr><th id="832">832</th><td><i>/* Match only something equal to what is stored in the operand table</i></td></tr>
<tr><th id="833">833</th><td><i>   at the index specified by the argument.  Use with MATCH_PARALLEL.  */</i></td></tr>
<tr><th id="834">834</th><td><a class="macro" href="rtl.h.html#52" title="MATCH_PAR_DUP ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MATCH_PAR_DUP" title='MATCH_PAR_DUP' data-ref="MATCH_PAR_DUP" data-ref-filename="MATCH_PAR_DUP">MATCH_PAR_DUP</dfn>, <q>"match_par_dup"</q>, <q>"iE"</q>, RTX_MATCH)</td></tr>
<tr><th id="835">835</th><td></td></tr>
<tr><th id="836">836</th><td><i>/* Appears only in define_predicate/define_special_predicate</i></td></tr>
<tr><th id="837">837</th><td><i>   expressions.  Evaluates true only if the operand has an RTX code</i></td></tr>
<tr><th id="838">838</th><td><i>   from the set given by the argument (a comma-separated list).  If the</i></td></tr>
<tr><th id="839">839</th><td><i>   second argument is present and nonempty, it is a sequence of digits</i></td></tr>
<tr><th id="840">840</th><td><i>   and/or letters which indicates the subexpression to test, using the</i></td></tr>
<tr><th id="841">841</th><td><i>   same syntax as genextract/genrecog's location strings: 0-9 for</i></td></tr>
<tr><th id="842">842</th><td><i>   XEXP (op, n), a-z for XVECEXP (op, 0, n); each character applies to</i></td></tr>
<tr><th id="843">843</th><td><i>   the result of the one before it.  */</i></td></tr>
<tr><th id="844">844</th><td><a class="macro" href="rtl.h.html#52" title="MATCH_CODE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MATCH_CODE" title='MATCH_CODE' data-ref="MATCH_CODE" data-ref-filename="MATCH_CODE">MATCH_CODE</dfn>, <q>"match_code"</q>, <q>"ss"</q>, RTX_MATCH)</td></tr>
<tr><th id="845">845</th><td></td></tr>
<tr><th id="846">846</th><td><i>/* Used to inject a C conditional expression into an .md file.  It can</i></td></tr>
<tr><th id="847">847</th><td><i>   appear in a predicate definition or an attribute expression.  */</i></td></tr>
<tr><th id="848">848</th><td><a class="macro" href="rtl.h.html#52" title="MATCH_TEST ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="MATCH_TEST" title='MATCH_TEST' data-ref="MATCH_TEST" data-ref-filename="MATCH_TEST">MATCH_TEST</dfn>, <q>"match_test"</q>, <q>"s"</q>, RTX_MATCH)</td></tr>
<tr><th id="849">849</th><td></td></tr>
<tr><th id="850">850</th><td><i>/* Insn (and related) definitions.  */</i></td></tr>
<tr><th id="851">851</th><td></td></tr>
<tr><th id="852">852</th><td><i>/* Definition of the pattern for one kind of instruction.</i></td></tr>
<tr><th id="853">853</th><td><i>   Operand:</i></td></tr>
<tr><th id="854">854</th><td><i>   0: names this instruction.</i></td></tr>
<tr><th id="855">855</th><td><i>      If the name is the null string, the instruction is in the</i></td></tr>
<tr><th id="856">856</th><td><i>      machine description just to be recognized, and will never be emitted by</i></td></tr>
<tr><th id="857">857</th><td><i>      the tree to rtl expander.</i></td></tr>
<tr><th id="858">858</th><td><i>   1: is the pattern.</i></td></tr>
<tr><th id="859">859</th><td><i>   2: is a string which is a C expression</i></td></tr>
<tr><th id="860">860</th><td><i>      giving an additional condition for recognizing this pattern.</i></td></tr>
<tr><th id="861">861</th><td><i>      A null string means no extra condition.</i></td></tr>
<tr><th id="862">862</th><td><i>   3: is the action to execute if this pattern is matched.</i></td></tr>
<tr><th id="863">863</th><td><i>      If this assembler code template starts with a * then it is a fragment of</i></td></tr>
<tr><th id="864">864</th><td><i>      C code to run to decide on a template to use.  Otherwise, it is the</i></td></tr>
<tr><th id="865">865</th><td><i>      template to use.</i></td></tr>
<tr><th id="866">866</th><td><i>   4: optionally, a vector of attributes for this insn.</i></td></tr>
<tr><th id="867">867</th><td><i>     */</i></td></tr>
<tr><th id="868">868</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_INSN ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_INSN" title='DEFINE_INSN' data-ref="DEFINE_INSN" data-ref-filename="DEFINE_INSN">DEFINE_INSN</dfn>, <q>"define_insn"</q>, <q>"sEsTV"</q>, RTX_EXTRA)</td></tr>
<tr><th id="869">869</th><td></td></tr>
<tr><th id="870">870</th><td><i>/* Definition of a peephole optimization.</i></td></tr>
<tr><th id="871">871</th><td><i>   1st operand: vector of insn patterns to match</i></td></tr>
<tr><th id="872">872</th><td><i>   2nd operand: C expression that must be true</i></td></tr>
<tr><th id="873">873</th><td><i>   3rd operand: template or C code to produce assembler output.</i></td></tr>
<tr><th id="874">874</th><td><i>   4: optionally, a vector of attributes for this insn.</i></td></tr>
<tr><th id="875">875</th><td><i></i></td></tr>
<tr><th id="876">876</th><td><i>   This form is deprecated; use define_peephole2 instead.  */</i></td></tr>
<tr><th id="877">877</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_PEEPHOLE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_PEEPHOLE" title='DEFINE_PEEPHOLE' data-ref="DEFINE_PEEPHOLE" data-ref-filename="DEFINE_PEEPHOLE">DEFINE_PEEPHOLE</dfn>, <q>"define_peephole"</q>, <q>"EsTV"</q>, RTX_EXTRA)</td></tr>
<tr><th id="878">878</th><td></td></tr>
<tr><th id="879">879</th><td><i>/* Definition of a split operation.</i></td></tr>
<tr><th id="880">880</th><td><i>   1st operand: insn pattern to match</i></td></tr>
<tr><th id="881">881</th><td><i>   2nd operand: C expression that must be true</i></td></tr>
<tr><th id="882">882</th><td><i>   3rd operand: vector of insn patterns to place into a SEQUENCE</i></td></tr>
<tr><th id="883">883</th><td><i>   4th operand: optionally, some C code to execute before generating the</i></td></tr>
<tr><th id="884">884</th><td><i>	insns.  This might, for example, create some RTX's and store them in</i></td></tr>
<tr><th id="885">885</th><td><i>	elements of `recog_data.operand' for use by the vector of</i></td></tr>
<tr><th id="886">886</th><td><i>	insn-patterns.</i></td></tr>
<tr><th id="887">887</th><td><i>	(`operands' is an alias here for `recog_data.operand').  */</i></td></tr>
<tr><th id="888">888</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_SPLIT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_SPLIT" title='DEFINE_SPLIT' data-ref="DEFINE_SPLIT" data-ref-filename="DEFINE_SPLIT">DEFINE_SPLIT</dfn>, <q>"define_split"</q>, <q>"EsES"</q>, RTX_EXTRA)</td></tr>
<tr><th id="889">889</th><td></td></tr>
<tr><th id="890">890</th><td><i>/* Definition of an insn and associated split.</i></td></tr>
<tr><th id="891">891</th><td><i>   This is the concatenation, with a few modifications, of a define_insn</i></td></tr>
<tr><th id="892">892</th><td><i>   and a define_split which share the same pattern.</i></td></tr>
<tr><th id="893">893</th><td><i>   Operand:</i></td></tr>
<tr><th id="894">894</th><td><i>   0: names this instruction.</i></td></tr>
<tr><th id="895">895</th><td><i>      If the name is the null string, the instruction is in the</i></td></tr>
<tr><th id="896">896</th><td><i>      machine description just to be recognized, and will never be emitted by</i></td></tr>
<tr><th id="897">897</th><td><i>      the tree to rtl expander.</i></td></tr>
<tr><th id="898">898</th><td><i>   1: is the pattern.</i></td></tr>
<tr><th id="899">899</th><td><i>   2: is a string which is a C expression</i></td></tr>
<tr><th id="900">900</th><td><i>      giving an additional condition for recognizing this pattern.</i></td></tr>
<tr><th id="901">901</th><td><i>      A null string means no extra condition.</i></td></tr>
<tr><th id="902">902</th><td><i>   3: is the action to execute if this pattern is matched.</i></td></tr>
<tr><th id="903">903</th><td><i>      If this assembler code template starts with a * then it is a fragment of</i></td></tr>
<tr><th id="904">904</th><td><i>      C code to run to decide on a template to use.  Otherwise, it is the</i></td></tr>
<tr><th id="905">905</th><td><i>      template to use.</i></td></tr>
<tr><th id="906">906</th><td><i>   4: C expression that must be true for split.  This may start with "&amp;&amp;"</i></td></tr>
<tr><th id="907">907</th><td><i>      in which case the split condition is the logical and of the insn</i></td></tr>
<tr><th id="908">908</th><td><i>      condition and what follows the "&amp;&amp;" of this operand.</i></td></tr>
<tr><th id="909">909</th><td><i>   5: vector of insn patterns to place into a SEQUENCE</i></td></tr>
<tr><th id="910">910</th><td><i>   6: optionally, some C code to execute before generating the</i></td></tr>
<tr><th id="911">911</th><td><i>	insns.  This might, for example, create some RTX's and store them in</i></td></tr>
<tr><th id="912">912</th><td><i>	elements of `recog_data.operand' for use by the vector of</i></td></tr>
<tr><th id="913">913</th><td><i>	insn-patterns.</i></td></tr>
<tr><th id="914">914</th><td><i>	(`operands' is an alias here for `recog_data.operand').</i></td></tr>
<tr><th id="915">915</th><td><i>   7: optionally, a vector of attributes for this insn.  */</i></td></tr>
<tr><th id="916">916</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_INSN_AND_SPLIT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_INSN_AND_SPLIT" title='DEFINE_INSN_AND_SPLIT' data-ref="DEFINE_INSN_AND_SPLIT" data-ref-filename="DEFINE_INSN_AND_SPLIT">DEFINE_INSN_AND_SPLIT</dfn>, <q>"define_insn_and_split"</q>, <q>"sEsTsESV"</q>, RTX_EXTRA)</td></tr>
<tr><th id="917">917</th><td></td></tr>
<tr><th id="918">918</th><td><i>/* Definition of an RTL peephole operation.</i></td></tr>
<tr><th id="919">919</th><td><i>   Follows the same arguments as define_split.  */</i></td></tr>
<tr><th id="920">920</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_PEEPHOLE2 ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_PEEPHOLE2" title='DEFINE_PEEPHOLE2' data-ref="DEFINE_PEEPHOLE2" data-ref-filename="DEFINE_PEEPHOLE2">DEFINE_PEEPHOLE2</dfn>, <q>"define_peephole2"</q>, <q>"EsES"</q>, RTX_EXTRA)</td></tr>
<tr><th id="921">921</th><td></td></tr>
<tr><th id="922">922</th><td><i>/* Define how to generate multiple insns for a standard insn name.</i></td></tr>
<tr><th id="923">923</th><td><i>   1st operand: the insn name.</i></td></tr>
<tr><th id="924">924</th><td><i>   2nd operand: vector of insn-patterns.</i></td></tr>
<tr><th id="925">925</th><td><i>	Use match_operand to substitute an element of `recog_data.operand'.</i></td></tr>
<tr><th id="926">926</th><td><i>   3rd operand: C expression that must be true for this to be available.</i></td></tr>
<tr><th id="927">927</th><td><i>	This may not test any operands.</i></td></tr>
<tr><th id="928">928</th><td><i>   4th operand: Extra C code to execute before generating the insns.</i></td></tr>
<tr><th id="929">929</th><td><i>	This might, for example, create some RTX's and store them in</i></td></tr>
<tr><th id="930">930</th><td><i>	elements of `recog_data.operand' for use by the vector of</i></td></tr>
<tr><th id="931">931</th><td><i>	insn-patterns.</i></td></tr>
<tr><th id="932">932</th><td><i>	(`operands' is an alias here for `recog_data.operand').</i></td></tr>
<tr><th id="933">933</th><td><i>   5th: optionally, a vector of attributes for this expand.  */</i></td></tr>
<tr><th id="934">934</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_EXPAND ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_EXPAND" title='DEFINE_EXPAND' data-ref="DEFINE_EXPAND" data-ref-filename="DEFINE_EXPAND">DEFINE_EXPAND</dfn>, <q>"define_expand"</q>, <q>"sEssV"</q>, RTX_EXTRA)</td></tr>
<tr><th id="935">935</th><td></td></tr>
<tr><th id="936">936</th><td><i>/* Define a requirement for delay slots.</i></td></tr>
<tr><th id="937">937</th><td><i>   1st operand: Condition involving insn attributes that, if true,</i></td></tr>
<tr><th id="938">938</th><td><i>	        indicates that the insn requires the number of delay slots</i></td></tr>
<tr><th id="939">939</th><td><i>		shown.</i></td></tr>
<tr><th id="940">940</th><td><i>   2nd operand: Vector whose length is the three times the number of delay</i></td></tr>
<tr><th id="941">941</th><td><i>		slots required.</i></td></tr>
<tr><th id="942">942</th><td><i>	        Each entry gives three conditions, each involving attributes.</i></td></tr>
<tr><th id="943">943</th><td><i>		The first must be true for an insn to occupy that delay slot</i></td></tr>
<tr><th id="944">944</th><td><i>		location.  The second is true for all insns that can be</i></td></tr>
<tr><th id="945">945</th><td><i>		annulled if the branch is true and the third is true for all</i></td></tr>
<tr><th id="946">946</th><td><i>		insns that can be annulled if the branch is false.</i></td></tr>
<tr><th id="947">947</th><td><i></i></td></tr>
<tr><th id="948">948</th><td><i>   Multiple DEFINE_DELAYs may be present.  They indicate differing</i></td></tr>
<tr><th id="949">949</th><td><i>   requirements for delay slots.  */</i></td></tr>
<tr><th id="950">950</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_DELAY ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_DELAY" title='DEFINE_DELAY' data-ref="DEFINE_DELAY" data-ref-filename="DEFINE_DELAY">DEFINE_DELAY</dfn>, <q>"define_delay"</q>, <q>"eE"</q>, RTX_EXTRA)</td></tr>
<tr><th id="951">951</th><td></td></tr>
<tr><th id="952">952</th><td><i>/* Define attribute computation for `asm' instructions.  */</i></td></tr>
<tr><th id="953">953</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_ASM_ATTRIBUTES ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_ASM_ATTRIBUTES" title='DEFINE_ASM_ATTRIBUTES' data-ref="DEFINE_ASM_ATTRIBUTES" data-ref-filename="DEFINE_ASM_ATTRIBUTES">DEFINE_ASM_ATTRIBUTES</dfn>, <q>"define_asm_attributes"</q>, <q>"V"</q>, RTX_EXTRA)</td></tr>
<tr><th id="954">954</th><td></td></tr>
<tr><th id="955">955</th><td><i>/* Definition of a conditional execution meta operation.  Automatically</i></td></tr>
<tr><th id="956">956</th><td><i>   generates new instances of DEFINE_INSN, selected by having attribute</i></td></tr>
<tr><th id="957">957</th><td><i>   "predicable" true.  The new pattern will contain a COND_EXEC and the</i></td></tr>
<tr><th id="958">958</th><td><i>   predicate at top-level.</i></td></tr>
<tr><th id="959">959</th><td><i></i></td></tr>
<tr><th id="960">960</th><td><i>   Operand:</i></td></tr>
<tr><th id="961">961</th><td><i>   0: The predicate pattern.  The top-level form should match a</i></td></tr>
<tr><th id="962">962</th><td><i>      relational operator.  Operands should have only one alternative.</i></td></tr>
<tr><th id="963">963</th><td><i>   1: A C expression giving an additional condition for recognizing</i></td></tr>
<tr><th id="964">964</th><td><i>      the generated pattern.</i></td></tr>
<tr><th id="965">965</th><td><i>   2: A template or C code to produce assembler output.</i></td></tr>
<tr><th id="966">966</th><td><i>   3: A vector of attributes to append to the resulting cond_exec insn.  */</i></td></tr>
<tr><th id="967">967</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_COND_EXEC ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_COND_EXEC" title='DEFINE_COND_EXEC' data-ref="DEFINE_COND_EXEC" data-ref-filename="DEFINE_COND_EXEC">DEFINE_COND_EXEC</dfn>, <q>"define_cond_exec"</q>, <q>"EssV"</q>, RTX_EXTRA)</td></tr>
<tr><th id="968">968</th><td></td></tr>
<tr><th id="969">969</th><td><i>/* Definition of an operand predicate.  The difference between</i></td></tr>
<tr><th id="970">970</th><td><i>   DEFINE_PREDICATE and DEFINE_SPECIAL_PREDICATE is that genrecog will</i></td></tr>
<tr><th id="971">971</th><td><i>   not warn about a match_operand with no mode if it has a predicate</i></td></tr>
<tr><th id="972">972</th><td><i>   defined with DEFINE_SPECIAL_PREDICATE.</i></td></tr>
<tr><th id="973">973</th><td><i></i></td></tr>
<tr><th id="974">974</th><td><i>   Operand:</i></td></tr>
<tr><th id="975">975</th><td><i>   0: The name of the predicate.</i></td></tr>
<tr><th id="976">976</th><td><i>   1: A boolean expression which computes whether or not the predicate</i></td></tr>
<tr><th id="977">977</th><td><i>      matches.  This expression can use IOR, AND, NOT, MATCH_OPERAND,</i></td></tr>
<tr><th id="978">978</th><td><i>      MATCH_CODE, and MATCH_TEST.  It must be specific enough that genrecog</i></td></tr>
<tr><th id="979">979</th><td><i>      can calculate the set of RTX codes that can possibly match.</i></td></tr>
<tr><th id="980">980</th><td><i>   2: A C function body which must return true for the predicate to match.</i></td></tr>
<tr><th id="981">981</th><td><i>      Optional.  Use this when the test is too complicated to fit into a</i></td></tr>
<tr><th id="982">982</th><td><i>      match_test expression.  */</i></td></tr>
<tr><th id="983">983</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_PREDICATE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_PREDICATE" title='DEFINE_PREDICATE' data-ref="DEFINE_PREDICATE" data-ref-filename="DEFINE_PREDICATE">DEFINE_PREDICATE</dfn>, <q>"define_predicate"</q>, <q>"ses"</q>, RTX_EXTRA)</td></tr>
<tr><th id="984">984</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_SPECIAL_PREDICATE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_SPECIAL_PREDICATE" title='DEFINE_SPECIAL_PREDICATE' data-ref="DEFINE_SPECIAL_PREDICATE" data-ref-filename="DEFINE_SPECIAL_PREDICATE">DEFINE_SPECIAL_PREDICATE</dfn>, <q>"define_special_predicate"</q>, <q>"ses"</q>, RTX_EXTRA)</td></tr>
<tr><th id="985">985</th><td></td></tr>
<tr><th id="986">986</th><td><i>/* Definition of a register operand constraint.  This simply maps the</i></td></tr>
<tr><th id="987">987</th><td><i>   constraint string to a register class.</i></td></tr>
<tr><th id="988">988</th><td><i></i></td></tr>
<tr><th id="989">989</th><td><i>   Operand:</i></td></tr>
<tr><th id="990">990</th><td><i>   0: The name of the constraint (often, but not always, a single letter).</i></td></tr>
<tr><th id="991">991</th><td><i>   1: A C expression which evaluates to the appropriate register class for</i></td></tr>
<tr><th id="992">992</th><td><i>      this constraint.  If this is not just a constant, it should look only</i></td></tr>
<tr><th id="993">993</th><td><i>      at -m switches and the like.</i></td></tr>
<tr><th id="994">994</th><td><i>   2: A docstring for this constraint, in Texinfo syntax; not currently</i></td></tr>
<tr><th id="995">995</th><td><i>      used, in future will be incorporated into the manual's list of</i></td></tr>
<tr><th id="996">996</th><td><i>      machine-specific operand constraints.  */</i></td></tr>
<tr><th id="997">997</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_REGISTER_CONSTRAINT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_REGISTER_CONSTRAINT" title='DEFINE_REGISTER_CONSTRAINT' data-ref="DEFINE_REGISTER_CONSTRAINT" data-ref-filename="DEFINE_REGISTER_CONSTRAINT">DEFINE_REGISTER_CONSTRAINT</dfn>, <q>"define_register_constraint"</q>, <q>"sss"</q>, RTX_EXTRA)</td></tr>
<tr><th id="998">998</th><td></td></tr>
<tr><th id="999">999</th><td><i>/* Definition of a non-register operand constraint.  These look at the</i></td></tr>
<tr><th id="1000">1000</th><td><i>   operand and decide whether it fits the constraint.</i></td></tr>
<tr><th id="1001">1001</th><td><i></i></td></tr>
<tr><th id="1002">1002</th><td><i>   DEFINE_CONSTRAINT gets no special treatment if it fails to match.</i></td></tr>
<tr><th id="1003">1003</th><td><i>   It is appropriate for constant-only constraints, and most others.</i></td></tr>
<tr><th id="1004">1004</th><td><i></i></td></tr>
<tr><th id="1005">1005</th><td><i>   DEFINE_MEMORY_CONSTRAINT tells reload that this constraint can be made</i></td></tr>
<tr><th id="1006">1006</th><td><i>   to match, if it doesn't already, by converting the operand to the form</i></td></tr>
<tr><th id="1007">1007</th><td><i>   (mem (reg X)) where X is a base register.  It is suitable for constraints</i></td></tr>
<tr><th id="1008">1008</th><td><i>   that describe a subset of all memory references.</i></td></tr>
<tr><th id="1009">1009</th><td><i></i></td></tr>
<tr><th id="1010">1010</th><td><i>   DEFINE_ADDRESS_CONSTRAINT tells reload that this constraint can be made</i></td></tr>
<tr><th id="1011">1011</th><td><i>   to match, if it doesn't already, by converting the operand to the form</i></td></tr>
<tr><th id="1012">1012</th><td><i>   (reg X) where X is a base register.  It is suitable for constraints that</i></td></tr>
<tr><th id="1013">1013</th><td><i>   describe a subset of all address references.</i></td></tr>
<tr><th id="1014">1014</th><td><i></i></td></tr>
<tr><th id="1015">1015</th><td><i>   When in doubt, use plain DEFINE_CONSTRAINT.</i></td></tr>
<tr><th id="1016">1016</th><td><i></i></td></tr>
<tr><th id="1017">1017</th><td><i>   Operand:</i></td></tr>
<tr><th id="1018">1018</th><td><i>   0: The name of the constraint (often, but not always, a single letter).</i></td></tr>
<tr><th id="1019">1019</th><td><i>   1: A docstring for this constraint, in Texinfo syntax; not currently</i></td></tr>
<tr><th id="1020">1020</th><td><i>      used, in future will be incorporated into the manual's list of</i></td></tr>
<tr><th id="1021">1021</th><td><i>      machine-specific operand constraints.</i></td></tr>
<tr><th id="1022">1022</th><td><i>   2: A boolean expression which computes whether or not the constraint</i></td></tr>
<tr><th id="1023">1023</th><td><i>      matches.  It should follow the same rules as a define_predicate</i></td></tr>
<tr><th id="1024">1024</th><td><i>      expression, including the bit about specifying the set of RTX codes</i></td></tr>
<tr><th id="1025">1025</th><td><i>      that could possibly match.  MATCH_TEST subexpressions may make use of</i></td></tr>
<tr><th id="1026">1026</th><td><i>      these variables:</i></td></tr>
<tr><th id="1027">1027</th><td><i>        `op'    - the RTL object defining the operand.</i></td></tr>
<tr><th id="1028">1028</th><td><i>        `mode'  - the mode of `op'.</i></td></tr>
<tr><th id="1029">1029</th><td><i>	`ival'  - INTVAL(op), if op is a CONST_INT.</i></td></tr>
<tr><th id="1030">1030</th><td><i>        `hval'  - CONST_DOUBLE_HIGH(op), if op is an integer CONST_DOUBLE.</i></td></tr>
<tr><th id="1031">1031</th><td><i>        `lval'  - CONST_DOUBLE_LOW(op), if op is an integer CONST_DOUBLE.</i></td></tr>
<tr><th id="1032">1032</th><td><i>        `rval'  - CONST_DOUBLE_REAL_VALUE(op), if op is a floating-point</i></td></tr>
<tr><th id="1033">1033</th><td><i>                  CONST_DOUBLE.</i></td></tr>
<tr><th id="1034">1034</th><td><i>      Do not use ival/hval/lval/rval if op is not the appropriate kind of</i></td></tr>
<tr><th id="1035">1035</th><td><i>      RTL object.  */</i></td></tr>
<tr><th id="1036">1036</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_CONSTRAINT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_CONSTRAINT" title='DEFINE_CONSTRAINT' data-ref="DEFINE_CONSTRAINT" data-ref-filename="DEFINE_CONSTRAINT">DEFINE_CONSTRAINT</dfn>, <q>"define_constraint"</q>, <q>"sse"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1037">1037</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_MEMORY_CONSTRAINT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_MEMORY_CONSTRAINT" title='DEFINE_MEMORY_CONSTRAINT' data-ref="DEFINE_MEMORY_CONSTRAINT" data-ref-filename="DEFINE_MEMORY_CONSTRAINT">DEFINE_MEMORY_CONSTRAINT</dfn>, <q>"define_memory_constraint"</q>, <q>"sse"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1038">1038</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_SPECIAL_MEMORY_CONSTRAINT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_SPECIAL_MEMORY_CONSTRAINT" title='DEFINE_SPECIAL_MEMORY_CONSTRAINT' data-ref="DEFINE_SPECIAL_MEMORY_CONSTRAINT" data-ref-filename="DEFINE_SPECIAL_MEMORY_CONSTRAINT">DEFINE_SPECIAL_MEMORY_CONSTRAINT</dfn>, <q>"define_special_memory_constraint"</q>, <q>"sse"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1039">1039</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_ADDRESS_CONSTRAINT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_ADDRESS_CONSTRAINT" title='DEFINE_ADDRESS_CONSTRAINT' data-ref="DEFINE_ADDRESS_CONSTRAINT" data-ref-filename="DEFINE_ADDRESS_CONSTRAINT">DEFINE_ADDRESS_CONSTRAINT</dfn>, <q>"define_address_constraint"</q>, <q>"sse"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1040">1040</th><td></td></tr>
<tr><th id="1041">1041</th><td></td></tr>
<tr><th id="1042">1042</th><td><i>/* Constructions for CPU pipeline description described by NDFAs.  */</i></td></tr>
<tr><th id="1043">1043</th><td></td></tr>
<tr><th id="1044">1044</th><td><i>/* (define_cpu_unit string [string]) describes cpu functional</i></td></tr>
<tr><th id="1045">1045</th><td><i>   units (separated by comma).</i></td></tr>
<tr><th id="1046">1046</th><td><i></i></td></tr>
<tr><th id="1047">1047</th><td><i>   1st operand: Names of cpu functional units.</i></td></tr>
<tr><th id="1048">1048</th><td><i>   2nd operand: Name of automaton (see comments for DEFINE_AUTOMATON).</i></td></tr>
<tr><th id="1049">1049</th><td><i></i></td></tr>
<tr><th id="1050">1050</th><td><i>   All define_reservations, define_cpu_units, and</i></td></tr>
<tr><th id="1051">1051</th><td><i>   define_query_cpu_units should have unique names which may not be</i></td></tr>
<tr><th id="1052">1052</th><td><i>   "nothing".  */</i></td></tr>
<tr><th id="1053">1053</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_CPU_UNIT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_CPU_UNIT" title='DEFINE_CPU_UNIT' data-ref="DEFINE_CPU_UNIT" data-ref-filename="DEFINE_CPU_UNIT">DEFINE_CPU_UNIT</dfn>, <q>"define_cpu_unit"</q>, <q>"sS"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1054">1054</th><td></td></tr>
<tr><th id="1055">1055</th><td><i>/* (define_query_cpu_unit string [string]) describes cpu functional</i></td></tr>
<tr><th id="1056">1056</th><td><i>   units analogously to define_cpu_unit.  The reservation of such</i></td></tr>
<tr><th id="1057">1057</th><td><i>   units can be queried for automaton state.  */</i></td></tr>
<tr><th id="1058">1058</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_QUERY_CPU_UNIT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_QUERY_CPU_UNIT" title='DEFINE_QUERY_CPU_UNIT' data-ref="DEFINE_QUERY_CPU_UNIT" data-ref-filename="DEFINE_QUERY_CPU_UNIT">DEFINE_QUERY_CPU_UNIT</dfn>, <q>"define_query_cpu_unit"</q>, <q>"sS"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1059">1059</th><td></td></tr>
<tr><th id="1060">1060</th><td><i>/* (exclusion_set string string) means that each CPU functional unit</i></td></tr>
<tr><th id="1061">1061</th><td><i>   in the first string can not be reserved simultaneously with any</i></td></tr>
<tr><th id="1062">1062</th><td><i>   unit whose name is in the second string and vise versa.  CPU units</i></td></tr>
<tr><th id="1063">1063</th><td><i>   in the string are separated by commas.  For example, it is useful</i></td></tr>
<tr><th id="1064">1064</th><td><i>   for description CPU with fully pipelined floating point functional</i></td></tr>
<tr><th id="1065">1065</th><td><i>   unit which can execute simultaneously only single floating point</i></td></tr>
<tr><th id="1066">1066</th><td><i>   insns or only double floating point insns.  All CPU functional</i></td></tr>
<tr><th id="1067">1067</th><td><i>   units in a set should belong to the same automaton.  */</i></td></tr>
<tr><th id="1068">1068</th><td><a class="macro" href="rtl.h.html#52" title="EXCLUSION_SET ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="EXCLUSION_SET" title='EXCLUSION_SET' data-ref="EXCLUSION_SET" data-ref-filename="EXCLUSION_SET">EXCLUSION_SET</dfn>, <q>"exclusion_set"</q>, <q>"ss"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1069">1069</th><td></td></tr>
<tr><th id="1070">1070</th><td><i>/* (presence_set string string) means that each CPU functional unit in</i></td></tr>
<tr><th id="1071">1071</th><td><i>   the first string can not be reserved unless at least one of pattern</i></td></tr>
<tr><th id="1072">1072</th><td><i>   of units whose names are in the second string is reserved.  This is</i></td></tr>
<tr><th id="1073">1073</th><td><i>   an asymmetric relation.  CPU units or unit patterns in the strings</i></td></tr>
<tr><th id="1074">1074</th><td><i>   are separated by commas.  Pattern is one unit name or unit names</i></td></tr>
<tr><th id="1075">1075</th><td><i>   separated by white-spaces.</i></td></tr>
<tr><th id="1076">1076</th><td><i></i></td></tr>
<tr><th id="1077">1077</th><td><i>   For example, it is useful for description that slot1 is reserved</i></td></tr>
<tr><th id="1078">1078</th><td><i>   after slot0 reservation for a VLIW processor.  We could describe it</i></td></tr>
<tr><th id="1079">1079</th><td><i>   by the following construction</i></td></tr>
<tr><th id="1080">1080</th><td><i></i></td></tr>
<tr><th id="1081">1081</th><td><i>      (presence_set "slot1" "slot0")</i></td></tr>
<tr><th id="1082">1082</th><td><i></i></td></tr>
<tr><th id="1083">1083</th><td><i>   Or slot1 is reserved only after slot0 and unit b0 reservation.  In</i></td></tr>
<tr><th id="1084">1084</th><td><i>   this case we could write</i></td></tr>
<tr><th id="1085">1085</th><td><i></i></td></tr>
<tr><th id="1086">1086</th><td><i>      (presence_set "slot1" "slot0 b0")</i></td></tr>
<tr><th id="1087">1087</th><td><i></i></td></tr>
<tr><th id="1088">1088</th><td><i>   All CPU functional units in a set should belong to the same</i></td></tr>
<tr><th id="1089">1089</th><td><i>   automaton.  */</i></td></tr>
<tr><th id="1090">1090</th><td><a class="macro" href="rtl.h.html#52" title="PRESENCE_SET ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="PRESENCE_SET" title='PRESENCE_SET' data-ref="PRESENCE_SET" data-ref-filename="PRESENCE_SET">PRESENCE_SET</dfn>, <q>"presence_set"</q>, <q>"ss"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1091">1091</th><td></td></tr>
<tr><th id="1092">1092</th><td><i>/* (final_presence_set string string) is analogous to `presence_set'.</i></td></tr>
<tr><th id="1093">1093</th><td><i>   The difference between them is when checking is done.  When an</i></td></tr>
<tr><th id="1094">1094</th><td><i>   instruction is issued in given automaton state reflecting all</i></td></tr>
<tr><th id="1095">1095</th><td><i>   current and planned unit reservations, the automaton state is</i></td></tr>
<tr><th id="1096">1096</th><td><i>   changed.  The first state is a source state, the second one is a</i></td></tr>
<tr><th id="1097">1097</th><td><i>   result state.  Checking for `presence_set' is done on the source</i></td></tr>
<tr><th id="1098">1098</th><td><i>   state reservation, checking for `final_presence_set' is done on the</i></td></tr>
<tr><th id="1099">1099</th><td><i>   result reservation.  This construction is useful to describe a</i></td></tr>
<tr><th id="1100">1100</th><td><i>   reservation which is actually two subsequent reservations.  For</i></td></tr>
<tr><th id="1101">1101</th><td><i>   example, if we use</i></td></tr>
<tr><th id="1102">1102</th><td><i></i></td></tr>
<tr><th id="1103">1103</th><td><i>      (presence_set "slot1" "slot0")</i></td></tr>
<tr><th id="1104">1104</th><td><i></i></td></tr>
<tr><th id="1105">1105</th><td><i>   the following insn will be never issued (because slot1 requires</i></td></tr>
<tr><th id="1106">1106</th><td><i>   slot0 which is absent in the source state).</i></td></tr>
<tr><th id="1107">1107</th><td><i></i></td></tr>
<tr><th id="1108">1108</th><td><i>      (define_reservation "insn_and_nop" "slot0 + slot1")</i></td></tr>
<tr><th id="1109">1109</th><td><i></i></td></tr>
<tr><th id="1110">1110</th><td><i>   but it can be issued if we use analogous `final_presence_set'.  */</i></td></tr>
<tr><th id="1111">1111</th><td><a class="macro" href="rtl.h.html#52" title="FINAL_PRESENCE_SET ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="FINAL_PRESENCE_SET" title='FINAL_PRESENCE_SET' data-ref="FINAL_PRESENCE_SET" data-ref-filename="FINAL_PRESENCE_SET">FINAL_PRESENCE_SET</dfn>, <q>"final_presence_set"</q>, <q>"ss"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1112">1112</th><td></td></tr>
<tr><th id="1113">1113</th><td><i>/* (absence_set string string) means that each CPU functional unit in</i></td></tr>
<tr><th id="1114">1114</th><td><i>   the first string can be reserved only if each pattern of units</i></td></tr>
<tr><th id="1115">1115</th><td><i>   whose names are in the second string is not reserved.  This is an</i></td></tr>
<tr><th id="1116">1116</th><td><i>   asymmetric relation (actually exclusion set is analogous to this</i></td></tr>
<tr><th id="1117">1117</th><td><i>   one but it is symmetric).  CPU units or unit patterns in the string</i></td></tr>
<tr><th id="1118">1118</th><td><i>   are separated by commas.  Pattern is one unit name or unit names</i></td></tr>
<tr><th id="1119">1119</th><td><i>   separated by white-spaces.</i></td></tr>
<tr><th id="1120">1120</th><td><i></i></td></tr>
<tr><th id="1121">1121</th><td><i>   For example, it is useful for description that slot0 can not be</i></td></tr>
<tr><th id="1122">1122</th><td><i>   reserved after slot1 or slot2 reservation for a VLIW processor.  We</i></td></tr>
<tr><th id="1123">1123</th><td><i>   could describe it by the following construction</i></td></tr>
<tr><th id="1124">1124</th><td><i></i></td></tr>
<tr><th id="1125">1125</th><td><i>      (absence_set "slot2" "slot0, slot1")</i></td></tr>
<tr><th id="1126">1126</th><td><i></i></td></tr>
<tr><th id="1127">1127</th><td><i>   Or slot2 can not be reserved if slot0 and unit b0 are reserved or</i></td></tr>
<tr><th id="1128">1128</th><td><i>   slot1 and unit b1 are reserved .  In this case we could write</i></td></tr>
<tr><th id="1129">1129</th><td><i></i></td></tr>
<tr><th id="1130">1130</th><td><i>      (absence_set "slot2" "slot0 b0, slot1 b1")</i></td></tr>
<tr><th id="1131">1131</th><td><i></i></td></tr>
<tr><th id="1132">1132</th><td><i>   All CPU functional units in a set should to belong the same</i></td></tr>
<tr><th id="1133">1133</th><td><i>   automaton.  */</i></td></tr>
<tr><th id="1134">1134</th><td><a class="macro" href="rtl.h.html#52" title="ABSENCE_SET ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ABSENCE_SET" title='ABSENCE_SET' data-ref="ABSENCE_SET" data-ref-filename="ABSENCE_SET">ABSENCE_SET</dfn>, <q>"absence_set"</q>, <q>"ss"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1135">1135</th><td></td></tr>
<tr><th id="1136">1136</th><td><i>/* (final_absence_set string string) is analogous to `absence_set' but</i></td></tr>
<tr><th id="1137">1137</th><td><i>   checking is done on the result (state) reservation.  See comments</i></td></tr>
<tr><th id="1138">1138</th><td><i>   for `final_presence_set'.  */</i></td></tr>
<tr><th id="1139">1139</th><td><a class="macro" href="rtl.h.html#52" title="FINAL_ABSENCE_SET ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="FINAL_ABSENCE_SET" title='FINAL_ABSENCE_SET' data-ref="FINAL_ABSENCE_SET" data-ref-filename="FINAL_ABSENCE_SET">FINAL_ABSENCE_SET</dfn>, <q>"final_absence_set"</q>, <q>"ss"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1140">1140</th><td></td></tr>
<tr><th id="1141">1141</th><td><i>/* (define_bypass number out_insn_names in_insn_names) names bypass</i></td></tr>
<tr><th id="1142">1142</th><td><i>   with given latency (the first number) from insns given by the first</i></td></tr>
<tr><th id="1143">1143</th><td><i>   string (see define_insn_reservation) into insns given by the second</i></td></tr>
<tr><th id="1144">1144</th><td><i>   string.  Insn names in the strings are separated by commas.  The</i></td></tr>
<tr><th id="1145">1145</th><td><i>   third operand is optional name of function which is additional</i></td></tr>
<tr><th id="1146">1146</th><td><i>   guard for the bypass.  The function will get the two insns as</i></td></tr>
<tr><th id="1147">1147</th><td><i>   parameters.  If the function returns zero the bypass will be</i></td></tr>
<tr><th id="1148">1148</th><td><i>   ignored for this case.  Additional guard is necessary to recognize</i></td></tr>
<tr><th id="1149">1149</th><td><i>   complicated bypasses, e.g. when consumer is load address.  If there</i></td></tr>
<tr><th id="1150">1150</th><td><i>   are more one bypass with the same output and input insns, the</i></td></tr>
<tr><th id="1151">1151</th><td><i>   chosen bypass is the first bypass with a guard in description whose</i></td></tr>
<tr><th id="1152">1152</th><td><i>   guard function returns nonzero.  If there is no such bypass, then</i></td></tr>
<tr><th id="1153">1153</th><td><i>   bypass without the guard function is chosen.  */</i></td></tr>
<tr><th id="1154">1154</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_BYPASS ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_BYPASS" title='DEFINE_BYPASS' data-ref="DEFINE_BYPASS" data-ref-filename="DEFINE_BYPASS">DEFINE_BYPASS</dfn>, <q>"define_bypass"</q>, <q>"issS"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1155">1155</th><td></td></tr>
<tr><th id="1156">1156</th><td><i>/* (define_automaton string) describes names of automata generated and</i></td></tr>
<tr><th id="1157">1157</th><td><i>   used for pipeline hazards recognition.  The names are separated by</i></td></tr>
<tr><th id="1158">1158</th><td><i>   comma.  Actually it is possibly to generate the single automaton</i></td></tr>
<tr><th id="1159">1159</th><td><i>   but unfortunately it can be very large.  If we use more one</i></td></tr>
<tr><th id="1160">1160</th><td><i>   automata, the summary size of the automata usually is less than the</i></td></tr>
<tr><th id="1161">1161</th><td><i>   single one.  The automaton name is used in define_cpu_unit and</i></td></tr>
<tr><th id="1162">1162</th><td><i>   define_query_cpu_unit.  All automata should have unique names.  */</i></td></tr>
<tr><th id="1163">1163</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_AUTOMATON ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_AUTOMATON" title='DEFINE_AUTOMATON' data-ref="DEFINE_AUTOMATON" data-ref-filename="DEFINE_AUTOMATON">DEFINE_AUTOMATON</dfn>, <q>"define_automaton"</q>, <q>"s"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1164">1164</th><td></td></tr>
<tr><th id="1165">1165</th><td><i>/* (automata_option string) describes option for generation of</i></td></tr>
<tr><th id="1166">1166</th><td><i>   automata.  Currently there are the following options:</i></td></tr>
<tr><th id="1167">1167</th><td><i></i></td></tr>
<tr><th id="1168">1168</th><td><i>   o "no-minimization" which makes no minimization of automata.  This</i></td></tr>
<tr><th id="1169">1169</th><td><i>     is only worth to do when we are debugging the description and</i></td></tr>
<tr><th id="1170">1170</th><td><i>     need to look more accurately at reservations of states.</i></td></tr>
<tr><th id="1171">1171</th><td><i></i></td></tr>
<tr><th id="1172">1172</th><td><i>   o "time" which means printing additional time statistics about</i></td></tr>
<tr><th id="1173">1173</th><td><i>      generation of automata.</i></td></tr>
<tr><th id="1174">1174</th><td><i></i></td></tr>
<tr><th id="1175">1175</th><td><i>   o "v" which means generation of file describing the result</i></td></tr>
<tr><th id="1176">1176</th><td><i>     automata.  The file has suffix `.dfa' and can be used for the</i></td></tr>
<tr><th id="1177">1177</th><td><i>     description verification and debugging.</i></td></tr>
<tr><th id="1178">1178</th><td><i></i></td></tr>
<tr><th id="1179">1179</th><td><i>   o "w" which means generation of warning instead of error for</i></td></tr>
<tr><th id="1180">1180</th><td><i>     non-critical errors.</i></td></tr>
<tr><th id="1181">1181</th><td><i></i></td></tr>
<tr><th id="1182">1182</th><td><i>   o "ndfa" which makes nondeterministic finite state automata.</i></td></tr>
<tr><th id="1183">1183</th><td><i></i></td></tr>
<tr><th id="1184">1184</th><td><i>   o "progress" which means output of a progress bar showing how many</i></td></tr>
<tr><th id="1185">1185</th><td><i>     states were generated so far for automaton being processed.  */</i></td></tr>
<tr><th id="1186">1186</th><td><a class="macro" href="rtl.h.html#52" title="AUTOMATA_OPTION ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="AUTOMATA_OPTION" title='AUTOMATA_OPTION' data-ref="AUTOMATA_OPTION" data-ref-filename="AUTOMATA_OPTION">AUTOMATA_OPTION</dfn>, <q>"automata_option"</q>, <q>"s"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1187">1187</th><td></td></tr>
<tr><th id="1188">1188</th><td><i>/* (define_reservation string string) names reservation (the first</i></td></tr>
<tr><th id="1189">1189</th><td><i>   string) of cpu functional units (the 2nd string).  Sometimes unit</i></td></tr>
<tr><th id="1190">1190</th><td><i>   reservations for different insns contain common parts.  In such</i></td></tr>
<tr><th id="1191">1191</th><td><i>   case, you can describe common part and use its name (the 1st</i></td></tr>
<tr><th id="1192">1192</th><td><i>   parameter) in regular expression in define_insn_reservation.  All</i></td></tr>
<tr><th id="1193">1193</th><td><i>   define_reservations, define_cpu_units, and define_query_cpu_units</i></td></tr>
<tr><th id="1194">1194</th><td><i>   should have unique names which may not be "nothing".  */</i></td></tr>
<tr><th id="1195">1195</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_RESERVATION ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_RESERVATION" title='DEFINE_RESERVATION' data-ref="DEFINE_RESERVATION" data-ref-filename="DEFINE_RESERVATION">DEFINE_RESERVATION</dfn>, <q>"define_reservation"</q>, <q>"ss"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1196">1196</th><td></td></tr>
<tr><th id="1197">1197</th><td><i>/* (define_insn_reservation name default_latency condition regexpr)</i></td></tr>
<tr><th id="1198">1198</th><td><i>   describes reservation of cpu functional units (the 3nd operand) for</i></td></tr>
<tr><th id="1199">1199</th><td><i>   instruction which is selected by the condition (the 2nd parameter).</i></td></tr>
<tr><th id="1200">1200</th><td><i>   The first parameter is used for output of debugging information.</i></td></tr>
<tr><th id="1201">1201</th><td><i>   The reservations are described by a regular expression according</i></td></tr>
<tr><th id="1202">1202</th><td><i>   the following syntax:</i></td></tr>
<tr><th id="1203">1203</th><td><i></i></td></tr>
<tr><th id="1204">1204</th><td><i>       regexp = regexp "," oneof</i></td></tr>
<tr><th id="1205">1205</th><td><i>              | oneof</i></td></tr>
<tr><th id="1206">1206</th><td><i></i></td></tr>
<tr><th id="1207">1207</th><td><i>       oneof = oneof "|" allof</i></td></tr>
<tr><th id="1208">1208</th><td><i>             | allof</i></td></tr>
<tr><th id="1209">1209</th><td><i></i></td></tr>
<tr><th id="1210">1210</th><td><i>       allof = allof "+" repeat</i></td></tr>
<tr><th id="1211">1211</th><td><i>             | repeat</i></td></tr>
<tr><th id="1212">1212</th><td><i></i></td></tr>
<tr><th id="1213">1213</th><td><i>       repeat = element "*" number</i></td></tr>
<tr><th id="1214">1214</th><td><i>              | element</i></td></tr>
<tr><th id="1215">1215</th><td><i></i></td></tr>
<tr><th id="1216">1216</th><td><i>       element = cpu_function_unit_name</i></td></tr>
<tr><th id="1217">1217</th><td><i>               | reservation_name</i></td></tr>
<tr><th id="1218">1218</th><td><i>               | result_name</i></td></tr>
<tr><th id="1219">1219</th><td><i>               | "nothing"</i></td></tr>
<tr><th id="1220">1220</th><td><i>               | "(" regexp ")"</i></td></tr>
<tr><th id="1221">1221</th><td><i></i></td></tr>
<tr><th id="1222">1222</th><td><i>       1. "," is used for describing start of the next cycle in</i></td></tr>
<tr><th id="1223">1223</th><td><i>       reservation.</i></td></tr>
<tr><th id="1224">1224</th><td><i></i></td></tr>
<tr><th id="1225">1225</th><td><i>       2. "|" is used for describing the reservation described by the</i></td></tr>
<tr><th id="1226">1226</th><td><i>       first regular expression *or* the reservation described by the</i></td></tr>
<tr><th id="1227">1227</th><td><i>       second regular expression *or* etc.</i></td></tr>
<tr><th id="1228">1228</th><td><i></i></td></tr>
<tr><th id="1229">1229</th><td><i>       3. "+" is used for describing the reservation described by the</i></td></tr>
<tr><th id="1230">1230</th><td><i>       first regular expression *and* the reservation described by the</i></td></tr>
<tr><th id="1231">1231</th><td><i>       second regular expression *and* etc.</i></td></tr>
<tr><th id="1232">1232</th><td><i></i></td></tr>
<tr><th id="1233">1233</th><td><i>       4. "*" is used for convenience and simply means sequence in</i></td></tr>
<tr><th id="1234">1234</th><td><i>       which the regular expression are repeated NUMBER times with</i></td></tr>
<tr><th id="1235">1235</th><td><i>       cycle advancing (see ",").</i></td></tr>
<tr><th id="1236">1236</th><td><i></i></td></tr>
<tr><th id="1237">1237</th><td><i>       5. cpu functional unit name which means its reservation.</i></td></tr>
<tr><th id="1238">1238</th><td><i></i></td></tr>
<tr><th id="1239">1239</th><td><i>       6. reservation name -- see define_reservation.</i></td></tr>
<tr><th id="1240">1240</th><td><i></i></td></tr>
<tr><th id="1241">1241</th><td><i>       7. string "nothing" means no units reservation.  */</i></td></tr>
<tr><th id="1242">1242</th><td></td></tr>
<tr><th id="1243">1243</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_INSN_RESERVATION ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_INSN_RESERVATION" title='DEFINE_INSN_RESERVATION' data-ref="DEFINE_INSN_RESERVATION" data-ref-filename="DEFINE_INSN_RESERVATION">DEFINE_INSN_RESERVATION</dfn>, <q>"define_insn_reservation"</q>, <q>"sies"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1244">1244</th><td></td></tr>
<tr><th id="1245">1245</th><td><i>/* Expressions used for insn attributes.  */</i></td></tr>
<tr><th id="1246">1246</th><td></td></tr>
<tr><th id="1247">1247</th><td><i>/* Definition of an insn attribute.</i></td></tr>
<tr><th id="1248">1248</th><td><i>   1st operand: name of the attribute</i></td></tr>
<tr><th id="1249">1249</th><td><i>   2nd operand: comma-separated list of possible attribute values</i></td></tr>
<tr><th id="1250">1250</th><td><i>   3rd operand: expression for the default value of the attribute.  */</i></td></tr>
<tr><th id="1251">1251</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_ATTR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_ATTR" title='DEFINE_ATTR' data-ref="DEFINE_ATTR" data-ref-filename="DEFINE_ATTR">DEFINE_ATTR</dfn>, <q>"define_attr"</q>, <q>"sse"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1252">1252</th><td></td></tr>
<tr><th id="1253">1253</th><td><i>/* Definition of an insn attribute that uses an existing enumerated type.</i></td></tr>
<tr><th id="1254">1254</th><td><i>   1st operand: name of the attribute</i></td></tr>
<tr><th id="1255">1255</th><td><i>   2nd operand: the name of the enumerated type</i></td></tr>
<tr><th id="1256">1256</th><td><i>   3rd operand: expression for the default value of the attribute.  */</i></td></tr>
<tr><th id="1257">1257</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_ENUM_ATTR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_ENUM_ATTR" title='DEFINE_ENUM_ATTR' data-ref="DEFINE_ENUM_ATTR" data-ref-filename="DEFINE_ENUM_ATTR">DEFINE_ENUM_ATTR</dfn>, <q>"define_enum_attr"</q>, <q>"sse"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1258">1258</th><td></td></tr>
<tr><th id="1259">1259</th><td><i>/* Marker for the name of an attribute.  */</i></td></tr>
<tr><th id="1260">1260</th><td><a class="macro" href="rtl.h.html#52" title="ATTR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="ATTR" title='ATTR' data-ref="ATTR" data-ref-filename="ATTR">ATTR</dfn>, <q>"attr"</q>, <q>"s"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1261">1261</th><td></td></tr>
<tr><th id="1262">1262</th><td><i>/* For use in the last (optional) operand of DEFINE_INSN or DEFINE_PEEPHOLE and</i></td></tr>
<tr><th id="1263">1263</th><td><i>   in DEFINE_ASM_INSN to specify an attribute to assign to insns matching that</i></td></tr>
<tr><th id="1264">1264</th><td><i>   pattern.</i></td></tr>
<tr><th id="1265">1265</th><td><i></i></td></tr>
<tr><th id="1266">1266</th><td><i>   (set_attr "name" "value") is equivalent to</i></td></tr>
<tr><th id="1267">1267</th><td><i>   (set (attr "name") (const_string "value"))  */</i></td></tr>
<tr><th id="1268">1268</th><td><a class="macro" href="rtl.h.html#52" title="SET_ATTR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SET_ATTR" title='SET_ATTR' data-ref="SET_ATTR" data-ref-filename="SET_ATTR">SET_ATTR</dfn>, <q>"set_attr"</q>, <q>"ss"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1269">1269</th><td></td></tr>
<tr><th id="1270">1270</th><td><i>/* In the last operand of DEFINE_INSN and DEFINE_PEEPHOLE, this can be used to</i></td></tr>
<tr><th id="1271">1271</th><td><i>   specify that attribute values are to be assigned according to the</i></td></tr>
<tr><th id="1272">1272</th><td><i>   alternative matched.</i></td></tr>
<tr><th id="1273">1273</th><td><i></i></td></tr>
<tr><th id="1274">1274</th><td><i>   The following three expressions are equivalent:</i></td></tr>
<tr><th id="1275">1275</th><td><i></i></td></tr>
<tr><th id="1276">1276</th><td><i>   (set (attr "att") (cond [(eq_attrq "alternative" "1") (const_string "a1")</i></td></tr>
<tr><th id="1277">1277</th><td><i>			    (eq_attrq "alternative" "2") (const_string "a2")]</i></td></tr>
<tr><th id="1278">1278</th><td><i>			   (const_string "a3")))</i></td></tr>
<tr><th id="1279">1279</th><td><i>   (set_attr_alternative "att" [(const_string "a1") (const_string "a2")</i></td></tr>
<tr><th id="1280">1280</th><td><i>				 (const_string "a3")])</i></td></tr>
<tr><th id="1281">1281</th><td><i>   (set_attr "att" "a1,a2,a3")</i></td></tr>
<tr><th id="1282">1282</th><td><i> */</i></td></tr>
<tr><th id="1283">1283</th><td><a class="macro" href="rtl.h.html#52" title="SET_ATTR_ALTERNATIVE ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="SET_ATTR_ALTERNATIVE" title='SET_ATTR_ALTERNATIVE' data-ref="SET_ATTR_ALTERNATIVE" data-ref-filename="SET_ATTR_ALTERNATIVE">SET_ATTR_ALTERNATIVE</dfn>, <q>"set_attr_alternative"</q>, <q>"sE"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1284">1284</th><td></td></tr>
<tr><th id="1285">1285</th><td><i>/* A conditional expression true if the value of the specified attribute of</i></td></tr>
<tr><th id="1286">1286</th><td><i>   the current insn equals the specified value.  The first operand is the</i></td></tr>
<tr><th id="1287">1287</th><td><i>   attribute name and the second is the comparison value.  */</i></td></tr>
<tr><th id="1288">1288</th><td><a class="macro" href="rtl.h.html#52" title="EQ_ATTR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="EQ_ATTR" title='EQ_ATTR' data-ref="EQ_ATTR" data-ref-filename="EQ_ATTR">EQ_ATTR</dfn>, <q>"eq_attr"</q>, <q>"ss"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1289">1289</th><td></td></tr>
<tr><th id="1290">1290</th><td><i>/* A special case of the above representing a set of alternatives.  The first</i></td></tr>
<tr><th id="1291">1291</th><td><i>   operand is bitmap of the set, the second one is the default value.  */</i></td></tr>
<tr><th id="1292">1292</th><td><a class="macro" href="rtl.h.html#52" title="EQ_ATTR_ALT ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="EQ_ATTR_ALT" title='EQ_ATTR_ALT' data-ref="EQ_ATTR_ALT" data-ref-filename="EQ_ATTR_ALT">EQ_ATTR_ALT</dfn>, <q>"eq_attr_alt"</q>, <q>"ii"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1293">1293</th><td></td></tr>
<tr><th id="1294">1294</th><td><i>/* A conditional expression which is true if the specified flag is</i></td></tr>
<tr><th id="1295">1295</th><td><i>   true for the insn being scheduled in reorg.</i></td></tr>
<tr><th id="1296">1296</th><td><i></i></td></tr>
<tr><th id="1297">1297</th><td><i>   genattr.c defines the following flags which can be tested by</i></td></tr>
<tr><th id="1298">1298</th><td><i>   (attr_flag "foo") expressions in eligible_for_delay: forward, backward.  */</i></td></tr>
<tr><th id="1299">1299</th><td></td></tr>
<tr><th id="1300">1300</th><td><a class="macro" href="rtl.h.html#52" title="ATTR_FLAG ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a> (<dfn class="enum" id="ATTR_FLAG" title='ATTR_FLAG' data-ref="ATTR_FLAG" data-ref-filename="ATTR_FLAG">ATTR_FLAG</dfn>, <q>"attr_flag"</q>, <q>"s"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1301">1301</th><td></td></tr>
<tr><th id="1302">1302</th><td><i>/* General conditional. The first operand is a vector composed of pairs of</i></td></tr>
<tr><th id="1303">1303</th><td><i>   expressions.  The first element of each pair is evaluated, in turn.</i></td></tr>
<tr><th id="1304">1304</th><td><i>   The value of the conditional is the second expression of the first pair</i></td></tr>
<tr><th id="1305">1305</th><td><i>   whose first expression evaluates nonzero.  If none of the expressions is</i></td></tr>
<tr><th id="1306">1306</th><td><i>   true, the second operand will be used as the value of the conditional.  */</i></td></tr>
<tr><th id="1307">1307</th><td><a class="macro" href="rtl.h.html#52" title="COND ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="COND" title='COND' data-ref="COND" data-ref-filename="COND">COND</dfn>, <q>"cond"</q>, <q>"Ee"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1308">1308</th><td></td></tr>
<tr><th id="1309">1309</th><td><i>/* Definition of a pattern substitution meta operation on a DEFINE_EXPAND</i></td></tr>
<tr><th id="1310">1310</th><td><i>   or a DEFINE_INSN.  Automatically generates new instances of DEFINE_INSNs</i></td></tr>
<tr><th id="1311">1311</th><td><i>   that match the substitution pattern.</i></td></tr>
<tr><th id="1312">1312</th><td><i></i></td></tr>
<tr><th id="1313">1313</th><td><i>   Operand:</i></td></tr>
<tr><th id="1314">1314</th><td><i>   0: The name of the substitition template.</i></td></tr>
<tr><th id="1315">1315</th><td><i>   1: Input template to match to see if a substitution is applicable.</i></td></tr>
<tr><th id="1316">1316</th><td><i>   2: A C expression giving an additional condition for the generated</i></td></tr>
<tr><th id="1317">1317</th><td><i>      new define_expand or define_insn.</i></td></tr>
<tr><th id="1318">1318</th><td><i>   3: Output tempalate to generate via substitution.</i></td></tr>
<tr><th id="1319">1319</th><td><i></i></td></tr>
<tr><th id="1320">1320</th><td><i>   Within a DEFINE_SUBST template, the meaning of some RTL expressions is</i></td></tr>
<tr><th id="1321">1321</th><td><i>   different from their usual interpretation: a MATCH_OPERAND matches any</i></td></tr>
<tr><th id="1322">1322</th><td><i>   expression tree with matching machine mode or with VOIDmode.  Likewise,</i></td></tr>
<tr><th id="1323">1323</th><td><i>   MATCH_OP_DUP and MATCH_DUP match more liberally in a DEFINE_SUBST than</i></td></tr>
<tr><th id="1324">1324</th><td><i>   in other RTL expressions.  MATCH_OPERATOR matches all common operators</i></td></tr>
<tr><th id="1325">1325</th><td><i>   but also UNSPEC, UNSPEC_VOLATILE, and MATCH_OPERATORS from the input</i></td></tr>
<tr><th id="1326">1326</th><td><i>   DEFINE_EXPAND or DEFINE_INSN.  */</i></td></tr>
<tr><th id="1327">1327</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_SUBST ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_SUBST" title='DEFINE_SUBST' data-ref="DEFINE_SUBST" data-ref-filename="DEFINE_SUBST">DEFINE_SUBST</dfn>, <q>"define_subst"</q>, <q>"sEsE"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1328">1328</th><td></td></tr>
<tr><th id="1329">1329</th><td><i>/* Substitution attribute to apply a DEFINE_SUBST to a pattern.</i></td></tr>
<tr><th id="1330">1330</th><td><i></i></td></tr>
<tr><th id="1331">1331</th><td><i>   Operand:</i></td></tr>
<tr><th id="1332">1332</th><td><i>   0: The name of the subst-attribute.</i></td></tr>
<tr><th id="1333">1333</th><td><i>   1: The name of the DEFINE_SUBST to be applied for this attribute.</i></td></tr>
<tr><th id="1334">1334</th><td><i>   2: String to substitute for the subst-attribute name in the pattern</i></td></tr>
<tr><th id="1335">1335</th><td><i>      name, for the case that the DEFINE_SUBST is not applied (i.e. the</i></td></tr>
<tr><th id="1336">1336</th><td><i>      unmodified version of the pattern).</i></td></tr>
<tr><th id="1337">1337</th><td><i>   3: String to substitute for the subst-attribute name in the pattern</i></td></tr>
<tr><th id="1338">1338</th><td><i>      name, for the case that the DEFINE_SUBST is applied to the patten.</i></td></tr>
<tr><th id="1339">1339</th><td><i>      </i></td></tr>
<tr><th id="1340">1340</th><td><i>   The use of DEFINE_SUBST and DEFINE_SUBST_ATTR is explained in the</i></td></tr>
<tr><th id="1341">1341</th><td><i>   GCC internals manual, under "RTL Templates Transformations".  */</i></td></tr>
<tr><th id="1342">1342</th><td><a class="macro" href="rtl.h.html#52" title="DEFINE_SUBST_ATTR ," data-ref="_M/DEF_RTL_EXPR">DEF_RTL_EXPR</a>(<dfn class="enum" id="DEFINE_SUBST_ATTR" title='DEFINE_SUBST_ATTR' data-ref="DEFINE_SUBST_ATTR" data-ref-filename="DEFINE_SUBST_ATTR">DEFINE_SUBST_ATTR</dfn>, <q>"define_subst_attr"</q>, <q>"ssss"</q>, RTX_EXTRA)</td></tr>
<tr><th id="1343">1343</th><td></td></tr>
<tr><th id="1344">1344</th><td><u>#<span data-ppcond="766">endif</span> /* GENERATOR_FILE */</u></td></tr>
<tr><th id="1345">1345</th><td></td></tr>
<tr><th id="1346">1346</th><td><i>/*</i></td></tr>
<tr><th id="1347">1347</th><td><i>Local variables:</i></td></tr>
<tr><th id="1348">1348</th><td><i>mode:c</i></td></tr>
<tr><th id="1349">1349</th><td><i>End:</i></td></tr>
<tr><th id="1350">1350</th><td><i>*/</i></td></tr>
<tr><th id="1351">1351</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='genattr-common.c.html'>netbsd/external/gpl3/gcc/dist/gcc/genattr-common.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
