<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>btree.h source code [netbsd/lib/libc/db/btree/btree.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="_binternal,_bleaf,_btmeta,_btree,_cursor,_epg,_epgno,_page,_rinternal,_rleaf "/>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/lib/libc/db/btree/btree.h'; var root_path = '../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>netbsd</a>/<a href='../../..'>lib</a>/<a href='../..'>libc</a>/<a href='..'>db</a>/<a href='./'>btree</a>/<a href='btree.h.html'>btree.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*	$NetBSD: btree.h,v 1.17 2013/09/04 13:03:22 ryoon Exp $	*/</i></td></tr>
<tr><th id="2">2</th><td></td></tr>
<tr><th id="3">3</th><td><i>/*-</i></td></tr>
<tr><th id="4">4</th><td><i> * Copyright (c) 1991, 1993, 1994</i></td></tr>
<tr><th id="5">5</th><td><i> *	The Regents of the University of California.  All rights reserved.</i></td></tr>
<tr><th id="6">6</th><td><i> *</i></td></tr>
<tr><th id="7">7</th><td><i> * This code is derived from software contributed to Berkeley by</i></td></tr>
<tr><th id="8">8</th><td><i> * Mike Olson.</i></td></tr>
<tr><th id="9">9</th><td><i> *</i></td></tr>
<tr><th id="10">10</th><td><i> * Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="11">11</th><td><i> * modification, are permitted provided that the following conditions</i></td></tr>
<tr><th id="12">12</th><td><i> * are met:</i></td></tr>
<tr><th id="13">13</th><td><i> * 1. Redistributions of source code must retain the above copyright</i></td></tr>
<tr><th id="14">14</th><td><i> *    notice, this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="15">15</th><td><i> * 2. Redistributions in binary form must reproduce the above copyright</i></td></tr>
<tr><th id="16">16</th><td><i> *    notice, this list of conditions and the following disclaimer in the</i></td></tr>
<tr><th id="17">17</th><td><i> *    documentation and/or other materials provided with the distribution.</i></td></tr>
<tr><th id="18">18</th><td><i> * 3. Neither the name of the University nor the names of its contributors</i></td></tr>
<tr><th id="19">19</th><td><i> *    may be used to endorse or promote products derived from this software</i></td></tr>
<tr><th id="20">20</th><td><i> *    without specific prior written permission.</i></td></tr>
<tr><th id="21">21</th><td><i> *</i></td></tr>
<tr><th id="22">22</th><td><i> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</i></td></tr>
<tr><th id="23">23</th><td><i> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</i></td></tr>
<tr><th id="24">24</th><td><i> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</i></td></tr>
<tr><th id="25">25</th><td><i> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</i></td></tr>
<tr><th id="26">26</th><td><i> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</i></td></tr>
<tr><th id="27">27</th><td><i> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</i></td></tr>
<tr><th id="28">28</th><td><i> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</i></td></tr>
<tr><th id="29">29</th><td><i> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</i></td></tr>
<tr><th id="30">30</th><td><i> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</i></td></tr>
<tr><th id="31">31</th><td><i> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</i></td></tr>
<tr><th id="32">32</th><td><i> * SUCH DAMAGE.</i></td></tr>
<tr><th id="33">33</th><td><i> *</i></td></tr>
<tr><th id="34">34</th><td><i> *	@(#)btree.h	8.11 (Berkeley) 8/17/94</i></td></tr>
<tr><th id="35">35</th><td><i> */</i></td></tr>
<tr><th id="36">36</th><td></td></tr>
<tr><th id="37">37</th><td><u>#<span data-ppcond="37">if</span> HAVE_NBTOOL_CONFIG_H</u></td></tr>
<tr><th id="38">38</th><td><u>#include "nbtool_config.h"</u></td></tr>
<tr><th id="39">39</th><td><u>#<span data-ppcond="37">endif</span></u></td></tr>
<tr><th id="40">40</th><td></td></tr>
<tr><th id="41">41</th><td><i>/* Macros to set/clear/test flags. */</i></td></tr>
<tr><th id="42">42</th><td><u>#define	<dfn class="macro" id="_M/F_SET" data-ref="_M/F_SET">F_SET</dfn>(p, f)	(p)-&gt;flags |= (f)</u></td></tr>
<tr><th id="43">43</th><td><u>#define	<dfn class="macro" id="_M/F_CLR" data-ref="_M/F_CLR">F_CLR</dfn>(p, f)	(p)-&gt;flags &amp;= ~(f)</u></td></tr>
<tr><th id="44">44</th><td><u>#define	<dfn class="macro" id="_M/F_ISSET" data-ref="_M/F_ISSET">F_ISSET</dfn>(p, f)	((p)-&gt;flags &amp; (f))</u></td></tr>
<tr><th id="45">45</th><td></td></tr>
<tr><th id="46">46</th><td><u>#include <a href="../../../../objdir.amd64/destdir.amd64/usr/include/mpool.h.html">&lt;mpool.h&gt;</a></u></td></tr>
<tr><th id="47">47</th><td></td></tr>
<tr><th id="48">48</th><td><u>#define	<dfn class="macro" id="_M/DEFMINKEYPAGE" data-ref="_M/DEFMINKEYPAGE">DEFMINKEYPAGE</dfn>	(2)		/* Minimum keys per page */</u></td></tr>
<tr><th id="49">49</th><td><u>#define	<dfn class="macro" id="_M/MINCACHE" data-ref="_M/MINCACHE">MINCACHE</dfn>	(5)		/* Minimum cached pages */</u></td></tr>
<tr><th id="50">50</th><td><u>#define	<dfn class="macro" id="_M/MINPSIZE" data-ref="_M/MINPSIZE">MINPSIZE</dfn>	(512)		/* Minimum page size */</u></td></tr>
<tr><th id="51">51</th><td></td></tr>
<tr><th id="52">52</th><td><i>/*</i></td></tr>
<tr><th id="53">53</th><td><i> * Page 0 of a btree file contains a copy of the meta-data.  This page is also</i></td></tr>
<tr><th id="54">54</th><td><i> * used as an out-of-band page, i.e. page pointers that point to nowhere point</i></td></tr>
<tr><th id="55">55</th><td><i> * to page 0.  Page 1 is the root of the btree.</i></td></tr>
<tr><th id="56">56</th><td><i> */</i></td></tr>
<tr><th id="57">57</th><td><u>#define	<dfn class="macro" id="_M/P_INVALID" data-ref="_M/P_INVALID">P_INVALID</dfn>	 0		/* Invalid tree page number. */</u></td></tr>
<tr><th id="58">58</th><td><u>#define	<dfn class="macro" id="_M/P_META" data-ref="_M/P_META">P_META</dfn>		 0		/* Tree metadata page number. */</u></td></tr>
<tr><th id="59">59</th><td><u>#define	<dfn class="macro" id="_M/P_ROOT" data-ref="_M/P_ROOT">P_ROOT</dfn>		 1		/* Tree root page number. */</u></td></tr>
<tr><th id="60">60</th><td></td></tr>
<tr><th id="61">61</th><td><i>/*</i></td></tr>
<tr><th id="62">62</th><td><i> * There are five page layouts in the btree: btree internal pages (BINTERNAL),</i></td></tr>
<tr><th id="63">63</th><td><i> * btree leaf pages (BLEAF), recno internal pages (RINTERNAL), recno leaf pages</i></td></tr>
<tr><th id="64">64</th><td><i> * (RLEAF) and overflow pages.  All five page types have a page header (PAGE).</i></td></tr>
<tr><th id="65">65</th><td><i> * This implementation requires that values within structures NOT be padded.</i></td></tr>
<tr><th id="66">66</th><td><i> * (ANSI C permits random padding.)  If your compiler pads randomly you'll have</i></td></tr>
<tr><th id="67">67</th><td><i> * to do some work to get this package to run.</i></td></tr>
<tr><th id="68">68</th><td><i> */</i></td></tr>
<tr><th id="69">69</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_page" title='_page' data-ref="_page" data-ref-filename="_page"><a class="type" href="#_page" title='_page' data-ref="_page" data-ref-filename="_page">_page</a></dfn> {</td></tr>
<tr><th id="70">70</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>	<dfn class="decl field" id="_page::pgno" title='_page::pgno' data-ref="_page::pgno" data-ref-filename="_page..pgno">pgno</dfn>;			<i>/* this page's page number */</i></td></tr>
<tr><th id="71">71</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>	<dfn class="decl field" id="_page::prevpg" title='_page::prevpg' data-ref="_page::prevpg" data-ref-filename="_page..prevpg">prevpg</dfn>;			<i>/* left sibling */</i></td></tr>
<tr><th id="72">72</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>	<dfn class="decl field" id="_page::nextpg" title='_page::nextpg' data-ref="_page::nextpg" data-ref-filename="_page..nextpg">nextpg</dfn>;			<i>/* right sibling */</i></td></tr>
<tr><th id="73">73</th><td></td></tr>
<tr><th id="74">74</th><td><u>#define	<dfn class="macro" id="_M/P_BINTERNAL" data-ref="_M/P_BINTERNAL">P_BINTERNAL</dfn>	0x01		/* btree internal page */</u></td></tr>
<tr><th id="75">75</th><td><u>#define	<dfn class="macro" id="_M/P_BLEAF" data-ref="_M/P_BLEAF">P_BLEAF</dfn>		0x02		/* leaf page */</u></td></tr>
<tr><th id="76">76</th><td><u>#define	<dfn class="macro" id="_M/P_OVERFLOW" data-ref="_M/P_OVERFLOW">P_OVERFLOW</dfn>	0x04		/* overflow page */</u></td></tr>
<tr><th id="77">77</th><td><u>#define	<dfn class="macro" id="_M/P_RINTERNAL" data-ref="_M/P_RINTERNAL">P_RINTERNAL</dfn>	0x08		/* recno internal page */</u></td></tr>
<tr><th id="78">78</th><td><u>#define	<dfn class="macro" id="_M/P_RLEAF" data-ref="_M/P_RLEAF">P_RLEAF</dfn>		0x10		/* leaf page */</u></td></tr>
<tr><th id="79">79</th><td><u>#define <dfn class="macro" id="_M/P_TYPE" data-ref="_M/P_TYPE">P_TYPE</dfn>		0x1f		/* type mask */</u></td></tr>
<tr><th id="80">80</th><td><u>#define	<dfn class="macro" id="_M/P_PRESERVE" data-ref="_M/P_PRESERVE">P_PRESERVE</dfn>	0x20		/* never delete this chain of pages */</u></td></tr>
<tr><th id="81">81</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="_page::flags" title='_page::flags' data-ref="_page::flags" data-ref-filename="_page..flags">flags</dfn>;</td></tr>
<tr><th id="82">82</th><td></td></tr>
<tr><th id="83">83</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>	<dfn class="decl field" id="_page::lower" title='_page::lower' data-ref="_page::lower" data-ref-filename="_page..lower">lower</dfn>;			<i>/* lower bound of free space on page */</i></td></tr>
<tr><th id="84">84</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>	<dfn class="decl field" id="_page::upper" title='_page::upper' data-ref="_page::upper" data-ref-filename="_page..upper">upper</dfn>;			<i>/* upper bound of free space on page */</i></td></tr>
<tr><th id="85">85</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>	<dfn class="decl field" id="_page::linp" title='_page::linp' data-ref="_page::linp" data-ref-filename="_page..linp">linp</dfn>[<var>1</var>];		<i>/* indx_t-aligned VAR. LENGTH DATA */</i></td></tr>
<tr><th id="86">86</th><td>} <dfn class="typedef" id="PAGE" title='PAGE' data-type='struct _page' data-ref="PAGE" data-ref-filename="PAGE">PAGE</dfn>;</td></tr>
<tr><th id="87">87</th><td></td></tr>
<tr><th id="88">88</th><td><i>/* First and next index. */</i></td></tr>
<tr><th id="89">89</th><td><u>#define	<dfn class="macro" id="_M/BTDATAOFF" data-ref="_M/BTDATAOFF">BTDATAOFF</dfn>							\</u></td></tr>
<tr><th id="90">90</th><td><u>	(sizeof(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>) + sizeof(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>) + sizeof(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>) +		\</u></td></tr>
<tr><th id="91">91</th><td><u>	    sizeof(<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>) + sizeof(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>) + sizeof(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>))</u></td></tr>
<tr><th id="92">92</th><td></td></tr>
<tr><th id="93">93</th><td><u>#define	<dfn class="macro" id="_M/_NEXTINDEX" data-ref="_M/_NEXTINDEX">_NEXTINDEX</dfn>(p) (((p)-&gt;<a class="ref field" href="#_page::lower" title='_page::lower' data-ref="_page::lower" data-ref-filename="_page..lower">lower</a> - BTDATAOFF) / sizeof(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>))</u></td></tr>
<tr><th id="94">94</th><td><u>#<span data-ppcond="94">ifdef</span> <span class="macro" data-ref="_M/_DIAGNOSTIC">_DIAGNOSTIC</span></u></td></tr>
<tr><th id="95">95</th><td><em>static</em> <b>__inline</b> <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a></td></tr>
<tr><th id="96">96</th><td><dfn class="decl def fn" id="NEXTINDEX" title='NEXTINDEX' data-ref="NEXTINDEX" data-ref-filename="NEXTINDEX">NEXTINDEX</dfn>(<em>const</em> <a class="typedef" href="#PAGE" title='PAGE' data-type='struct _page' data-ref="PAGE" data-ref-filename="PAGE">PAGE</a> *<dfn class="local col1 decl" id="1p" title='p' data-type='const PAGE *' data-ref="1p" data-ref-filename="1p">p</dfn>) {</td></tr>
<tr><th id="97">97</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="local col2 decl" id="2x" title='x' data-type='size_t' data-ref="2x" data-ref-filename="2x">x</dfn> = <a class="macro" href="#93" title="(((p)-&gt;lower - (sizeof(pgno_t) + sizeof(pgno_t) + sizeof(pgno_t) + sizeof(uint32_t) + sizeof(indx_t) + sizeof(indx_t))) / sizeof(indx_t))" data-ref="_M/_NEXTINDEX">_NEXTINDEX</a>(<a class="local col1 ref" href="#1p" title='p' data-ref="1p" data-ref-filename="1p">p</a>);</td></tr>
<tr><th id="98">98</th><td>	<a class="macro" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#234" title="(((( ((indx_t)((1ULL &lt;&lt; (sizeof(indx_t) * 8 - 1)))) + (indx_t)1 &lt; (indx_t)1) ? ( (!((x) &gt; 0) &amp;&amp; ((x) != 0)) ? ((intmax_t)((x) + __zeroll()) &gt;= (intmax_t)((indx_t)((1ULL &lt;&lt; (sizeof(indx_t) * 8 - 1))))) : ((intmax_t)((x) + __zeroll()) &gt;= (intmax_t)0 &amp;&amp; (intmax_t)((x) + __zeroll()) &lt;= (intmax_t)((indx_t)~((1ULL &lt;&lt; (sizeof(indx_t) * 8 - 1)))))) : ( !(!((x) &gt; 0) &amp;&amp; ((x) != 0)) &amp;&amp; (uintmax_t)((x) + __zeroull()) &lt;= (uintmax_t)((indx_t)~0ULL)))) ? (void)0 : __diagassert13(&quot;/___NETBSD_SRC___/objdir.amd64/compat/amd64/i386/lib/libc/../../../../../../lib/libc/db/btree/btree.h&quot;, 98, __func__, &quot;__type_fit(indx_t, x)&quot;))" data-ref="_M/_DBFIT">_DBFIT</a>(<a class="local col2 ref" href="#2x" title='x' data-ref="2x" data-ref-filename="2x">x</a>, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>);</td></tr>
<tr><th id="99">99</th><td>	<b>return</b> (<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>)<a class="local col2 ref" href="#2x" title='x' data-ref="2x" data-ref-filename="2x">x</a>;</td></tr>
<tr><th id="100">100</th><td>}</td></tr>
<tr><th id="101">101</th><td><u>#<span data-ppcond="94">else</span></u></td></tr>
<tr><th id="102">102</th><td><u>#define	NEXTINDEX(p) (indx_t)_NEXTINDEX(p)</u></td></tr>
<tr><th id="103">103</th><td><u>#<span data-ppcond="94">endif</span></u></td></tr>
<tr><th id="104">104</th><td></td></tr>
<tr><th id="105">105</th><td><i>/*</i></td></tr>
<tr><th id="106">106</th><td><i> * For pages other than overflow pages, there is an array of offsets into the</i></td></tr>
<tr><th id="107">107</th><td><i> * rest of the page immediately following the page header.  Each offset is to</i></td></tr>
<tr><th id="108">108</th><td><i> * an item which is unique to the type of page.  The h_lower offset is just</i></td></tr>
<tr><th id="109">109</th><td><i> * past the last filled-in index.  The h_upper offset is the first item on the</i></td></tr>
<tr><th id="110">110</th><td><i> * page.  Offsets are from the beginning of the page.</i></td></tr>
<tr><th id="111">111</th><td><i> *</i></td></tr>
<tr><th id="112">112</th><td><i> * If an item is too big to store on a single page, a flag is set and the item</i></td></tr>
<tr><th id="113">113</th><td><i> * is a { page, size } pair such that the page is the first page of an overflow</i></td></tr>
<tr><th id="114">114</th><td><i> * chain with size bytes of item.  Overflow pages are simply bytes without any</i></td></tr>
<tr><th id="115">115</th><td><i> * external structure.</i></td></tr>
<tr><th id="116">116</th><td><i> *</i></td></tr>
<tr><th id="117">117</th><td><i> * The page number and size fields in the items are pgno_t-aligned so they can</i></td></tr>
<tr><th id="118">118</th><td><i> * be manipulated without copying.  (This presumes that 32 bit items can be</i></td></tr>
<tr><th id="119">119</th><td><i> * manipulated on this system.)</i></td></tr>
<tr><th id="120">120</th><td><i> */</i></td></tr>
<tr><th id="121">121</th><td><u>#define	<dfn class="macro" id="_M/BTLALIGN" data-ref="_M/BTLALIGN">BTLALIGN</dfn>(n)	(((n) + sizeof(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>) - 1) &amp; ~(sizeof(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>) - 1))</u></td></tr>
<tr><th id="122">122</th><td><u>#define	<dfn class="macro" id="_M/NOVFLSIZE" data-ref="_M/NOVFLSIZE">NOVFLSIZE</dfn>	(sizeof(pgno_t) + sizeof(uint32_t))</u></td></tr>
<tr><th id="123">123</th><td></td></tr>
<tr><th id="124">124</th><td><i>/*</i></td></tr>
<tr><th id="125">125</th><td><i> * For the btree internal pages, the item is a key.  BINTERNALs are {key, pgno}</i></td></tr>
<tr><th id="126">126</th><td><i> * pairs, such that the key compares less than or equal to all of the records</i></td></tr>
<tr><th id="127">127</th><td><i> * on that page.  For a tree without duplicate keys, an internal page with two</i></td></tr>
<tr><th id="128">128</th><td><i> * consecutive keys, a and b, will have all records greater than or equal to a</i></td></tr>
<tr><th id="129">129</th><td><i> * and less than b stored on the page associated with a.  Duplicate keys are</i></td></tr>
<tr><th id="130">130</th><td><i> * somewhat special and can cause duplicate internal and leaf page records and</i></td></tr>
<tr><th id="131">131</th><td><i> * some minor modifications of the above rule.</i></td></tr>
<tr><th id="132">132</th><td><i> */</i></td></tr>
<tr><th id="133">133</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_binternal" title='_binternal' data-ref="_binternal" data-ref-filename="_binternal"><a class="type" href="#_binternal" title='_binternal' data-ref="_binternal" data-ref-filename="_binternal">_binternal</a></dfn> {</td></tr>
<tr><th id="134">134</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="_binternal::ksize" title='_binternal::ksize' data-ref="_binternal::ksize" data-ref-filename="_binternal..ksize">ksize</dfn>;			<i>/* key size */</i></td></tr>
<tr><th id="135">135</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>	<dfn class="decl field" id="_binternal::pgno" title='_binternal::pgno' data-ref="_binternal::pgno" data-ref-filename="_binternal..pgno">pgno</dfn>;			<i>/* page number stored on */</i></td></tr>
<tr><th id="136">136</th><td><u>#define	<dfn class="macro" id="_M/P_BIGDATA" data-ref="_M/P_BIGDATA">P_BIGDATA</dfn>	0x01		/* overflow data */</u></td></tr>
<tr><th id="137">137</th><td><u>#define	<dfn class="macro" id="_M/P_BIGKEY" data-ref="_M/P_BIGKEY">P_BIGKEY</dfn>	0x02		/* overflow key */</u></td></tr>
<tr><th id="138">138</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a>	<dfn class="decl field" id="_binternal::flags" title='_binternal::flags' data-ref="_binternal::flags" data-ref-filename="_binternal..flags">flags</dfn>;</td></tr>
<tr><th id="139">139</th><td>	<em>char</em>	<dfn class="decl field" id="_binternal::bytes" title='_binternal::bytes' data-ref="_binternal::bytes" data-ref-filename="_binternal..bytes">bytes</dfn>[<var>1</var>];		<i>/* data */</i></td></tr>
<tr><th id="140">140</th><td>} <dfn class="typedef" id="BINTERNAL" title='BINTERNAL' data-type='struct _binternal' data-ref="BINTERNAL" data-ref-filename="BINTERNAL">BINTERNAL</dfn>;</td></tr>
<tr><th id="141">141</th><td></td></tr>
<tr><th id="142">142</th><td><i>/* Get the page's BINTERNAL structure at index indx. */</i></td></tr>
<tr><th id="143">143</th><td><u>#define	<dfn class="macro" id="_M/GETBINTERNAL" data-ref="_M/GETBINTERNAL">GETBINTERNAL</dfn>(pg, indx)						\</u></td></tr>
<tr><th id="144">144</th><td><u>	((BINTERNAL *)(void *)((char *)(void *)(pg) + (pg)-&gt;linp[indx]))</u></td></tr>
<tr><th id="145">145</th><td></td></tr>
<tr><th id="146">146</th><td><i>/* Get the number of bytes in the entry. */</i></td></tr>
<tr><th id="147">147</th><td><u>#define <dfn class="macro" id="_M/_NBINTERNAL" data-ref="_M/_NBINTERNAL">_NBINTERNAL</dfn>(len)						\</u></td></tr>
<tr><th id="148">148</th><td><u>    BTLALIGN(sizeof(<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>) + sizeof(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>) + sizeof(<a class="typedef" href="../../../../sys/sys/types.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a>) + (len))</u></td></tr>
<tr><th id="149">149</th><td><u>#<span data-ppcond="149">ifdef</span> <span class="macro" data-ref="_M/_DIAGNOSTIC">_DIAGNOSTIC</span></u></td></tr>
<tr><th id="150">150</th><td><em>static</em> <b>__inline</b> <a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a></td></tr>
<tr><th id="151">151</th><td><dfn class="decl def fn" id="NBINTERNAL" title='NBINTERNAL' data-ref="NBINTERNAL" data-ref-filename="NBINTERNAL">NBINTERNAL</dfn>(<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="local col3 decl" id="3len" title='len' data-type='uint32_t' data-ref="3len" data-ref-filename="3len">len</dfn>) {</td></tr>
<tr><th id="152">152</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="local col4 decl" id="4x" title='x' data-type='size_t' data-ref="4x" data-ref-filename="4x">x</dfn> = <a class="macro" href="#147" title="(((sizeof(uint32_t) + sizeof(pgno_t) + sizeof(uint8_t) + (len)) + sizeof(pgno_t) - 1) &amp; ~(sizeof(pgno_t) - 1))" data-ref="_M/_NBINTERNAL">_NBINTERNAL</a>(<a class="local col3 ref" href="#3len" title='len' data-ref="3len" data-ref-filename="3len">len</a>);</td></tr>
<tr><th id="153">153</th><td>	<a class="macro" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#234" title="(((( ((uint32_t)((1ULL &lt;&lt; (sizeof(uint32_t) * 8 - 1)))) + (uint32_t)1 &lt; (uint32_t)1) ? ( (!((x) &gt; 0) &amp;&amp; ((x) != 0)) ? ((intmax_t)((x) + __zeroll()) &gt;= (intmax_t)((uint32_t)((1ULL &lt;&lt; (sizeof(uint32_t) * 8 - 1))))) : ((intmax_t)((x) + __zeroll()) &gt;= (intmax_t)0 &amp;&amp; (intmax_t)((x) + __zeroll()) &lt;= (intmax_t)((uint32_t)~((1ULL &lt;&lt; (sizeof(uint32_t) * 8 - 1)))))) : ( !(!((x) &gt; 0) &amp;&amp; ((x) != 0)) &amp;&amp; (uintmax_t)((x) + __zeroull()) &lt;= (uintmax_t)((uint32_t)~0ULL)))) ? (void)0 : __diagassert13(&quot;/___NETBSD_SRC___/objdir.amd64/compat/amd64/i386/lib/libc/../../../../../../lib/libc/db/btree/btree.h&quot;, 153, __func__, &quot;__type_fit(uint32_t, x)&quot;))" data-ref="_M/_DBFIT">_DBFIT</a>(<a class="local col4 ref" href="#4x" title='x' data-ref="4x" data-ref-filename="4x">x</a>, <a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>);</td></tr>
<tr><th id="154">154</th><td>	<b>return</b> (<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>)<a class="local col4 ref" href="#4x" title='x' data-ref="4x" data-ref-filename="4x">x</a>;</td></tr>
<tr><th id="155">155</th><td>}</td></tr>
<tr><th id="156">156</th><td><u>#<span data-ppcond="149">else</span></u></td></tr>
<tr><th id="157">157</th><td><u>#define NBINTERNAL(len)	(uint32_t)_NBINTERNAL(len)</u></td></tr>
<tr><th id="158">158</th><td><u>#<span data-ppcond="149">endif</span></u></td></tr>
<tr><th id="159">159</th><td></td></tr>
<tr><th id="160">160</th><td><i>/* Copy a BINTERNAL entry to the page. */</i></td></tr>
<tr><th id="161">161</th><td><u>#define	<dfn class="macro" id="_M/WR_BINTERNAL" data-ref="_M/WR_BINTERNAL">WR_BINTERNAL</dfn>(p, size, pgno, flags) do {				\</u></td></tr>
<tr><th id="162">162</th><td><u>	_DBFIT(size, uint32_t);						\</u></td></tr>
<tr><th id="163">163</th><td><u>	*(uint32_t *)(void *)p = (uint32_t)size;			\</u></td></tr>
<tr><th id="164">164</th><td><u>	p += sizeof(uint32_t);						\</u></td></tr>
<tr><th id="165">165</th><td><u>	*(pgno_t *)(void *)p = pgno;					\</u></td></tr>
<tr><th id="166">166</th><td><u>	p += sizeof(pgno_t);						\</u></td></tr>
<tr><th id="167">167</th><td><u>	*(uint8_t *)(void *)p = flags;					\</u></td></tr>
<tr><th id="168">168</th><td><u>	p += sizeof(uint8_t);						\</u></td></tr>
<tr><th id="169">169</th><td><u>} while (/*CONSTCOND*/0)</u></td></tr>
<tr><th id="170">170</th><td></td></tr>
<tr><th id="171">171</th><td><i>/*</i></td></tr>
<tr><th id="172">172</th><td><i> * For the recno internal pages, the item is a page number with the number of</i></td></tr>
<tr><th id="173">173</th><td><i> * keys found on that page and below.</i></td></tr>
<tr><th id="174">174</th><td><i> */</i></td></tr>
<tr><th id="175">175</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_rinternal" title='_rinternal' data-ref="_rinternal" data-ref-filename="_rinternal"><a class="type" href="#_rinternal" title='_rinternal' data-ref="_rinternal" data-ref-filename="_rinternal">_rinternal</a></dfn> {</td></tr>
<tr><th id="176">176</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#recno_t" title='recno_t' data-type='uint32_t' data-ref="recno_t" data-ref-filename="recno_t">recno_t</a>	<dfn class="decl field" id="_rinternal::nrecs" title='_rinternal::nrecs' data-ref="_rinternal::nrecs" data-ref-filename="_rinternal..nrecs">nrecs</dfn>;			<i>/* number of records */</i></td></tr>
<tr><th id="177">177</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>	<dfn class="decl field" id="_rinternal::pgno" title='_rinternal::pgno' data-ref="_rinternal::pgno" data-ref-filename="_rinternal..pgno">pgno</dfn>;			<i>/* page number stored below */</i></td></tr>
<tr><th id="178">178</th><td>} <dfn class="typedef" id="RINTERNAL" title='RINTERNAL' data-type='struct _rinternal' data-ref="RINTERNAL" data-ref-filename="RINTERNAL">RINTERNAL</dfn>;</td></tr>
<tr><th id="179">179</th><td></td></tr>
<tr><th id="180">180</th><td><i>/* Get the page's RINTERNAL structure at index indx. */</i></td></tr>
<tr><th id="181">181</th><td><u>#define	<dfn class="macro" id="_M/GETRINTERNAL" data-ref="_M/GETRINTERNAL">GETRINTERNAL</dfn>(pg, indx)						\</u></td></tr>
<tr><th id="182">182</th><td><u>	((RINTERNAL *)(void *)((char *)(void *)(pg) + (pg)-&gt;linp[indx]))</u></td></tr>
<tr><th id="183">183</th><td></td></tr>
<tr><th id="184">184</th><td><i>/* Get the number of bytes in the entry. */</i></td></tr>
<tr><th id="185">185</th><td><u>#define <dfn class="macro" id="_M/NRINTERNAL" data-ref="_M/NRINTERNAL">NRINTERNAL</dfn>							\</u></td></tr>
<tr><th id="186">186</th><td><u>	BTLALIGN(sizeof(recno_t) + sizeof(pgno_t))</u></td></tr>
<tr><th id="187">187</th><td></td></tr>
<tr><th id="188">188</th><td><i>/* Copy a RINTERNAL entry to the page. */</i></td></tr>
<tr><th id="189">189</th><td><u>#define	<dfn class="macro" id="_M/WR_RINTERNAL" data-ref="_M/WR_RINTERNAL">WR_RINTERNAL</dfn>(p, nrecs, pgno) do {				\</u></td></tr>
<tr><th id="190">190</th><td><u>	*(recno_t *)(void *)p = nrecs;					\</u></td></tr>
<tr><th id="191">191</th><td><u>	p += sizeof(recno_t);						\</u></td></tr>
<tr><th id="192">192</th><td><u>	*(pgno_t *)(void *)p = pgno;					\</u></td></tr>
<tr><th id="193">193</th><td><u>} while (/*CONSTCOND*/0)</u></td></tr>
<tr><th id="194">194</th><td></td></tr>
<tr><th id="195">195</th><td><i>/* For the btree leaf pages, the item is a key and data pair. */</i></td></tr>
<tr><th id="196">196</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_bleaf" title='_bleaf' data-ref="_bleaf" data-ref-filename="_bleaf"><a class="type" href="#_bleaf" title='_bleaf' data-ref="_bleaf" data-ref-filename="_bleaf">_bleaf</a></dfn> {</td></tr>
<tr><th id="197">197</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	<dfn class="decl field" id="_bleaf::ksize" title='_bleaf::ksize' data-ref="_bleaf::ksize" data-ref-filename="_bleaf..ksize">ksize</dfn>;		<i>/* size of key */</i></td></tr>
<tr><th id="198">198</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	<dfn class="decl field" id="_bleaf::dsize" title='_bleaf::dsize' data-ref="_bleaf::dsize" data-ref-filename="_bleaf..dsize">dsize</dfn>;		<i>/* size of data */</i></td></tr>
<tr><th id="199">199</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a>	<dfn class="decl field" id="_bleaf::flags" title='_bleaf::flags' data-ref="_bleaf::flags" data-ref-filename="_bleaf..flags">flags</dfn>;			<i>/* P_BIGDATA, P_BIGKEY */</i></td></tr>
<tr><th id="200">200</th><td>	<em>char</em>	<dfn class="decl field" id="_bleaf::bytes" title='_bleaf::bytes' data-ref="_bleaf::bytes" data-ref-filename="_bleaf..bytes">bytes</dfn>[<var>1</var>];		<i>/* data */</i></td></tr>
<tr><th id="201">201</th><td>} <dfn class="typedef" id="BLEAF" title='BLEAF' data-type='struct _bleaf' data-ref="BLEAF" data-ref-filename="BLEAF">BLEAF</dfn>;</td></tr>
<tr><th id="202">202</th><td></td></tr>
<tr><th id="203">203</th><td><i>/* Get the page's BLEAF structure at index indx. */</i></td></tr>
<tr><th id="204">204</th><td><u>#define	<dfn class="macro" id="_M/GETBLEAF" data-ref="_M/GETBLEAF">GETBLEAF</dfn>(pg, indx)						\</u></td></tr>
<tr><th id="205">205</th><td><u>	((BLEAF *)(void *)((char *)(void *)(pg) + (pg)-&gt;linp[indx]))</u></td></tr>
<tr><th id="206">206</th><td></td></tr>
<tr><th id="207">207</th><td></td></tr>
<tr><th id="208">208</th><td><i>/* Get the number of bytes in the user's key/data pair. */</i></td></tr>
<tr><th id="209">209</th><td><u>#define <dfn class="macro" id="_M/_NBLEAFDBT" data-ref="_M/_NBLEAFDBT">_NBLEAFDBT</dfn>(ksize, dsize)					\</u></td></tr>
<tr><th id="210">210</th><td><u>    BTLALIGN(sizeof(<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>) + sizeof(<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>) + sizeof(<a class="typedef" href="../../../../sys/sys/types.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a>) +	\</u></td></tr>
<tr><th id="211">211</th><td><u>	    (ksize) + (dsize))</u></td></tr>
<tr><th id="212">212</th><td><u>#<span data-ppcond="212">ifdef</span> <span class="macro" data-ref="_M/_DIAGNOSTIC">_DIAGNOSTIC</span></u></td></tr>
<tr><th id="213">213</th><td><em>static</em> <b>__inline</b> <a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a></td></tr>
<tr><th id="214">214</th><td><dfn class="decl def fn" id="NBLEAFDBT" title='NBLEAFDBT' data-ref="NBLEAFDBT" data-ref-filename="NBLEAFDBT">NBLEAFDBT</dfn>(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="local col5 decl" id="5k" title='k' data-type='size_t' data-ref="5k" data-ref-filename="5k">k</dfn>, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="local col6 decl" id="6d" title='d' data-type='size_t' data-ref="6d" data-ref-filename="6d">d</dfn>) {</td></tr>
<tr><th id="215">215</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="local col7 decl" id="7x" title='x' data-type='size_t' data-ref="7x" data-ref-filename="7x">x</dfn> = <a class="macro" href="#209" title="(((sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint8_t) + (k) + (d)) + sizeof(pgno_t) - 1) &amp; ~(sizeof(pgno_t) - 1))" data-ref="_M/_NBLEAFDBT">_NBLEAFDBT</a>(<a class="local col5 ref" href="#5k" title='k' data-ref="5k" data-ref-filename="5k">k</a>, <a class="local col6 ref" href="#6d" title='d' data-ref="6d" data-ref-filename="6d">d</a>);</td></tr>
<tr><th id="216">216</th><td>	<a class="macro" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#234" title="(((( ((uint32_t)((1ULL &lt;&lt; (sizeof(uint32_t) * 8 - 1)))) + (uint32_t)1 &lt; (uint32_t)1) ? ( (!((x) &gt; 0) &amp;&amp; ((x) != 0)) ? ((intmax_t)((x) + __zeroll()) &gt;= (intmax_t)((uint32_t)((1ULL &lt;&lt; (sizeof(uint32_t) * 8 - 1))))) : ((intmax_t)((x) + __zeroll()) &gt;= (intmax_t)0 &amp;&amp; (intmax_t)((x) + __zeroll()) &lt;= (intmax_t)((uint32_t)~((1ULL &lt;&lt; (sizeof(uint32_t) * 8 - 1)))))) : ( !(!((x) &gt; 0) &amp;&amp; ((x) != 0)) &amp;&amp; (uintmax_t)((x) + __zeroull()) &lt;= (uintmax_t)((uint32_t)~0ULL)))) ? (void)0 : __diagassert13(&quot;/___NETBSD_SRC___/objdir.amd64/compat/amd64/i386/lib/libc/../../../../../../lib/libc/db/btree/btree.h&quot;, 216, __func__, &quot;__type_fit(uint32_t, x)&quot;))" data-ref="_M/_DBFIT">_DBFIT</a>(<a class="local col7 ref" href="#7x" title='x' data-ref="7x" data-ref-filename="7x">x</a>, <a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>);</td></tr>
<tr><th id="217">217</th><td>	<b>return</b> (<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>)<a class="local col7 ref" href="#7x" title='x' data-ref="7x" data-ref-filename="7x">x</a>;</td></tr>
<tr><th id="218">218</th><td>}</td></tr>
<tr><th id="219">219</th><td><u>#<span data-ppcond="212">else</span></u></td></tr>
<tr><th id="220">220</th><td><u>#define NBLEAFDBT(p, q)	(uint32_t)_NBLEAFDBT(p, q)</u></td></tr>
<tr><th id="221">221</th><td><u>#<span data-ppcond="212">endif</span></u></td></tr>
<tr><th id="222">222</th><td></td></tr>
<tr><th id="223">223</th><td><i>/* Get the number of bytes in the entry. */</i></td></tr>
<tr><th id="224">224</th><td><u>#define <dfn class="macro" id="_M/NBLEAF" data-ref="_M/NBLEAF">NBLEAF</dfn>(p)	NBLEAFDBT((p)-&gt;ksize, (p)-&gt;dsize)</u></td></tr>
<tr><th id="225">225</th><td></td></tr>
<tr><th id="226">226</th><td><i>/* Copy a BLEAF entry to the page. */</i></td></tr>
<tr><th id="227">227</th><td><u>#define	<dfn class="macro" id="_M/WR_BLEAF" data-ref="_M/WR_BLEAF">WR_BLEAF</dfn>(p, key, data, flags) do {				\</u></td></tr>
<tr><th id="228">228</th><td><u>	_DBFIT(key-&gt;size, uint32_t);					\</u></td></tr>
<tr><th id="229">229</th><td><u>	*(uint32_t *)(void *)p = (uint32_t)key-&gt;size;			\</u></td></tr>
<tr><th id="230">230</th><td><u>	p += sizeof(uint32_t);						\</u></td></tr>
<tr><th id="231">231</th><td><u>	_DBFIT(data-&gt;size, uint32_t);					\</u></td></tr>
<tr><th id="232">232</th><td><u>	*(uint32_t *)(void *)p = (uint32_t)data-&gt;size;			\</u></td></tr>
<tr><th id="233">233</th><td><u>	p += sizeof(uint32_t);						\</u></td></tr>
<tr><th id="234">234</th><td><u>	*(uint8_t *)(void *)p = flags;					\</u></td></tr>
<tr><th id="235">235</th><td><u>	p += sizeof(uint8_t);						\</u></td></tr>
<tr><th id="236">236</th><td><u>	(void)memmove(p, key-&gt;data, key-&gt;size);				\</u></td></tr>
<tr><th id="237">237</th><td><u>	p += key-&gt;size;							\</u></td></tr>
<tr><th id="238">238</th><td><u>	(void)memmove(p, data-&gt;data, data-&gt;size);			\</u></td></tr>
<tr><th id="239">239</th><td><u>} while (/*CONSTCOND*/0)</u></td></tr>
<tr><th id="240">240</th><td></td></tr>
<tr><th id="241">241</th><td><i>/* For the recno leaf pages, the item is a data entry. */</i></td></tr>
<tr><th id="242">242</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_rleaf" title='_rleaf' data-ref="_rleaf" data-ref-filename="_rleaf"><a class="type" href="#_rleaf" title='_rleaf' data-ref="_rleaf" data-ref-filename="_rleaf">_rleaf</a></dfn> {</td></tr>
<tr><th id="243">243</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	<dfn class="decl field" id="_rleaf::dsize" title='_rleaf::dsize' data-ref="_rleaf::dsize" data-ref-filename="_rleaf..dsize">dsize</dfn>;		<i>/* size of data */</i></td></tr>
<tr><th id="244">244</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a>	<dfn class="decl field" id="_rleaf::flags" title='_rleaf::flags' data-ref="_rleaf::flags" data-ref-filename="_rleaf..flags">flags</dfn>;			<i>/* P_BIGDATA */</i></td></tr>
<tr><th id="245">245</th><td>	<em>char</em>	<dfn class="decl field" id="_rleaf::bytes" title='_rleaf::bytes' data-ref="_rleaf::bytes" data-ref-filename="_rleaf..bytes">bytes</dfn>[<var>1</var>];</td></tr>
<tr><th id="246">246</th><td>} <dfn class="typedef" id="RLEAF" title='RLEAF' data-type='struct _rleaf' data-ref="RLEAF" data-ref-filename="RLEAF">RLEAF</dfn>;</td></tr>
<tr><th id="247">247</th><td></td></tr>
<tr><th id="248">248</th><td><i>/* Get the page's RLEAF structure at index indx. */</i></td></tr>
<tr><th id="249">249</th><td><u>#define	<dfn class="macro" id="_M/GETRLEAF" data-ref="_M/GETRLEAF">GETRLEAF</dfn>(pg, indx)						\</u></td></tr>
<tr><th id="250">250</th><td><u>	((RLEAF *)(void *)((char *)(void *)(pg) + (pg)-&gt;linp[indx]))</u></td></tr>
<tr><th id="251">251</th><td></td></tr>
<tr><th id="252">252</th><td><u>#define	<dfn class="macro" id="_M/_NRLEAFDBT" data-ref="_M/_NRLEAFDBT">_NRLEAFDBT</dfn>(dsize)						\</u></td></tr>
<tr><th id="253">253</th><td><u>	BTLALIGN(sizeof(<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>) + sizeof(<a class="typedef" href="../../../../sys/sys/types.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a>) + (dsize))</u></td></tr>
<tr><th id="254">254</th><td></td></tr>
<tr><th id="255">255</th><td><u>#<span data-ppcond="255">ifdef</span> <span class="macro" data-ref="_M/_DIAGNOSTIC">_DIAGNOSTIC</span></u></td></tr>
<tr><th id="256">256</th><td><em>static</em> <b>__inline</b> <a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a></td></tr>
<tr><th id="257">257</th><td><dfn class="decl def fn" id="NRLEAFDBT" title='NRLEAFDBT' data-ref="NRLEAFDBT" data-ref-filename="NRLEAFDBT">NRLEAFDBT</dfn>(<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="local col8 decl" id="8d" title='d' data-type='size_t' data-ref="8d" data-ref-filename="8d">d</dfn>) {</td></tr>
<tr><th id="258">258</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="local col9 decl" id="9x" title='x' data-type='size_t' data-ref="9x" data-ref-filename="9x">x</dfn> = <a class="macro" href="#252" title="(((sizeof(uint32_t) + sizeof(uint8_t) + (d)) + sizeof(pgno_t) - 1) &amp; ~(sizeof(pgno_t) - 1))" data-ref="_M/_NRLEAFDBT">_NRLEAFDBT</a>(<a class="local col8 ref" href="#8d" title='d' data-ref="8d" data-ref-filename="8d">d</a>);</td></tr>
<tr><th id="259">259</th><td>	<a class="macro" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#234" title="(((( ((uint32_t)((1ULL &lt;&lt; (sizeof(uint32_t) * 8 - 1)))) + (uint32_t)1 &lt; (uint32_t)1) ? ( (!((x) &gt; 0) &amp;&amp; ((x) != 0)) ? ((intmax_t)((x) + __zeroll()) &gt;= (intmax_t)((uint32_t)((1ULL &lt;&lt; (sizeof(uint32_t) * 8 - 1))))) : ((intmax_t)((x) + __zeroll()) &gt;= (intmax_t)0 &amp;&amp; (intmax_t)((x) + __zeroll()) &lt;= (intmax_t)((uint32_t)~((1ULL &lt;&lt; (sizeof(uint32_t) * 8 - 1)))))) : ( !(!((x) &gt; 0) &amp;&amp; ((x) != 0)) &amp;&amp; (uintmax_t)((x) + __zeroull()) &lt;= (uintmax_t)((uint32_t)~0ULL)))) ? (void)0 : __diagassert13(&quot;/___NETBSD_SRC___/objdir.amd64/compat/amd64/i386/lib/libc/../../../../../../lib/libc/db/btree/btree.h&quot;, 259, __func__, &quot;__type_fit(uint32_t, x)&quot;))" data-ref="_M/_DBFIT">_DBFIT</a>(<a class="local col9 ref" href="#9x" title='x' data-ref="9x" data-ref-filename="9x">x</a>, <a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>);</td></tr>
<tr><th id="260">260</th><td>	<b>return</b> (<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>)<a class="local col9 ref" href="#9x" title='x' data-ref="9x" data-ref-filename="9x">x</a>;</td></tr>
<tr><th id="261">261</th><td>}</td></tr>
<tr><th id="262">262</th><td><u>#<span data-ppcond="255">else</span></u></td></tr>
<tr><th id="263">263</th><td><u>#define NRLEAFDBT(d)	(uint32_t)_NRLEAFDBT(d)</u></td></tr>
<tr><th id="264">264</th><td><u>#<span data-ppcond="255">endif</span></u></td></tr>
<tr><th id="265">265</th><td></td></tr>
<tr><th id="266">266</th><td><i>/* Get the number of bytes in the entry. */</i></td></tr>
<tr><th id="267">267</th><td><u>#define <dfn class="macro" id="_M/NRLEAF" data-ref="_M/NRLEAF">NRLEAF</dfn>(p)	NRLEAFDBT((p)-&gt;dsize)</u></td></tr>
<tr><th id="268">268</th><td></td></tr>
<tr><th id="269">269</th><td><i>/* Get the number of bytes from the user's data. */</i></td></tr>
<tr><th id="270">270</th><td></td></tr>
<tr><th id="271">271</th><td><i>/* Copy a RLEAF entry to the page. */</i></td></tr>
<tr><th id="272">272</th><td><u>#define	<dfn class="macro" id="_M/WR_RLEAF" data-ref="_M/WR_RLEAF">WR_RLEAF</dfn>(p, data, flags) do {					\</u></td></tr>
<tr><th id="273">273</th><td><u>	_DBFIT(data-&gt;size, uint32_t);					\</u></td></tr>
<tr><th id="274">274</th><td><u>	*(uint32_t *)(void *)p = (uint32_t)data-&gt;size;			\</u></td></tr>
<tr><th id="275">275</th><td><u>	p += sizeof(uint32_t);						\</u></td></tr>
<tr><th id="276">276</th><td><u>	*(uint8_t *)(void *)p = flags;					\</u></td></tr>
<tr><th id="277">277</th><td><u>	p += sizeof(uint8_t);						\</u></td></tr>
<tr><th id="278">278</th><td><u>	memmove(p, data-&gt;data, data-&gt;size);				\</u></td></tr>
<tr><th id="279">279</th><td><u>} while (/*CONSTCOND*/0)</u></td></tr>
<tr><th id="280">280</th><td></td></tr>
<tr><th id="281">281</th><td><i>/*</i></td></tr>
<tr><th id="282">282</th><td><i> * A record in the tree is either a pointer to a page and an index in the page</i></td></tr>
<tr><th id="283">283</th><td><i> * or a page number and an index.  These structures are used as a cursor, stack</i></td></tr>
<tr><th id="284">284</th><td><i> * entry and search returns as well as to pass records to other routines.</i></td></tr>
<tr><th id="285">285</th><td><i> *</i></td></tr>
<tr><th id="286">286</th><td><i> * One comment about searches.  Internal page searches must find the largest</i></td></tr>
<tr><th id="287">287</th><td><i> * record less than key in the tree so that descents work.  Leaf page searches</i></td></tr>
<tr><th id="288">288</th><td><i> * must find the smallest record greater than key so that the returned index</i></td></tr>
<tr><th id="289">289</th><td><i> * is the record's correct position for insertion.</i></td></tr>
<tr><th id="290">290</th><td><i> */</i></td></tr>
<tr><th id="291">291</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_epgno" title='_epgno' data-ref="_epgno" data-ref-filename="_epgno"><a class="type" href="#_epgno" title='_epgno' data-ref="_epgno" data-ref-filename="_epgno">_epgno</a></dfn> {</td></tr>
<tr><th id="292">292</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>	<dfn class="decl field" id="_epgno::pgno" title='_epgno::pgno' data-ref="_epgno::pgno" data-ref-filename="_epgno..pgno">pgno</dfn>;			<i>/* the page number */</i></td></tr>
<tr><th id="293">293</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>	<dfn class="decl field" id="_epgno::index" title='_epgno::index' data-ref="_epgno::index" data-ref-filename="_epgno..index">index</dfn>;			<i>/* the index on the page */</i></td></tr>
<tr><th id="294">294</th><td>} <dfn class="typedef" id="EPGNO" title='EPGNO' data-type='struct _epgno' data-ref="EPGNO" data-ref-filename="EPGNO">EPGNO</dfn>;</td></tr>
<tr><th id="295">295</th><td></td></tr>
<tr><th id="296">296</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_epg" title='_epg' data-ref="_epg" data-ref-filename="_epg"><a class="type" href="#_epg" title='_epg' data-ref="_epg" data-ref-filename="_epg">_epg</a></dfn> {</td></tr>
<tr><th id="297">297</th><td>	<a class="typedef" href="#PAGE" title='PAGE' data-type='struct _page' data-ref="PAGE" data-ref-filename="PAGE">PAGE</a>	*<dfn class="decl field" id="_epg::page" title='_epg::page' data-ref="_epg::page" data-ref-filename="_epg..page">page</dfn>;			<i>/* the (pinned) page */</i></td></tr>
<tr><th id="298">298</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>	 <dfn class="decl field" id="_epg::index" title='_epg::index' data-ref="_epg::index" data-ref-filename="_epg..index">index</dfn>;			<i>/* the index on the page */</i></td></tr>
<tr><th id="299">299</th><td>} <dfn class="typedef" id="EPG" title='EPG' data-type='struct _epg' data-ref="EPG" data-ref-filename="EPG">EPG</dfn>;</td></tr>
<tr><th id="300">300</th><td></td></tr>
<tr><th id="301">301</th><td><i>/*</i></td></tr>
<tr><th id="302">302</th><td><i> * About cursors.  The cursor (and the page that contained the key/data pair</i></td></tr>
<tr><th id="303">303</th><td><i> * that it referenced) can be deleted, which makes things a bit tricky.  If</i></td></tr>
<tr><th id="304">304</th><td><i> * there are no duplicates of the cursor key in the tree (i.e. B_NODUPS is set</i></td></tr>
<tr><th id="305">305</th><td><i> * or there simply aren't any duplicates of the key) we copy the key that it</i></td></tr>
<tr><th id="306">306</th><td><i> * referenced when it's deleted, and reacquire a new cursor key if the cursor</i></td></tr>
<tr><th id="307">307</th><td><i> * is used again.  If there are duplicates keys, we move to the next/previous</i></td></tr>
<tr><th id="308">308</th><td><i> * key, and set a flag so that we know what happened.  NOTE: if duplicate (to</i></td></tr>
<tr><th id="309">309</th><td><i> * the cursor) keys are added to the tree during this process, it is undefined</i></td></tr>
<tr><th id="310">310</th><td><i> * if they will be returned or not in a cursor scan.</i></td></tr>
<tr><th id="311">311</th><td><i> *</i></td></tr>
<tr><th id="312">312</th><td><i> * The flags determine the possible states of the cursor:</i></td></tr>
<tr><th id="313">313</th><td><i> *</i></td></tr>
<tr><th id="314">314</th><td><i> * CURS_INIT	The cursor references *something*.</i></td></tr>
<tr><th id="315">315</th><td><i> * CURS_ACQUIRE	The cursor was deleted, and a key has been saved so that</i></td></tr>
<tr><th id="316">316</th><td><i> *		we can reacquire the right position in the tree.</i></td></tr>
<tr><th id="317">317</th><td><i> * CURS_AFTER, CURS_BEFORE</i></td></tr>
<tr><th id="318">318</th><td><i> *		The cursor was deleted, and now references a key/data pair</i></td></tr>
<tr><th id="319">319</th><td><i> *		that has not yet been returned, either before or after the</i></td></tr>
<tr><th id="320">320</th><td><i> *		deleted key/data pair.</i></td></tr>
<tr><th id="321">321</th><td><i> * XXX</i></td></tr>
<tr><th id="322">322</th><td><i> * This structure is broken out so that we can eventually offer multiple</i></td></tr>
<tr><th id="323">323</th><td><i> * cursors as part of the DB interface.</i></td></tr>
<tr><th id="324">324</th><td><i> */</i></td></tr>
<tr><th id="325">325</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_cursor" title='_cursor' data-ref="_cursor" data-ref-filename="_cursor"><a class="type" href="#_cursor" title='_cursor' data-ref="_cursor" data-ref-filename="_cursor">_cursor</a></dfn> {</td></tr>
<tr><th id="326">326</th><td>	<a class="typedef" href="#EPGNO" title='EPGNO' data-type='struct _epgno' data-ref="EPGNO" data-ref-filename="EPGNO">EPGNO</a>	 <dfn class="decl field" id="_cursor::pg" title='_cursor::pg' data-ref="_cursor::pg" data-ref-filename="_cursor..pg">pg</dfn>;			<i>/* B: Saved tree reference. */</i></td></tr>
<tr><th id="327">327</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#DBT" title='DBT' data-type='struct DBT' data-ref="DBT" data-ref-filename="DBT">DBT</a>	 <dfn class="decl field" id="_cursor::key" title='_cursor::key' data-ref="_cursor::key" data-ref-filename="_cursor..key">key</dfn>;			<i>/* B: Saved key, or key.data == NULL. */</i></td></tr>
<tr><th id="328">328</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#recno_t" title='recno_t' data-type='uint32_t' data-ref="recno_t" data-ref-filename="recno_t">recno_t</a>	 <dfn class="decl field" id="_cursor::rcursor" title='_cursor::rcursor' data-ref="_cursor::rcursor" data-ref-filename="_cursor..rcursor">rcursor</dfn>;		<i>/* R: recno cursor (1-based) */</i></td></tr>
<tr><th id="329">329</th><td></td></tr>
<tr><th id="330">330</th><td><u>#define	<dfn class="macro" id="_M/CURS_ACQUIRE" data-ref="_M/CURS_ACQUIRE">CURS_ACQUIRE</dfn>	0x01		/*  B: Cursor needs to be reacquired. */</u></td></tr>
<tr><th id="331">331</th><td><u>#define	<dfn class="macro" id="_M/CURS_AFTER" data-ref="_M/CURS_AFTER">CURS_AFTER</dfn>	0x02		/*  B: Unreturned cursor after key. */</u></td></tr>
<tr><th id="332">332</th><td><u>#define	<dfn class="macro" id="_M/CURS_BEFORE" data-ref="_M/CURS_BEFORE">CURS_BEFORE</dfn>	0x04		/*  B: Unreturned cursor before key. */</u></td></tr>
<tr><th id="333">333</th><td><u>#define	<dfn class="macro" id="_M/CURS_INIT" data-ref="_M/CURS_INIT">CURS_INIT</dfn>	0x08		/* RB: Cursor initialized. */</u></td></tr>
<tr><th id="334">334</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="_cursor::flags" title='_cursor::flags' data-ref="_cursor::flags" data-ref-filename="_cursor..flags">flags</dfn>;</td></tr>
<tr><th id="335">335</th><td>} <dfn class="typedef" id="CURSOR" title='CURSOR' data-type='struct _cursor' data-ref="CURSOR" data-ref-filename="CURSOR">CURSOR</dfn>;</td></tr>
<tr><th id="336">336</th><td></td></tr>
<tr><th id="337">337</th><td><i>/*</i></td></tr>
<tr><th id="338">338</th><td><i> * The metadata of the tree.  The nrecs field is used only by the RECNO code.</i></td></tr>
<tr><th id="339">339</th><td><i> * This is because the btree doesn't really need it and it requires that every</i></td></tr>
<tr><th id="340">340</th><td><i> * put or delete call modify the metadata.</i></td></tr>
<tr><th id="341">341</th><td><i> */</i></td></tr>
<tr><th id="342">342</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_btmeta" title='_btmeta' data-ref="_btmeta" data-ref-filename="_btmeta"><a class="type" href="#_btmeta" title='_btmeta' data-ref="_btmeta" data-ref-filename="_btmeta">_btmeta</a></dfn> {</td></tr>
<tr><th id="343">343</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	<dfn class="decl field" id="_btmeta::magic" title='_btmeta::magic' data-ref="_btmeta::magic" data-ref-filename="_btmeta..magic">magic</dfn>;		<i>/* magic number */</i></td></tr>
<tr><th id="344">344</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	<dfn class="decl field" id="_btmeta::version" title='_btmeta::version' data-ref="_btmeta::version" data-ref-filename="_btmeta..version">version</dfn>;	<i>/* version */</i></td></tr>
<tr><th id="345">345</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	<dfn class="decl field" id="_btmeta::psize" title='_btmeta::psize' data-ref="_btmeta::psize" data-ref-filename="_btmeta..psize">psize</dfn>;		<i>/* page size */</i></td></tr>
<tr><th id="346">346</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	<dfn class="decl field" id="_btmeta::free" title='_btmeta::free' data-ref="_btmeta::free" data-ref-filename="_btmeta..free">free</dfn>;		<i>/* page number of first free page */</i></td></tr>
<tr><th id="347">347</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	<dfn class="decl field" id="_btmeta::nrecs" title='_btmeta::nrecs' data-ref="_btmeta::nrecs" data-ref-filename="_btmeta..nrecs">nrecs</dfn>;		<i>/* R: number of records */</i></td></tr>
<tr><th id="348">348</th><td></td></tr>
<tr><th id="349">349</th><td><u>#define	<dfn class="macro" id="_M/SAVEMETA" data-ref="_M/SAVEMETA">SAVEMETA</dfn>	(B_NODUPS | R_RECNO)</u></td></tr>
<tr><th id="350">350</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	<dfn class="decl field" id="_btmeta::flags" title='_btmeta::flags' data-ref="_btmeta::flags" data-ref-filename="_btmeta..flags">flags</dfn>;		<i>/* bt_flags &amp; SAVEMETA */</i></td></tr>
<tr><th id="351">351</th><td>} <dfn class="typedef" id="BTMETA" title='BTMETA' data-type='struct _btmeta' data-ref="BTMETA" data-ref-filename="BTMETA">BTMETA</dfn>;</td></tr>
<tr><th id="352">352</th><td></td></tr>
<tr><th id="353">353</th><td><i>/* The in-memory btree/recno data structure. */</i></td></tr>
<tr><th id="354">354</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="_btree" title='_btree' data-ref="_btree" data-ref-filename="_btree"><a class="type" href="#_btree" title='_btree' data-ref="_btree" data-ref-filename="_btree">_btree</a></dfn> {</td></tr>
<tr><th id="355">355</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/mpool.h.html#MPOOL" title='MPOOL' data-type='struct MPOOL' data-ref="MPOOL" data-ref-filename="MPOOL">MPOOL</a>	 *<dfn class="decl field" id="_btree::bt_mp" title='_btree::bt_mp' data-ref="_btree::bt_mp" data-ref-filename="_btree..bt_mp">bt_mp</dfn>;		<i>/* memory pool cookie */</i></td></tr>
<tr><th id="356">356</th><td></td></tr>
<tr><th id="357">357</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#DB" title='DB' data-type='struct __db' data-ref="DB" data-ref-filename="DB">DB</a>	 *<dfn class="decl field" id="_btree::bt_dbp" title='_btree::bt_dbp' data-ref="_btree::bt_dbp" data-ref-filename="_btree..bt_dbp">bt_dbp</dfn>;		<i>/* pointer to enclosing DB */</i></td></tr>
<tr><th id="358">358</th><td></td></tr>
<tr><th id="359">359</th><td>	<a class="typedef" href="#EPG" title='EPG' data-type='struct _epg' data-ref="EPG" data-ref-filename="EPG">EPG</a>	  <dfn class="decl field" id="_btree::bt_cur" title='_btree::bt_cur' data-ref="_btree::bt_cur" data-ref-filename="_btree..bt_cur">bt_cur</dfn>;		<i>/* current (pinned) page */</i></td></tr>
<tr><th id="360">360</th><td>	<a class="typedef" href="#PAGE" title='PAGE' data-type='struct _page' data-ref="PAGE" data-ref-filename="PAGE">PAGE</a>	 *<dfn class="decl field" id="_btree::bt_pinned" title='_btree::bt_pinned' data-ref="_btree::bt_pinned" data-ref-filename="_btree..bt_pinned">bt_pinned</dfn>;		<i>/* page pinned across calls */</i></td></tr>
<tr><th id="361">361</th><td></td></tr>
<tr><th id="362">362</th><td>	<a class="typedef" href="#CURSOR" title='CURSOR' data-type='struct _cursor' data-ref="CURSOR" data-ref-filename="CURSOR">CURSOR</a>	  <dfn class="decl field" id="_btree::bt_cursor" title='_btree::bt_cursor' data-ref="_btree::bt_cursor" data-ref-filename="_btree..bt_cursor">bt_cursor</dfn>;		<i>/* cursor */</i></td></tr>
<tr><th id="363">363</th><td></td></tr>
<tr><th id="364">364</th><td><u>#define	<dfn class="macro" id="_M/BT_PUSH" data-ref="_M/BT_PUSH">BT_PUSH</dfn>(t, p, i) {						\</u></td></tr>
<tr><th id="365">365</th><td><u>	t-&gt;bt_sp-&gt;pgno = p; 						\</u></td></tr>
<tr><th id="366">366</th><td><u>	t-&gt;bt_sp-&gt;index = i; 						\</u></td></tr>
<tr><th id="367">367</th><td><u>	++t-&gt;bt_sp;							\</u></td></tr>
<tr><th id="368">368</th><td><u>}</u></td></tr>
<tr><th id="369">369</th><td><u>#define	<dfn class="macro" id="_M/BT_POP" data-ref="_M/BT_POP">BT_POP</dfn>(t)	(t-&gt;bt_sp == t-&gt;bt_stack ? NULL : --t-&gt;bt_sp)</u></td></tr>
<tr><th id="370">370</th><td><u>#define	<dfn class="macro" id="_M/BT_CLR" data-ref="_M/BT_CLR">BT_CLR</dfn>(t)	(t-&gt;bt_sp = t-&gt;bt_stack)</u></td></tr>
<tr><th id="371">371</th><td>	<a class="typedef" href="#EPGNO" title='EPGNO' data-type='struct _epgno' data-ref="EPGNO" data-ref-filename="EPGNO">EPGNO</a>	  <dfn class="decl field" id="_btree::bt_stack" title='_btree::bt_stack' data-ref="_btree::bt_stack" data-ref-filename="_btree..bt_stack">bt_stack</dfn>[<var>50</var>];		<i>/* stack of parent pages */</i></td></tr>
<tr><th id="372">372</th><td>	<a class="typedef" href="#EPGNO" title='EPGNO' data-type='struct _epgno' data-ref="EPGNO" data-ref-filename="EPGNO">EPGNO</a>	 *<dfn class="decl field" id="_btree::bt_sp" title='_btree::bt_sp' data-ref="_btree::bt_sp" data-ref-filename="_btree..bt_sp">bt_sp</dfn>;		<i>/* current stack pointer */</i></td></tr>
<tr><th id="373">373</th><td></td></tr>
<tr><th id="374">374</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#DBT" title='DBT' data-type='struct DBT' data-ref="DBT" data-ref-filename="DBT">DBT</a>	  <dfn class="decl field" id="_btree::bt_rkey" title='_btree::bt_rkey' data-ref="_btree::bt_rkey" data-ref-filename="_btree..bt_rkey">bt_rkey</dfn>;		<i>/* returned key */</i></td></tr>
<tr><th id="375">375</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#DBT" title='DBT' data-type='struct DBT' data-ref="DBT" data-ref-filename="DBT">DBT</a>	  <dfn class="decl field" id="_btree::bt_rdata" title='_btree::bt_rdata' data-ref="_btree::bt_rdata" data-ref-filename="_btree..bt_rdata">bt_rdata</dfn>;		<i>/* returned data */</i></td></tr>
<tr><th id="376">376</th><td></td></tr>
<tr><th id="377">377</th><td>	<em>int</em>	  <dfn class="decl field" id="_btree::bt_fd" title='_btree::bt_fd' data-ref="_btree::bt_fd" data-ref-filename="_btree..bt_fd">bt_fd</dfn>;		<i>/* tree file descriptor */</i></td></tr>
<tr><th id="378">378</th><td></td></tr>
<tr><th id="379">379</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#pgno_t" title='pgno_t' data-type='uint32_t' data-ref="pgno_t" data-ref-filename="pgno_t">pgno_t</a>	  <dfn class="decl field" id="_btree::bt_free" title='_btree::bt_free' data-ref="_btree::bt_free" data-ref-filename="_btree..bt_free">bt_free</dfn>;		<i>/* next free page */</i></td></tr>
<tr><th id="380">380</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="_btree::bt_psize" title='_btree::bt_psize' data-ref="_btree::bt_psize" data-ref-filename="_btree..bt_psize">bt_psize</dfn>;		<i>/* page size */</i></td></tr>
<tr><th id="381">381</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#indx_t" title='indx_t' data-type='uint16_t' data-ref="indx_t" data-ref-filename="indx_t">indx_t</a>	  <dfn class="decl field" id="_btree::bt_ovflsize" title='_btree::bt_ovflsize' data-ref="_btree::bt_ovflsize" data-ref-filename="_btree..bt_ovflsize">bt_ovflsize</dfn>;		<i>/* cut-off for key/data overflow */</i></td></tr>
<tr><th id="382">382</th><td>	<em>int</em>	  <dfn class="decl field" id="_btree::bt_lorder" title='_btree::bt_lorder' data-ref="_btree::bt_lorder" data-ref-filename="_btree..bt_lorder">bt_lorder</dfn>;		<i>/* byte order */</i></td></tr>
<tr><th id="383">383</th><td>					<i>/* sorted order */</i></td></tr>
<tr><th id="384">384</th><td>	<b>enum</b> { <dfn class="enum" id="_btree::NOT" title='_btree::NOT' data-ref="_btree::NOT" data-ref-filename="_btree..NOT">NOT</dfn>, <dfn class="enum" id="_btree::BACK" title='_btree::BACK' data-ref="_btree::BACK" data-ref-filename="_btree..BACK">BACK</dfn>, <dfn class="enum" id="_btree::FORWARD" title='_btree::FORWARD' data-ref="_btree::FORWARD" data-ref-filename="_btree..FORWARD">FORWARD</dfn> } <dfn class="decl field" id="_btree::bt_order" title='_btree::bt_order' data-ref="_btree::bt_order" data-ref-filename="_btree..bt_order">bt_order</dfn>;</td></tr>
<tr><th id="385">385</th><td>	<a class="typedef" href="#EPGNO" title='EPGNO' data-type='struct _epgno' data-ref="EPGNO" data-ref-filename="EPGNO">EPGNO</a>	  <dfn class="decl field" id="_btree::bt_last" title='_btree::bt_last' data-ref="_btree::bt_last" data-ref-filename="_btree..bt_last">bt_last</dfn>;		<i>/* last insert */</i></td></tr>
<tr><th id="386">386</th><td></td></tr>
<tr><th id="387">387</th><td>					<i>/* B: key comparison function */</i></td></tr>
<tr><th id="388">388</th><td>	<em>int</em>	(*<dfn class="decl field" id="_btree::bt_cmp" title='_btree::bt_cmp' data-ref="_btree::bt_cmp" data-ref-filename="_btree..bt_cmp">bt_cmp</dfn>)(<em>const</em> <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#DBT" title='DBT' data-type='struct DBT' data-ref="DBT" data-ref-filename="DBT">DBT</a> *, <em>const</em> <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#DBT" title='DBT' data-type='struct DBT' data-ref="DBT" data-ref-filename="DBT">DBT</a> *);</td></tr>
<tr><th id="389">389</th><td>					<i>/* B: prefix comparison function */</i></td></tr>
<tr><th id="390">390</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>	(*<dfn class="decl field" id="_btree::bt_pfx" title='_btree::bt_pfx' data-ref="_btree::bt_pfx" data-ref-filename="_btree..bt_pfx">bt_pfx</dfn>)(<em>const</em> <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#DBT" title='DBT' data-type='struct DBT' data-ref="DBT" data-ref-filename="DBT">DBT</a> *, <em>const</em> <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#DBT" title='DBT' data-type='struct DBT' data-ref="DBT" data-ref-filename="DBT">DBT</a> *);</td></tr>
<tr><th id="391">391</th><td>					<i>/* R: recno input function */</i></td></tr>
<tr><th id="392">392</th><td>	<em>int</em>	(*<dfn class="decl field" id="_btree::bt_irec" title='_btree::bt_irec' data-ref="_btree::bt_irec" data-ref-filename="_btree..bt_irec">bt_irec</dfn>)(<b>struct</b> <a class="type" href="#_btree" title='_btree' data-ref="_btree" data-ref-filename="_btree">_btree</a> *, <a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#recno_t" title='recno_t' data-type='uint32_t' data-ref="recno_t" data-ref-filename="recno_t">recno_t</a>);</td></tr>
<tr><th id="393">393</th><td></td></tr>
<tr><th id="394">394</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#FILE" title='FILE' data-type='struct __sFILE' data-ref="FILE" data-ref-filename="FILE">FILE</a>	 *<dfn class="decl field" id="_btree::bt_rfp" title='_btree::bt_rfp' data-ref="_btree::bt_rfp" data-ref-filename="_btree..bt_rfp">bt_rfp</dfn>;		<i>/* R: record FILE pointer */</i></td></tr>
<tr><th id="395">395</th><td>	<em>int</em>	  <dfn class="decl field" id="_btree::bt_rfd" title='_btree::bt_rfd' data-ref="_btree::bt_rfd" data-ref-filename="_btree..bt_rfd">bt_rfd</dfn>;		<i>/* R: record file descriptor */</i></td></tr>
<tr><th id="396">396</th><td></td></tr>
<tr><th id="397">397</th><td>	<a class="macro" href="../../../../sys/sys/types.h.html#146" title="__caddr_t" data-ref="_M/caddr_t">caddr_t</a>	  <dfn class="decl field" id="_btree::bt_cmap" title='_btree::bt_cmap' data-ref="_btree::bt_cmap" data-ref-filename="_btree..bt_cmap">bt_cmap</dfn>;		<i>/* R: current point in mapped space */</i></td></tr>
<tr><th id="398">398</th><td>	<a class="macro" href="../../../../sys/sys/types.h.html#146" title="__caddr_t" data-ref="_M/caddr_t">caddr_t</a>	  <dfn class="decl field" id="_btree::bt_smap" title='_btree::bt_smap' data-ref="_btree::bt_smap" data-ref-filename="_btree..bt_smap">bt_smap</dfn>;		<i>/* R: start of mapped space */</i></td></tr>
<tr><th id="399">399</th><td>	<a class="macro" href="../../../../sys/sys/types.h.html#146" title="__caddr_t" data-ref="_M/caddr_t">caddr_t</a>   <dfn class="decl field" id="_btree::bt_emap" title='_btree::bt_emap' data-ref="_btree::bt_emap" data-ref-filename="_btree..bt_emap">bt_emap</dfn>;		<i>/* R: end of mapped space */</i></td></tr>
<tr><th id="400">400</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>	  <dfn class="decl field" id="_btree::bt_msize" title='_btree::bt_msize' data-ref="_btree::bt_msize" data-ref-filename="_btree..bt_msize">bt_msize</dfn>;		<i>/* R: size of mapped region. */</i></td></tr>
<tr><th id="401">401</th><td></td></tr>
<tr><th id="402">402</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/db.h.html#recno_t" title='recno_t' data-type='uint32_t' data-ref="recno_t" data-ref-filename="recno_t">recno_t</a>	  <dfn class="decl field" id="_btree::bt_nrecs" title='_btree::bt_nrecs' data-ref="_btree::bt_nrecs" data-ref-filename="_btree..bt_nrecs">bt_nrecs</dfn>;		<i>/* R: number of records */</i></td></tr>
<tr><th id="403">403</th><td>	<a class="typedef" href="../../../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>	  <dfn class="decl field" id="_btree::bt_reclen" title='_btree::bt_reclen' data-ref="_btree::bt_reclen" data-ref-filename="_btree..bt_reclen">bt_reclen</dfn>;		<i>/* R: fixed record length */</i></td></tr>
<tr><th id="404">404</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a>	  <dfn class="decl field" id="_btree::bt_bval" title='_btree::bt_bval' data-ref="_btree::bt_bval" data-ref-filename="_btree..bt_bval">bt_bval</dfn>;		<i>/* R: delimiting byte/pad character */</i></td></tr>
<tr><th id="405">405</th><td></td></tr>
<tr><th id="406">406</th><td><i>/*</i></td></tr>
<tr><th id="407">407</th><td><i> * NB:</i></td></tr>
<tr><th id="408">408</th><td><i> * B_NODUPS and R_RECNO are stored on disk, and may not be changed.</i></td></tr>
<tr><th id="409">409</th><td><i> */</i></td></tr>
<tr><th id="410">410</th><td><u>#define	<dfn class="macro" id="_M/B_INMEM" data-ref="_M/B_INMEM">B_INMEM</dfn>		0x00001		/* in-memory tree */</u></td></tr>
<tr><th id="411">411</th><td><u>#define	<dfn class="macro" id="_M/B_METADIRTY" data-ref="_M/B_METADIRTY">B_METADIRTY</dfn>	0x00002		/* need to write metadata */</u></td></tr>
<tr><th id="412">412</th><td><u>#define	<dfn class="macro" id="_M/B_MODIFIED" data-ref="_M/B_MODIFIED">B_MODIFIED</dfn>	0x00004		/* tree modified */</u></td></tr>
<tr><th id="413">413</th><td><u>#define	<dfn class="macro" id="_M/B_NEEDSWAP" data-ref="_M/B_NEEDSWAP">B_NEEDSWAP</dfn>	0x00008		/* if byte order requires swapping */</u></td></tr>
<tr><th id="414">414</th><td><u>#define	<dfn class="macro" id="_M/B_RDONLY" data-ref="_M/B_RDONLY">B_RDONLY</dfn>	0x00010		/* read-only tree */</u></td></tr>
<tr><th id="415">415</th><td></td></tr>
<tr><th id="416">416</th><td><u>#define	<dfn class="macro" id="_M/B_NODUPS" data-ref="_M/B_NODUPS">B_NODUPS</dfn>	0x00020		/* no duplicate keys permitted */</u></td></tr>
<tr><th id="417">417</th><td><u>#define	<dfn class="macro" id="_M/R_RECNO" data-ref="_M/R_RECNO">R_RECNO</dfn>		0x00080		/* record oriented tree */</u></td></tr>
<tr><th id="418">418</th><td></td></tr>
<tr><th id="419">419</th><td><u>#define	<dfn class="macro" id="_M/R_CLOSEFP" data-ref="_M/R_CLOSEFP">R_CLOSEFP</dfn>	0x00040		/* opened a file pointer */</u></td></tr>
<tr><th id="420">420</th><td><u>#define	<dfn class="macro" id="_M/R_EOF" data-ref="_M/R_EOF">R_EOF</dfn>		0x00100		/* end of input file reached. */</u></td></tr>
<tr><th id="421">421</th><td><u>#define	<dfn class="macro" id="_M/R_FIXLEN" data-ref="_M/R_FIXLEN">R_FIXLEN</dfn>	0x00200		/* fixed length records */</u></td></tr>
<tr><th id="422">422</th><td><u>#define	<dfn class="macro" id="_M/R_MEMMAPPED" data-ref="_M/R_MEMMAPPED">R_MEMMAPPED</dfn>	0x00400		/* memory mapped file. */</u></td></tr>
<tr><th id="423">423</th><td><u>#define	<dfn class="macro" id="_M/R_INMEM" data-ref="_M/R_INMEM">R_INMEM</dfn>		0x00800		/* in-memory file */</u></td></tr>
<tr><th id="424">424</th><td><u>#define	<dfn class="macro" id="_M/R_MODIFIED" data-ref="_M/R_MODIFIED">R_MODIFIED</dfn>	0x01000		/* modified file */</u></td></tr>
<tr><th id="425">425</th><td><u>#define	<dfn class="macro" id="_M/R_RDONLY" data-ref="_M/R_RDONLY">R_RDONLY</dfn>	0x02000		/* read-only file */</u></td></tr>
<tr><th id="426">426</th><td></td></tr>
<tr><th id="427">427</th><td><u>#define	<dfn class="macro" id="_M/B_DB_LOCK" data-ref="_M/B_DB_LOCK">B_DB_LOCK</dfn>	0x04000		/* DB_LOCK specified. */</u></td></tr>
<tr><th id="428">428</th><td><u>#define	<dfn class="macro" id="_M/B_DB_SHMEM" data-ref="_M/B_DB_SHMEM">B_DB_SHMEM</dfn>	0x08000		/* DB_SHMEM specified. */</u></td></tr>
<tr><th id="429">429</th><td><u>#define	<dfn class="macro" id="_M/B_DB_TXN" data-ref="_M/B_DB_TXN">B_DB_TXN</dfn>	0x10000		/* DB_TXN specified. */</u></td></tr>
<tr><th id="430">430</th><td>	<a class="typedef" href="../../../../sys/sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="_btree::flags" title='_btree::flags' data-ref="_btree::flags" data-ref-filename="_btree..flags">flags</dfn>;</td></tr>
<tr><th id="431">431</th><td>} <dfn class="typedef" id="BTREE" title='BTREE' data-type='struct _btree' data-ref="BTREE" data-ref-filename="BTREE">BTREE</dfn>;</td></tr>
<tr><th id="432">432</th><td></td></tr>
<tr><th id="433">433</th><td><u>#include <a href="extern.h.html">"extern.h"</a></u></td></tr>
<tr><th id="434">434</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='bt_close.c.html'>netbsd/lib/libc/db/btree/bt_close.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
