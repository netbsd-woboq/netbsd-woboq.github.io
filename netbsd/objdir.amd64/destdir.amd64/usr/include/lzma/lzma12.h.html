<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>lzma12.h source code [netbsd/objdir.amd64/destdir.amd64/usr/include/lzma/lzma12.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/objdir.amd64/destdir.amd64/usr/include/lzma/lzma12.h'; var root_path = '../../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../..'>netbsd</a>/<a href='../../../..'>objdir.amd64</a>/<a href='../../..'>destdir.amd64</a>/<a href='../..'>usr</a>/<a href='..'>include</a>/<a href='./'>lzma</a>/<a href='lzma12.h.html'>lzma12.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i class="doc">/**</i></td></tr>
<tr><th id="2">2</th><td><i class="doc"> *<span class="command"> \file</span>        lzma/lzma12.h</i></td></tr>
<tr><th id="3">3</th><td><i class="doc"> * <span class="command">\brief</span>       LZMA1 and LZMA2 filters</i></td></tr>
<tr><th id="4">4</th><td><i class="doc"> */</i></td></tr>
<tr><th id="5">5</th><td></td></tr>
<tr><th id="6">6</th><td><i>/*</i></td></tr>
<tr><th id="7">7</th><td><i> * Author: Lasse Collin</i></td></tr>
<tr><th id="8">8</th><td><i> *</i></td></tr>
<tr><th id="9">9</th><td><i> * This file has been put into the public domain.</i></td></tr>
<tr><th id="10">10</th><td><i> * You can do whatever you want with this file.</i></td></tr>
<tr><th id="11">11</th><td><i> *</i></td></tr>
<tr><th id="12">12</th><td><i> * See ../lzma.h for information about liblzma as a whole.</i></td></tr>
<tr><th id="13">13</th><td><i> */</i></td></tr>
<tr><th id="14">14</th><td></td></tr>
<tr><th id="15">15</th><td><u>#<span data-ppcond="15">ifndef</span> <a class="macro" href="../lzma.h.html#289" data-ref="_M/LZMA_H_INTERNAL">LZMA_H_INTERNAL</a></u></td></tr>
<tr><th id="16">16</th><td><u>#	error Never include this file directly. Use &lt;lzma.h&gt; instead.</u></td></tr>
<tr><th id="17">17</th><td><u>#<span data-ppcond="15">endif</span></u></td></tr>
<tr><th id="18">18</th><td></td></tr>
<tr><th id="19">19</th><td></td></tr>
<tr><th id="20">20</th><td><i class="doc">/**</i></td></tr>
<tr><th id="21">21</th><td><i class="doc"> * <span class="command">\brief</span>       LZMA1 Filter ID</i></td></tr>
<tr><th id="22">22</th><td><i class="doc"> *</i></td></tr>
<tr><th id="23">23</th><td><i class="doc"> * LZMA1 is the very same thing as what was called just LZMA in LZMA Utils,</i></td></tr>
<tr><th id="24">24</th><td><i class="doc"> * 7-Zip, and LZMA SDK. It's called LZMA1 here to prevent developers from</i></td></tr>
<tr><th id="25">25</th><td><i class="doc"> * accidentally using LZMA when they actually want LZMA2.</i></td></tr>
<tr><th id="26">26</th><td><i class="doc"> *</i></td></tr>
<tr><th id="27">27</th><td><i class="doc"> * LZMA1 shouldn't be used for new applications unless you _really_ know</i></td></tr>
<tr><th id="28">28</th><td><i class="doc"> * what you are doing. LZMA2 is almost always a better choice.</i></td></tr>
<tr><th id="29">29</th><td><i class="doc"> */</i></td></tr>
<tr><th id="30">30</th><td><u>#define <dfn class="macro" id="_M/LZMA_FILTER_LZMA1" data-ref="_M/LZMA_FILTER_LZMA1">LZMA_FILTER_LZMA1</dfn>       LZMA_VLI_C(0x4000000000000001)</u></td></tr>
<tr><th id="31">31</th><td></td></tr>
<tr><th id="32">32</th><td><i class="doc">/**</i></td></tr>
<tr><th id="33">33</th><td><i class="doc"> * <span class="command">\brief</span>       LZMA2 Filter ID</i></td></tr>
<tr><th id="34">34</th><td><i class="doc"> *</i></td></tr>
<tr><th id="35">35</th><td><i class="doc"> * Usually you want this instead of LZMA1. Compared to LZMA1, LZMA2 adds</i></td></tr>
<tr><th id="36">36</th><td><i class="doc"> * support for LZMA_SYNC_FLUSH, uncompressed chunks (smaller expansion</i></td></tr>
<tr><th id="37">37</th><td><i class="doc"> * when trying to compress uncompressible data), possibility to change</i></td></tr>
<tr><th id="38">38</th><td><i class="doc"> * lc/lp/pb in the middle of encoding, and some other internal improvements.</i></td></tr>
<tr><th id="39">39</th><td><i class="doc"> */</i></td></tr>
<tr><th id="40">40</th><td><u>#define <dfn class="macro" id="_M/LZMA_FILTER_LZMA2" data-ref="_M/LZMA_FILTER_LZMA2">LZMA_FILTER_LZMA2</dfn>       LZMA_VLI_C(0x21)</u></td></tr>
<tr><th id="41">41</th><td></td></tr>
<tr><th id="42">42</th><td></td></tr>
<tr><th id="43">43</th><td><i class="doc">/**</i></td></tr>
<tr><th id="44">44</th><td><i class="doc"> * <span class="command">\brief</span>       Match finders</i></td></tr>
<tr><th id="45">45</th><td><i class="doc"> *</i></td></tr>
<tr><th id="46">46</th><td><i class="doc"> * Match finder has major effect on both speed and compression ratio.</i></td></tr>
<tr><th id="47">47</th><td><i class="doc"> * Usually hash chains are faster than binary trees.</i></td></tr>
<tr><th id="48">48</th><td><i class="doc"> *</i></td></tr>
<tr><th id="49">49</th><td><i class="doc"> * If you will use LZMA_SYNC_FLUSH often, the hash chains may be a better</i></td></tr>
<tr><th id="50">50</th><td><i class="doc"> * choice, because binary trees get much higher compression ratio penalty</i></td></tr>
<tr><th id="51">51</th><td><i class="doc"> * with LZMA_SYNC_FLUSH.</i></td></tr>
<tr><th id="52">52</th><td><i class="doc"> *</i></td></tr>
<tr><th id="53">53</th><td><i class="doc"> * The memory usage formulas are only rough estimates, which are closest to</i></td></tr>
<tr><th id="54">54</th><td><i class="doc"> * reality when dict_size is a power of two. The formulas are  more complex</i></td></tr>
<tr><th id="55">55</th><td><i class="doc"> * in reality, and can also change a little between liblzma versions. Use</i></td></tr>
<tr><th id="56">56</th><td><i class="doc"> * lzma_raw_encoder_memusage() to get more accurate estimate of memory usage.</i></td></tr>
<tr><th id="57">57</th><td><i class="doc"> */</i></td></tr>
<tr><th id="58">58</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="59">59</th><td>	<dfn class="enum" id="LZMA_MF_HC3" title='LZMA_MF_HC3' data-ref="LZMA_MF_HC3" data-ref-filename="LZMA_MF_HC3">LZMA_MF_HC3</dfn>     = <var>0x03</var>,</td></tr>
<tr><th id="60">60</th><td>		<i class="doc">/**&lt;</i></td></tr>
<tr><th id="61">61</th><td><i class="doc">		 * <span class="command">\brief</span>       Hash Chain with 2- and 3-byte hashing</i></td></tr>
<tr><th id="62">62</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="63">63</th><td><i class="doc">		 * Minimum nice_len: 3</i></td></tr>
<tr><th id="64">64</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="65">65</th><td><i class="doc">		 * Memory usage:</i></td></tr>
<tr><th id="66">66</th><td><i class="doc">		 *  - dict_size &lt;= 16 MiB: dict_size * 7.5</i></td></tr>
<tr><th id="67">67</th><td><i class="doc">		 *  - dict_size &gt; 16 MiB: dict_size * 5.5 + 64 MiB</i></td></tr>
<tr><th id="68">68</th><td><i class="doc">		 */</i></td></tr>
<tr><th id="69">69</th><td></td></tr>
<tr><th id="70">70</th><td>	<dfn class="enum" id="LZMA_MF_HC4" title='LZMA_MF_HC4' data-ref="LZMA_MF_HC4" data-ref-filename="LZMA_MF_HC4">LZMA_MF_HC4</dfn>     = <var>0x04</var>,</td></tr>
<tr><th id="71">71</th><td>		<i class="doc">/**&lt;</i></td></tr>
<tr><th id="72">72</th><td><i class="doc">		 * <span class="command">\brief</span>       Hash Chain with 2-, 3-, and 4-byte hashing</i></td></tr>
<tr><th id="73">73</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="74">74</th><td><i class="doc">		 * Minimum nice_len: 4</i></td></tr>
<tr><th id="75">75</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="76">76</th><td><i class="doc">		 * Memory usage:</i></td></tr>
<tr><th id="77">77</th><td><i class="doc">		 *  - dict_size &lt;= 32 MiB: dict_size * 7.5</i></td></tr>
<tr><th id="78">78</th><td><i class="doc">		 *  - dict_size &gt; 32 MiB: dict_size * 6.5</i></td></tr>
<tr><th id="79">79</th><td><i class="doc">		 */</i></td></tr>
<tr><th id="80">80</th><td></td></tr>
<tr><th id="81">81</th><td>	<dfn class="enum" id="LZMA_MF_BT2" title='LZMA_MF_BT2' data-ref="LZMA_MF_BT2" data-ref-filename="LZMA_MF_BT2">LZMA_MF_BT2</dfn>     = <var>0x12</var>,</td></tr>
<tr><th id="82">82</th><td>		<i class="doc">/**&lt;</i></td></tr>
<tr><th id="83">83</th><td><i class="doc">		 * <span class="command">\brief</span>       Binary Tree with 2-byte hashing</i></td></tr>
<tr><th id="84">84</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="85">85</th><td><i class="doc">		 * Minimum nice_len: 2</i></td></tr>
<tr><th id="86">86</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="87">87</th><td><i class="doc">		 * Memory usage: dict_size * 9.5</i></td></tr>
<tr><th id="88">88</th><td><i class="doc">		 */</i></td></tr>
<tr><th id="89">89</th><td></td></tr>
<tr><th id="90">90</th><td>	<dfn class="enum" id="LZMA_MF_BT3" title='LZMA_MF_BT3' data-ref="LZMA_MF_BT3" data-ref-filename="LZMA_MF_BT3">LZMA_MF_BT3</dfn>     = <var>0x13</var>,</td></tr>
<tr><th id="91">91</th><td>		<i class="doc">/**&lt;</i></td></tr>
<tr><th id="92">92</th><td><i class="doc">		 * <span class="command">\brief</span>       Binary Tree with 2- and 3-byte hashing</i></td></tr>
<tr><th id="93">93</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="94">94</th><td><i class="doc">		 * Minimum nice_len: 3</i></td></tr>
<tr><th id="95">95</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="96">96</th><td><i class="doc">		 * Memory usage:</i></td></tr>
<tr><th id="97">97</th><td><i class="doc">		 *  - dict_size &lt;= 16 MiB: dict_size * 11.5</i></td></tr>
<tr><th id="98">98</th><td><i class="doc">		 *  - dict_size &gt; 16 MiB: dict_size * 9.5 + 64 MiB</i></td></tr>
<tr><th id="99">99</th><td><i class="doc">		 */</i></td></tr>
<tr><th id="100">100</th><td></td></tr>
<tr><th id="101">101</th><td>	<dfn class="enum" id="LZMA_MF_BT4" title='LZMA_MF_BT4' data-ref="LZMA_MF_BT4" data-ref-filename="LZMA_MF_BT4">LZMA_MF_BT4</dfn>     = <var>0x14</var></td></tr>
<tr><th id="102">102</th><td>		<i class="doc">/**&lt;</i></td></tr>
<tr><th id="103">103</th><td><i class="doc">		 * <span class="command">\brief</span>       Binary Tree with 2-, 3-, and 4-byte hashing</i></td></tr>
<tr><th id="104">104</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="105">105</th><td><i class="doc">		 * Minimum nice_len: 4</i></td></tr>
<tr><th id="106">106</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="107">107</th><td><i class="doc">		 * Memory usage:</i></td></tr>
<tr><th id="108">108</th><td><i class="doc">		 *  - dict_size &lt;= 32 MiB: dict_size * 11.5</i></td></tr>
<tr><th id="109">109</th><td><i class="doc">		 *  - dict_size &gt; 32 MiB: dict_size * 10.5</i></td></tr>
<tr><th id="110">110</th><td><i class="doc">		 */</i></td></tr>
<tr><th id="111">111</th><td>} <dfn class="typedef" id="lzma_match_finder" title='lzma_match_finder' data-type='enum lzma_match_finder' data-ref="lzma_match_finder" data-ref-filename="lzma_match_finder">lzma_match_finder</dfn>;</td></tr>
<tr><th id="112">112</th><td></td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td><i class="doc">/**</i></td></tr>
<tr><th id="115">115</th><td><i class="doc"> * <span class="command">\brief</span>       Test if given match finder is supported</i></td></tr>
<tr><th id="116">116</th><td><i class="doc"> *</i></td></tr>
<tr><th id="117">117</th><td><i class="doc"> * Return true if the given match finder is supported by this liblzma build.</i></td></tr>
<tr><th id="118">118</th><td><i class="doc"> * Otherwise false is returned. It is safe to call this with a value that</i></td></tr>
<tr><th id="119">119</th><td><i class="doc"> * isn't listed in lzma_match_finder enumeration; the return value will be</i></td></tr>
<tr><th id="120">120</th><td><i class="doc"> * false.</i></td></tr>
<tr><th id="121">121</th><td><i class="doc"> *</i></td></tr>
<tr><th id="122">122</th><td><i class="doc"> * There is no way to list which match finders are available in this</i></td></tr>
<tr><th id="123">123</th><td><i class="doc"> * particular liblzma version and build. It would be useless, because</i></td></tr>
<tr><th id="124">124</th><td><i class="doc"> * a new match finder, which the application developer wasn't aware,</i></td></tr>
<tr><th id="125">125</th><td><i class="doc"> * could require giving additional options to the encoder that the older</i></td></tr>
<tr><th id="126">126</th><td><i class="doc"> * match finders don't need.</i></td></tr>
<tr><th id="127">127</th><td><i class="doc"> */</i></td></tr>
<tr><th id="128">128</th><td><b>extern</b> <a class="macro" href="../lzma.h.html#207" title=" lzma_bool" data-ref="_M/LZMA_API">LZMA_API</a>(<a class="typedef" href="base.h.html#lzma_bool" title='lzma_bool' data-type='unsigned char' data-ref="lzma_bool" data-ref-filename="lzma_bool">lzma_bool</a>) <dfn class="decl fn" id="lzma_mf_is_supported" title='lzma_mf_is_supported' data-ref="lzma_mf_is_supported" data-ref-filename="lzma_mf_is_supported">lzma_mf_is_supported</dfn>(<a class="typedef" href="#lzma_match_finder" title='lzma_match_finder' data-type='enum lzma_match_finder' data-ref="lzma_match_finder" data-ref-filename="lzma_match_finder">lzma_match_finder</a> <dfn class="local col3 decl" id="83match_finder" title='match_finder' data-type='lzma_match_finder' data-ref="83match_finder" data-ref-filename="83match_finder">match_finder</dfn>)</td></tr>
<tr><th id="129">129</th><td>		<a class="macro" href="../lzma.h.html#228" title="__attribute__((__nothrow__))" data-ref="_M/lzma_nothrow">lzma_nothrow</a> <a class="macro" href="../lzma.h.html#268" title="__attribute__((__const__))" data-ref="_M/lzma_attr_const">lzma_attr_const</a>;</td></tr>
<tr><th id="130">130</th><td></td></tr>
<tr><th id="131">131</th><td></td></tr>
<tr><th id="132">132</th><td><i class="doc">/**</i></td></tr>
<tr><th id="133">133</th><td><i class="doc"> * <span class="command">\brief</span>       Compression modes</i></td></tr>
<tr><th id="134">134</th><td><i class="doc"> *</i></td></tr>
<tr><th id="135">135</th><td><i class="doc"> * This selects the function used to analyze the data produced by the match</i></td></tr>
<tr><th id="136">136</th><td><i class="doc"> * finder.</i></td></tr>
<tr><th id="137">137</th><td><i class="doc"> */</i></td></tr>
<tr><th id="138">138</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="139">139</th><td>	<dfn class="enum" id="LZMA_MODE_FAST" title='LZMA_MODE_FAST' data-ref="LZMA_MODE_FAST" data-ref-filename="LZMA_MODE_FAST">LZMA_MODE_FAST</dfn> = <var>1</var>,</td></tr>
<tr><th id="140">140</th><td>		<i class="doc">/**&lt;</i></td></tr>
<tr><th id="141">141</th><td><i class="doc">		 * <span class="command">\brief</span>       Fast compression</i></td></tr>
<tr><th id="142">142</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="143">143</th><td><i class="doc">		 * Fast mode is usually at its best when combined with</i></td></tr>
<tr><th id="144">144</th><td><i class="doc">		 * a hash chain match finder.</i></td></tr>
<tr><th id="145">145</th><td><i class="doc">		 */</i></td></tr>
<tr><th id="146">146</th><td></td></tr>
<tr><th id="147">147</th><td>	<dfn class="enum" id="LZMA_MODE_NORMAL" title='LZMA_MODE_NORMAL' data-ref="LZMA_MODE_NORMAL" data-ref-filename="LZMA_MODE_NORMAL">LZMA_MODE_NORMAL</dfn> = <var>2</var></td></tr>
<tr><th id="148">148</th><td>		<i class="doc">/**&lt;</i></td></tr>
<tr><th id="149">149</th><td><i class="doc">		 * <span class="command">\brief</span>       Normal compression</i></td></tr>
<tr><th id="150">150</th><td><i class="doc">		 *</i></td></tr>
<tr><th id="151">151</th><td><i class="doc">		 * This is usually notably slower than fast mode. Use this</i></td></tr>
<tr><th id="152">152</th><td><i class="doc">		 * together with binary tree match finders to expose the</i></td></tr>
<tr><th id="153">153</th><td><i class="doc">		 * full potential of the LZMA1 or LZMA2 encoder.</i></td></tr>
<tr><th id="154">154</th><td><i class="doc">		 */</i></td></tr>
<tr><th id="155">155</th><td>} <dfn class="typedef" id="lzma_mode" title='lzma_mode' data-type='enum lzma_mode' data-ref="lzma_mode" data-ref-filename="lzma_mode">lzma_mode</dfn>;</td></tr>
<tr><th id="156">156</th><td></td></tr>
<tr><th id="157">157</th><td></td></tr>
<tr><th id="158">158</th><td><i class="doc">/**</i></td></tr>
<tr><th id="159">159</th><td><i class="doc"> * <span class="command">\brief</span>       Test if given compression mode is supported</i></td></tr>
<tr><th id="160">160</th><td><i class="doc"> *</i></td></tr>
<tr><th id="161">161</th><td><i class="doc"> * Return true if the given compression mode is supported by this liblzma</i></td></tr>
<tr><th id="162">162</th><td><i class="doc"> * build. Otherwise false is returned. It is safe to call this with a value</i></td></tr>
<tr><th id="163">163</th><td><i class="doc"> * that isn't listed in lzma_mode enumeration; the return value will be false.</i></td></tr>
<tr><th id="164">164</th><td><i class="doc"> *</i></td></tr>
<tr><th id="165">165</th><td><i class="doc"> * There is no way to list which modes are available in this particular</i></td></tr>
<tr><th id="166">166</th><td><i class="doc"> * liblzma version and build. It would be useless, because a new compression</i></td></tr>
<tr><th id="167">167</th><td><i class="doc"> * mode, which the application developer wasn't aware, could require giving</i></td></tr>
<tr><th id="168">168</th><td><i class="doc"> * additional options to the encoder that the older modes don't need.</i></td></tr>
<tr><th id="169">169</th><td><i class="doc"> */</i></td></tr>
<tr><th id="170">170</th><td><b>extern</b> <a class="macro" href="../lzma.h.html#207" title=" lzma_bool" data-ref="_M/LZMA_API">LZMA_API</a>(<a class="typedef" href="base.h.html#lzma_bool" title='lzma_bool' data-type='unsigned char' data-ref="lzma_bool" data-ref-filename="lzma_bool">lzma_bool</a>) <dfn class="decl fn" id="lzma_mode_is_supported" title='lzma_mode_is_supported' data-ref="lzma_mode_is_supported" data-ref-filename="lzma_mode_is_supported">lzma_mode_is_supported</dfn>(<a class="typedef" href="#lzma_mode" title='lzma_mode' data-type='enum lzma_mode' data-ref="lzma_mode" data-ref-filename="lzma_mode">lzma_mode</a> <dfn class="local col4 decl" id="84mode" title='mode' data-type='lzma_mode' data-ref="84mode" data-ref-filename="84mode">mode</dfn>)</td></tr>
<tr><th id="171">171</th><td>		<a class="macro" href="../lzma.h.html#228" title="__attribute__((__nothrow__))" data-ref="_M/lzma_nothrow">lzma_nothrow</a> <a class="macro" href="../lzma.h.html#268" title="__attribute__((__const__))" data-ref="_M/lzma_attr_const">lzma_attr_const</a>;</td></tr>
<tr><th id="172">172</th><td></td></tr>
<tr><th id="173">173</th><td></td></tr>
<tr><th id="174">174</th><td><i class="doc">/**</i></td></tr>
<tr><th id="175">175</th><td><i class="doc"> * <span class="command">\brief</span>       Options specific to the LZMA1 and LZMA2 filters</i></td></tr>
<tr><th id="176">176</th><td><i class="doc"> *</i></td></tr>
<tr><th id="177">177</th><td><i class="doc"> * Since LZMA1 and LZMA2 share most of the code, it's simplest to share</i></td></tr>
<tr><th id="178">178</th><td><i class="doc"> * the options structure too. For encoding, all but the reserved variables</i></td></tr>
<tr><th id="179">179</th><td><i class="doc"> * need to be initialized unless specifically mentioned otherwise.</i></td></tr>
<tr><th id="180">180</th><td><i class="doc"> * lzma_lzma_preset() can be used to get a good starting point.</i></td></tr>
<tr><th id="181">181</th><td><i class="doc"> *</i></td></tr>
<tr><th id="182">182</th><td><i class="doc"> * For raw decoding, both LZMA1 and LZMA2 need dict_size, preset_dict, and</i></td></tr>
<tr><th id="183">183</th><td><i class="doc"> * preset_dict_size (if preset_dict != NULL). LZMA1 needs also lc, lp, and pb.</i></td></tr>
<tr><th id="184">184</th><td><i class="doc"> */</i></td></tr>
<tr><th id="185">185</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="186">186</th><td>	<i class="doc">/**</i></td></tr>
<tr><th id="187">187</th><td><i class="doc">	 * <span class="command">\brief</span>       Dictionary size in bytes</i></td></tr>
<tr><th id="188">188</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="189">189</th><td><i class="doc">	 * Dictionary size indicates how many bytes of the recently processed</i></td></tr>
<tr><th id="190">190</th><td><i class="doc">	 * uncompressed data is kept in memory. One method to reduce size of</i></td></tr>
<tr><th id="191">191</th><td><i class="doc">	 * the uncompressed data is to store distance-length pairs, which</i></td></tr>
<tr><th id="192">192</th><td><i class="doc">	 * indicate what data to repeat from the dictionary buffer. Thus,</i></td></tr>
<tr><th id="193">193</th><td><i class="doc">	 * the bigger the dictionary, the better the compression ratio</i></td></tr>
<tr><th id="194">194</th><td><i class="doc">	 * usually is.</i></td></tr>
<tr><th id="195">195</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="196">196</th><td><i class="doc">	 * Maximum size of the dictionary depends on multiple things:</i></td></tr>
<tr><th id="197">197</th><td><i class="doc">	 *  - Memory usage limit</i></td></tr>
<tr><th id="198">198</th><td><i class="doc">	 *  - Available address space (not a problem on 64-bit systems)</i></td></tr>
<tr><th id="199">199</th><td><i class="doc">	 *  - Selected match finder (encoder only)</i></td></tr>
<tr><th id="200">200</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="201">201</th><td><i class="doc">	 * Currently the maximum dictionary size for encoding is 1.5 GiB</i></td></tr>
<tr><th id="202">202</th><td><i class="doc">	 * (i.e. (UINT32_C(1) &lt;&lt; 30) + (UINT32_C(1) &lt;&lt; 29)) even on 64-bit</i></td></tr>
<tr><th id="203">203</th><td><i class="doc">	 * systems for certain match finder implementation reasons. In the</i></td></tr>
<tr><th id="204">204</th><td><i class="doc">	 * future, there may be match finders that support bigger</i></td></tr>
<tr><th id="205">205</th><td><i class="doc">	 * dictionaries.</i></td></tr>
<tr><th id="206">206</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="207">207</th><td><i class="doc">	 * Decoder already supports dictionaries up to 4 GiB - 1 B (i.e.</i></td></tr>
<tr><th id="208">208</th><td><i class="doc">	 * UINT32_MAX), so increasing the maximum dictionary size of the</i></td></tr>
<tr><th id="209">209</th><td><i class="doc">	 * encoder won't cause problems for old decoders.</i></td></tr>
<tr><th id="210">210</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="211">211</th><td><i class="doc">	 * Because extremely small dictionaries sizes would have unneeded</i></td></tr>
<tr><th id="212">212</th><td><i class="doc">	 * overhead in the decoder, the minimum dictionary size is 4096 bytes.</i></td></tr>
<tr><th id="213">213</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="214">214</th><td><i class="doc">	 * <span class="command">\note</span>        When decoding, too big dictionary does no other harm</i></td></tr>
<tr><th id="215">215</th><td><i class="doc">	 *              than wasting memory.</i></td></tr>
<tr><th id="216">216</th><td><i class="doc">	 */</i></td></tr>
<tr><th id="217">217</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::dict_size" title='(anonymous struct)::dict_size' data-ref="(anonymous)::dict_size" data-ref-filename="(anonymous)..dict_size">dict_size</dfn>;</td></tr>
<tr><th id="218">218</th><td><u>#	define <dfn class="macro" id="_M/LZMA_DICT_SIZE_MIN" data-ref="_M/LZMA_DICT_SIZE_MIN">LZMA_DICT_SIZE_MIN</dfn>       UINT32_C(4096)</u></td></tr>
<tr><th id="219">219</th><td><u>#	define <dfn class="macro" id="_M/LZMA_DICT_SIZE_DEFAULT" data-ref="_M/LZMA_DICT_SIZE_DEFAULT">LZMA_DICT_SIZE_DEFAULT</dfn>   (UINT32_C(1) &lt;&lt; 23)</u></td></tr>
<tr><th id="220">220</th><td></td></tr>
<tr><th id="221">221</th><td>	<i class="doc">/**</i></td></tr>
<tr><th id="222">222</th><td><i class="doc">	 * <span class="command">\brief</span>       Pointer to an initial dictionary</i></td></tr>
<tr><th id="223">223</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="224">224</th><td><i class="doc">	 * It is possible to initialize the LZ77 history window using</i></td></tr>
<tr><th id="225">225</th><td><i class="doc">	 * a preset dictionary. It is useful when compressing many</i></td></tr>
<tr><th id="226">226</th><td><i class="doc">	 * similar, relatively small chunks of data independently from</i></td></tr>
<tr><th id="227">227</th><td><i class="doc">	 * each other. The preset dictionary should contain typical</i></td></tr>
<tr><th id="228">228</th><td><i class="doc">	 * strings that occur in the files being compressed. The most</i></td></tr>
<tr><th id="229">229</th><td><i class="doc">	 * probable strings should be near the end of the preset dictionary.</i></td></tr>
<tr><th id="230">230</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="231">231</th><td><i class="doc">	 * This feature should be used only in special situations. For</i></td></tr>
<tr><th id="232">232</th><td><i class="doc">	 * now, it works correctly only with raw encoding and decoding.</i></td></tr>
<tr><th id="233">233</th><td><i class="doc">	 * Currently none of the container formats supported by</i></td></tr>
<tr><th id="234">234</th><td><i class="doc">	 * liblzma allow preset dictionary when decoding, thus if</i></td></tr>
<tr><th id="235">235</th><td><i class="doc">	 * you create a .xz or .lzma file with preset dictionary, it</i></td></tr>
<tr><th id="236">236</th><td><i class="doc">	 * cannot be decoded with the regular decoder functions. In the</i></td></tr>
<tr><th id="237">237</th><td><i class="doc">	 * future, the .xz format will likely get support for preset</i></td></tr>
<tr><th id="238">238</th><td><i class="doc">	 * dictionary though.</i></td></tr>
<tr><th id="239">239</th><td><i class="doc">	 */</i></td></tr>
<tr><th id="240">240</th><td>	<em>const</em> <a class="typedef" href="../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> *<dfn class="decl field" id="(anonymous)::preset_dict" title='(anonymous struct)::preset_dict' data-ref="(anonymous)::preset_dict" data-ref-filename="(anonymous)..preset_dict">preset_dict</dfn>;</td></tr>
<tr><th id="241">241</th><td></td></tr>
<tr><th id="242">242</th><td>	<i class="doc">/**</i></td></tr>
<tr><th id="243">243</th><td><i class="doc">	 * <span class="command">\brief</span>       Size of the preset dictionary</i></td></tr>
<tr><th id="244">244</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="245">245</th><td><i class="doc">	 * Specifies the size of the preset dictionary. If the size is</i></td></tr>
<tr><th id="246">246</th><td><i class="doc">	 * bigger than dict_size, only the last dict_size bytes are</i></td></tr>
<tr><th id="247">247</th><td><i class="doc">	 * processed.</i></td></tr>
<tr><th id="248">248</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="249">249</th><td><i class="doc">	 * This variable is read only when preset_dict is not NULL.</i></td></tr>
<tr><th id="250">250</th><td><i class="doc">	 * If preset_dict is not NULL but preset_dict_size is zero,</i></td></tr>
<tr><th id="251">251</th><td><i class="doc">	 * no preset dictionary is used (identical to only setting</i></td></tr>
<tr><th id="252">252</th><td><i class="doc">	 * preset_dict to NULL).</i></td></tr>
<tr><th id="253">253</th><td><i class="doc">	 */</i></td></tr>
<tr><th id="254">254</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::preset_dict_size" title='(anonymous struct)::preset_dict_size' data-ref="(anonymous)::preset_dict_size" data-ref-filename="(anonymous)..preset_dict_size">preset_dict_size</dfn>;</td></tr>
<tr><th id="255">255</th><td></td></tr>
<tr><th id="256">256</th><td>	<i class="doc">/**</i></td></tr>
<tr><th id="257">257</th><td><i class="doc">	 * <span class="command">\brief</span>       Number of literal context bits</i></td></tr>
<tr><th id="258">258</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="259">259</th><td><i class="doc">	 * How many of the highest bits of the previous uncompressed</i></td></tr>
<tr><th id="260">260</th><td><i class="doc">	 * eight-bit byte (also known as `literal') are taken into</i></td></tr>
<tr><th id="261">261</th><td><i class="doc">	 * account when predicting the bits of the next literal.</i></td></tr>
<tr><th id="262">262</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="263">263</th><td><i class="doc">	 * E.g. in typical English text, an upper-case letter is</i></td></tr>
<tr><th id="264">264</th><td><i class="doc">	 * often followed by a lower-case letter, and a lower-case</i></td></tr>
<tr><th id="265">265</th><td><i class="doc">	 * letter is usually followed by another lower-case letter.</i></td></tr>
<tr><th id="266">266</th><td><i class="doc">	 * In the US-ASCII character set, the highest three bits are 010</i></td></tr>
<tr><th id="267">267</th><td><i class="doc">	 * for upper-case letters and 011 for lower-case letters.</i></td></tr>
<tr><th id="268">268</th><td><i class="doc">	 * When lc is at least 3, the literal coding can take advantage of</i></td></tr>
<tr><th id="269">269</th><td><i class="doc">	 * this property in the uncompressed data.</i></td></tr>
<tr><th id="270">270</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="271">271</th><td><i class="doc">	 * There is a limit that applies to literal context bits and literal</i></td></tr>
<tr><th id="272">272</th><td><i class="doc">	 * position bits together: lc + lp &lt;= 4. Without this limit the</i></td></tr>
<tr><th id="273">273</th><td><i class="doc">	 * decoding could become very slow, which could have security related</i></td></tr>
<tr><th id="274">274</th><td><i class="doc">	 * results in some cases like email servers doing virus scanning.</i></td></tr>
<tr><th id="275">275</th><td><i class="doc">	 * This limit also simplifies the internal implementation in liblzma.</i></td></tr>
<tr><th id="276">276</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="277">277</th><td><i class="doc">	 * There may be LZMA1 streams that have lc + lp &gt; 4 (maximum possible</i></td></tr>
<tr><th id="278">278</th><td><i class="doc">	 * lc would be 8). It is not possible to decode such streams with</i></td></tr>
<tr><th id="279">279</th><td><i class="doc">	 * liblzma.</i></td></tr>
<tr><th id="280">280</th><td><i class="doc">	 */</i></td></tr>
<tr><th id="281">281</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::lc" title='(anonymous struct)::lc' data-ref="(anonymous)::lc" data-ref-filename="(anonymous)..lc">lc</dfn>;</td></tr>
<tr><th id="282">282</th><td><u>#	define <dfn class="macro" id="_M/LZMA_LCLP_MIN" data-ref="_M/LZMA_LCLP_MIN">LZMA_LCLP_MIN</dfn>    0</u></td></tr>
<tr><th id="283">283</th><td><u>#	define <dfn class="macro" id="_M/LZMA_LCLP_MAX" data-ref="_M/LZMA_LCLP_MAX">LZMA_LCLP_MAX</dfn>    4</u></td></tr>
<tr><th id="284">284</th><td><u>#	define <dfn class="macro" id="_M/LZMA_LC_DEFAULT" data-ref="_M/LZMA_LC_DEFAULT">LZMA_LC_DEFAULT</dfn>  3</u></td></tr>
<tr><th id="285">285</th><td></td></tr>
<tr><th id="286">286</th><td>	<i class="doc">/**</i></td></tr>
<tr><th id="287">287</th><td><i class="doc">	 * <span class="command">\brief</span>       Number of literal position bits</i></td></tr>
<tr><th id="288">288</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="289">289</th><td><i class="doc">	 * lp affects what kind of alignment in the uncompressed data is</i></td></tr>
<tr><th id="290">290</th><td><i class="doc">	 * assumed when encoding literals. A literal is a single 8-bit byte.</i></td></tr>
<tr><th id="291">291</th><td><i class="doc">	 * See pb below for more information about alignment.</i></td></tr>
<tr><th id="292">292</th><td><i class="doc">	 */</i></td></tr>
<tr><th id="293">293</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::lp" title='(anonymous struct)::lp' data-ref="(anonymous)::lp" data-ref-filename="(anonymous)..lp">lp</dfn>;</td></tr>
<tr><th id="294">294</th><td><u>#	define <dfn class="macro" id="_M/LZMA_LP_DEFAULT" data-ref="_M/LZMA_LP_DEFAULT">LZMA_LP_DEFAULT</dfn>  0</u></td></tr>
<tr><th id="295">295</th><td></td></tr>
<tr><th id="296">296</th><td>	<i class="doc">/**</i></td></tr>
<tr><th id="297">297</th><td><i class="doc">	 * <span class="command">\brief</span>       Number of position bits</i></td></tr>
<tr><th id="298">298</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="299">299</th><td><i class="doc">	 * pb affects what kind of alignment in the uncompressed data is</i></td></tr>
<tr><th id="300">300</th><td><i class="doc">	 * assumed in general. The default means four-byte alignment</i></td></tr>
<tr><th id="301">301</th><td><i class="doc">	 * (2^ pb =2^2=4), which is often a good choice when there's</i></td></tr>
<tr><th id="302">302</th><td><i class="doc">	 * no better guess.</i></td></tr>
<tr><th id="303">303</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="304">304</th><td><i class="doc">	 * When the aligment is known, setting pb accordingly may reduce</i></td></tr>
<tr><th id="305">305</th><td><i class="doc">	 * the file size a little. E.g. with text files having one-byte</i></td></tr>
<tr><th id="306">306</th><td><i class="doc">	 * alignment (US-ASCII, ISO-8859-*, UTF-8), setting pb=0 can</i></td></tr>
<tr><th id="307">307</th><td><i class="doc">	 * improve compression slightly. For UTF-16 text, pb=1 is a good</i></td></tr>
<tr><th id="308">308</th><td><i class="doc">	 * choice. If the alignment is an odd number like 3 bytes, pb=0</i></td></tr>
<tr><th id="309">309</th><td><i class="doc">	 * might be the best choice.</i></td></tr>
<tr><th id="310">310</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="311">311</th><td><i class="doc">	 * Even though the assumed alignment can be adjusted with pb and</i></td></tr>
<tr><th id="312">312</th><td><i class="doc">	 * lp, LZMA1 and LZMA2 still slightly favor 16-byte alignment.</i></td></tr>
<tr><th id="313">313</th><td><i class="doc">	 * It might be worth taking into account when designing file formats</i></td></tr>
<tr><th id="314">314</th><td><i class="doc">	 * that are likely to be often compressed with LZMA1 or LZMA2.</i></td></tr>
<tr><th id="315">315</th><td><i class="doc">	 */</i></td></tr>
<tr><th id="316">316</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::pb" title='(anonymous struct)::pb' data-ref="(anonymous)::pb" data-ref-filename="(anonymous)..pb">pb</dfn>;</td></tr>
<tr><th id="317">317</th><td><u>#	define <dfn class="macro" id="_M/LZMA_PB_MIN" data-ref="_M/LZMA_PB_MIN">LZMA_PB_MIN</dfn>      0</u></td></tr>
<tr><th id="318">318</th><td><u>#	define <dfn class="macro" id="_M/LZMA_PB_MAX" data-ref="_M/LZMA_PB_MAX">LZMA_PB_MAX</dfn>      4</u></td></tr>
<tr><th id="319">319</th><td><u>#	define <dfn class="macro" id="_M/LZMA_PB_DEFAULT" data-ref="_M/LZMA_PB_DEFAULT">LZMA_PB_DEFAULT</dfn>  2</u></td></tr>
<tr><th id="320">320</th><td></td></tr>
<tr><th id="321">321</th><td>	<i class="doc">/** Compression mode */</i></td></tr>
<tr><th id="322">322</th><td>	<a class="typedef" href="#lzma_mode" title='lzma_mode' data-type='enum lzma_mode' data-ref="lzma_mode" data-ref-filename="lzma_mode">lzma_mode</a> <dfn class="decl field" id="(anonymous)::mode" title='(anonymous struct)::mode' data-ref="(anonymous)::mode" data-ref-filename="(anonymous)..mode">mode</dfn>;</td></tr>
<tr><th id="323">323</th><td></td></tr>
<tr><th id="324">324</th><td>	<i class="doc">/**</i></td></tr>
<tr><th id="325">325</th><td><i class="doc">	 * <span class="command">\brief</span>       Nice length of a match</i></td></tr>
<tr><th id="326">326</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="327">327</th><td><i class="doc">	 * This determines how many bytes the encoder compares from the match</i></td></tr>
<tr><th id="328">328</th><td><i class="doc">	 * candidates when looking for the best match. Once a match of at</i></td></tr>
<tr><th id="329">329</th><td><i class="doc">	 * least nice_len bytes long is found, the encoder stops looking for</i></td></tr>
<tr><th id="330">330</th><td><i class="doc">	 * better candidates and encodes the match. (Naturally, if the found</i></td></tr>
<tr><th id="331">331</th><td><i class="doc">	 * match is actually longer than nice_len, the actual length is</i></td></tr>
<tr><th id="332">332</th><td><i class="doc">	 * encoded; it's not truncated to nice_len.)</i></td></tr>
<tr><th id="333">333</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="334">334</th><td><i class="doc">	 * Bigger values usually increase the compression ratio and</i></td></tr>
<tr><th id="335">335</th><td><i class="doc">	 * compression time. For most files, 32 to 128 is a good value,</i></td></tr>
<tr><th id="336">336</th><td><i class="doc">	 * which gives very good compression ratio at good speed.</i></td></tr>
<tr><th id="337">337</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="338">338</th><td><i class="doc">	 * The exact minimum value depends on the match finder. The maximum</i></td></tr>
<tr><th id="339">339</th><td><i class="doc">	 * is 273, which is the maximum length of a match that LZMA1 and</i></td></tr>
<tr><th id="340">340</th><td><i class="doc">	 * LZMA2 can encode.</i></td></tr>
<tr><th id="341">341</th><td><i class="doc">	 */</i></td></tr>
<tr><th id="342">342</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::nice_len" title='(anonymous struct)::nice_len' data-ref="(anonymous)::nice_len" data-ref-filename="(anonymous)..nice_len">nice_len</dfn>;</td></tr>
<tr><th id="343">343</th><td></td></tr>
<tr><th id="344">344</th><td>	<i class="doc">/** Match finder ID */</i></td></tr>
<tr><th id="345">345</th><td>	<a class="typedef" href="#lzma_match_finder" title='lzma_match_finder' data-type='enum lzma_match_finder' data-ref="lzma_match_finder" data-ref-filename="lzma_match_finder">lzma_match_finder</a> <dfn class="decl field" id="(anonymous)::mf" title='(anonymous struct)::mf' data-ref="(anonymous)::mf" data-ref-filename="(anonymous)..mf">mf</dfn>;</td></tr>
<tr><th id="346">346</th><td></td></tr>
<tr><th id="347">347</th><td>	<i class="doc">/**</i></td></tr>
<tr><th id="348">348</th><td><i class="doc">	 * <span class="command">\brief</span>       Maximum search depth in the match finder</i></td></tr>
<tr><th id="349">349</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="350">350</th><td><i class="doc">	 * For every input byte, match finder searches through the hash chain</i></td></tr>
<tr><th id="351">351</th><td><i class="doc">	 * or binary tree in a loop, each iteration going one step deeper in</i></td></tr>
<tr><th id="352">352</th><td><i class="doc">	 * the chain or tree. The searching stops if</i></td></tr>
<tr><th id="353">353</th><td><i class="doc">	 *  - a match of at least nice_len bytes long is found;</i></td></tr>
<tr><th id="354">354</th><td><i class="doc">	 *  - all match candidates from the hash chain or binary tree have</i></td></tr>
<tr><th id="355">355</th><td><i class="doc">	 *    been checked; or</i></td></tr>
<tr><th id="356">356</th><td><i class="doc">	 *  - maximum search depth is reached.</i></td></tr>
<tr><th id="357">357</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="358">358</th><td><i class="doc">	 * Maximum search depth is needed to prevent the match finder from</i></td></tr>
<tr><th id="359">359</th><td><i class="doc">	 * wasting too much time in case there are lots of short match</i></td></tr>
<tr><th id="360">360</th><td><i class="doc">	 * candidates. On the other hand, stopping the search before all</i></td></tr>
<tr><th id="361">361</th><td><i class="doc">	 * candidates have been checked can reduce compression ratio.</i></td></tr>
<tr><th id="362">362</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="363">363</th><td><i class="doc">	 * Setting depth to zero tells liblzma to use an automatic default</i></td></tr>
<tr><th id="364">364</th><td><i class="doc">	 * value, that depends on the selected match finder and nice_len.</i></td></tr>
<tr><th id="365">365</th><td><i class="doc">	 * The default is in the range [4, 200] or so (it may vary between</i></td></tr>
<tr><th id="366">366</th><td><i class="doc">	 * liblzma versions).</i></td></tr>
<tr><th id="367">367</th><td><i class="doc">	 *</i></td></tr>
<tr><th id="368">368</th><td><i class="doc">	 * Using a bigger depth value than the default can increase</i></td></tr>
<tr><th id="369">369</th><td><i class="doc">	 * compression ratio in some cases. There is no strict maximum value,</i></td></tr>
<tr><th id="370">370</th><td><i class="doc">	 * but high values (thousands or millions) should be used with care:</i></td></tr>
<tr><th id="371">371</th><td><i class="doc">	 * the encoder could remain fast enough with typical input, but</i></td></tr>
<tr><th id="372">372</th><td><i class="doc">	 * malicious input could cause the match finder to slow down</i></td></tr>
<tr><th id="373">373</th><td><i class="doc">	 * dramatically, possibly creating a denial of service attack.</i></td></tr>
<tr><th id="374">374</th><td><i class="doc">	 */</i></td></tr>
<tr><th id="375">375</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::depth" title='(anonymous struct)::depth' data-ref="(anonymous)::depth" data-ref-filename="(anonymous)..depth">depth</dfn>;</td></tr>
<tr><th id="376">376</th><td></td></tr>
<tr><th id="377">377</th><td>	<i>/*</i></td></tr>
<tr><th id="378">378</th><td><i>	 * Reserved space to allow possible future extensions without</i></td></tr>
<tr><th id="379">379</th><td><i>	 * breaking the ABI. You should not touch these, because the names</i></td></tr>
<tr><th id="380">380</th><td><i>	 * of these variables may change. These are and will never be used</i></td></tr>
<tr><th id="381">381</th><td><i>	 * with the currently supported options, so it is safe to leave these</i></td></tr>
<tr><th id="382">382</th><td><i>	 * uninitialized.</i></td></tr>
<tr><th id="383">383</th><td><i>	 */</i></td></tr>
<tr><th id="384">384</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::reserved_int1" title='(anonymous struct)::reserved_int1' data-ref="(anonymous)::reserved_int1" data-ref-filename="(anonymous)..reserved_int1">reserved_int1</dfn>;</td></tr>
<tr><th id="385">385</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::reserved_int2" title='(anonymous struct)::reserved_int2' data-ref="(anonymous)::reserved_int2" data-ref-filename="(anonymous)..reserved_int2">reserved_int2</dfn>;</td></tr>
<tr><th id="386">386</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::reserved_int3" title='(anonymous struct)::reserved_int3' data-ref="(anonymous)::reserved_int3" data-ref-filename="(anonymous)..reserved_int3">reserved_int3</dfn>;</td></tr>
<tr><th id="387">387</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::reserved_int4" title='(anonymous struct)::reserved_int4' data-ref="(anonymous)::reserved_int4" data-ref-filename="(anonymous)..reserved_int4">reserved_int4</dfn>;</td></tr>
<tr><th id="388">388</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::reserved_int5" title='(anonymous struct)::reserved_int5' data-ref="(anonymous)::reserved_int5" data-ref-filename="(anonymous)..reserved_int5">reserved_int5</dfn>;</td></tr>
<tr><th id="389">389</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::reserved_int6" title='(anonymous struct)::reserved_int6' data-ref="(anonymous)::reserved_int6" data-ref-filename="(anonymous)..reserved_int6">reserved_int6</dfn>;</td></tr>
<tr><th id="390">390</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::reserved_int7" title='(anonymous struct)::reserved_int7' data-ref="(anonymous)::reserved_int7" data-ref-filename="(anonymous)..reserved_int7">reserved_int7</dfn>;</td></tr>
<tr><th id="391">391</th><td>	<a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="(anonymous)::reserved_int8" title='(anonymous struct)::reserved_int8' data-ref="(anonymous)::reserved_int8" data-ref-filename="(anonymous)..reserved_int8">reserved_int8</dfn>;</td></tr>
<tr><th id="392">392</th><td>	<a class="typedef" href="base.h.html#lzma_reserved_enum" title='lzma_reserved_enum' data-type='enum lzma_reserved_enum' data-ref="lzma_reserved_enum" data-ref-filename="lzma_reserved_enum">lzma_reserved_enum</a> <dfn class="decl field" id="(anonymous)::reserved_enum1" title='(anonymous struct)::reserved_enum1' data-ref="(anonymous)::reserved_enum1" data-ref-filename="(anonymous)..reserved_enum1">reserved_enum1</dfn>;</td></tr>
<tr><th id="393">393</th><td>	<a class="typedef" href="base.h.html#lzma_reserved_enum" title='lzma_reserved_enum' data-type='enum lzma_reserved_enum' data-ref="lzma_reserved_enum" data-ref-filename="lzma_reserved_enum">lzma_reserved_enum</a> <dfn class="decl field" id="(anonymous)::reserved_enum2" title='(anonymous struct)::reserved_enum2' data-ref="(anonymous)::reserved_enum2" data-ref-filename="(anonymous)..reserved_enum2">reserved_enum2</dfn>;</td></tr>
<tr><th id="394">394</th><td>	<a class="typedef" href="base.h.html#lzma_reserved_enum" title='lzma_reserved_enum' data-type='enum lzma_reserved_enum' data-ref="lzma_reserved_enum" data-ref-filename="lzma_reserved_enum">lzma_reserved_enum</a> <dfn class="decl field" id="(anonymous)::reserved_enum3" title='(anonymous struct)::reserved_enum3' data-ref="(anonymous)::reserved_enum3" data-ref-filename="(anonymous)..reserved_enum3">reserved_enum3</dfn>;</td></tr>
<tr><th id="395">395</th><td>	<a class="typedef" href="base.h.html#lzma_reserved_enum" title='lzma_reserved_enum' data-type='enum lzma_reserved_enum' data-ref="lzma_reserved_enum" data-ref-filename="lzma_reserved_enum">lzma_reserved_enum</a> <dfn class="decl field" id="(anonymous)::reserved_enum4" title='(anonymous struct)::reserved_enum4' data-ref="(anonymous)::reserved_enum4" data-ref-filename="(anonymous)..reserved_enum4">reserved_enum4</dfn>;</td></tr>
<tr><th id="396">396</th><td>	<em>void</em> *<dfn class="decl field" id="(anonymous)::reserved_ptr1" title='(anonymous struct)::reserved_ptr1' data-ref="(anonymous)::reserved_ptr1" data-ref-filename="(anonymous)..reserved_ptr1">reserved_ptr1</dfn>;</td></tr>
<tr><th id="397">397</th><td>	<em>void</em> *<dfn class="decl field" id="(anonymous)::reserved_ptr2" title='(anonymous struct)::reserved_ptr2' data-ref="(anonymous)::reserved_ptr2" data-ref-filename="(anonymous)..reserved_ptr2">reserved_ptr2</dfn>;</td></tr>
<tr><th id="398">398</th><td></td></tr>
<tr><th id="399">399</th><td>} <dfn class="typedef" id="lzma_options_lzma" title='lzma_options_lzma' data-type='struct lzma_options_lzma' data-ref="lzma_options_lzma" data-ref-filename="lzma_options_lzma">lzma_options_lzma</dfn>;</td></tr>
<tr><th id="400">400</th><td></td></tr>
<tr><th id="401">401</th><td></td></tr>
<tr><th id="402">402</th><td><i class="doc">/**</i></td></tr>
<tr><th id="403">403</th><td><i class="doc"> * <span class="command">\brief</span>       Set a compression preset to lzma_options_lzma structure</i></td></tr>
<tr><th id="404">404</th><td><i class="doc"> *</i></td></tr>
<tr><th id="405">405</th><td><i class="doc"> * 0 is the fastest and 9 is the slowest. These match the switches -0 .. -9</i></td></tr>
<tr><th id="406">406</th><td><i class="doc"> * of the xz command line tool. In addition, it is possible to bitwise-or</i></td></tr>
<tr><th id="407">407</th><td><i class="doc"> * flags to the preset. Currently only LZMA_PRESET_EXTREME is supported.</i></td></tr>
<tr><th id="408">408</th><td><i class="doc"> * The flags are defined in container.h, because the flags are used also</i></td></tr>
<tr><th id="409">409</th><td><i class="doc"> * with lzma_easy_encoder().</i></td></tr>
<tr><th id="410">410</th><td><i class="doc"> *</i></td></tr>
<tr><th id="411">411</th><td><i class="doc"> * The preset values are subject to changes between liblzma versions.</i></td></tr>
<tr><th id="412">412</th><td><i class="doc"> *</i></td></tr>
<tr><th id="413">413</th><td><i class="doc"> * This function is available only if LZMA1 or LZMA2 encoder has been enabled</i></td></tr>
<tr><th id="414">414</th><td><i class="doc"> * when building liblzma.</i></td></tr>
<tr><th id="415">415</th><td><i class="doc"> *</i></td></tr>
<tr><th id="416">416</th><td><i class="doc"> * <span class="command">\return</span>      On success, false is returned. If the preset is not</i></td></tr>
<tr><th id="417">417</th><td><i class="doc"> *              supported, true is returned.</i></td></tr>
<tr><th id="418">418</th><td><i class="doc"> */</i></td></tr>
<tr><th id="419">419</th><td><b>extern</b> <a class="macro" href="../lzma.h.html#207" title=" lzma_bool" data-ref="_M/LZMA_API">LZMA_API</a>(<a class="typedef" href="base.h.html#lzma_bool" title='lzma_bool' data-type='unsigned char' data-ref="lzma_bool" data-ref-filename="lzma_bool">lzma_bool</a>) <dfn class="decl fn" id="lzma_lzma_preset" title='lzma_lzma_preset' data-ref="lzma_lzma_preset" data-ref-filename="lzma_lzma_preset">lzma_lzma_preset</dfn>(</td></tr>
<tr><th id="420">420</th><td>		<a class="typedef" href="#lzma_options_lzma" title='lzma_options_lzma' data-type='struct lzma_options_lzma' data-ref="lzma_options_lzma" data-ref-filename="lzma_options_lzma">lzma_options_lzma</a> *<dfn class="local col5 decl" id="85options" title='options' data-type='lzma_options_lzma *' data-ref="85options" data-ref-filename="85options">options</dfn>, <a class="typedef" href="../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="local col6 decl" id="86preset" title='preset' data-type='uint32_t' data-ref="86preset" data-ref-filename="86preset">preset</dfn>) <a class="macro" href="../lzma.h.html#228" title="__attribute__((__nothrow__))" data-ref="_M/lzma_nothrow">lzma_nothrow</a>;</td></tr>
<tr><th id="421">421</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../../../../external/bsd/libarchive/dist/libarchive/archive_read_support_filter_xz.c.html'>netbsd/external/bsd/libarchive/dist/libarchive/archive_read_support_filter_xz.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
