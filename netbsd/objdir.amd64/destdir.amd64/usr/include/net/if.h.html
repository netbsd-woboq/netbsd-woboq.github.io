<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>if.h source code [netbsd/objdir.amd64/destdir.amd64/usr/include/net/if.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="if_addrprefreq,if_announcemsghdr,if_clone,if_clonereq,if_data,if_laddrreq,if_msghdr,if_nameindex,ifa_msghdr,ifaddr,ifaddr_data,ifaliasreq,ifcapreq,ifconf,ifdatareq,ifdrv,ifmediareq,ifnet,ifqueue,ifreq "/>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/objdir.amd64/destdir.amd64/usr/include/net/if.h'; var root_path = '../../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../..'>netbsd</a>/<a href='../../../..'>objdir.amd64</a>/<a href='../../..'>destdir.amd64</a>/<a href='../..'>usr</a>/<a href='..'>include</a>/<a href='./'>net</a>/<a href='if.h.html'>if.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*	$NetBSD: if.h,v 1.274 2019/07/04 02:44:25 ozaki-r Exp $	*/</i></td></tr>
<tr><th id="2">2</th><td></td></tr>
<tr><th id="3">3</th><td><i>/*-</i></td></tr>
<tr><th id="4">4</th><td><i> * Copyright (c) 1999, 2000, 2001 The NetBSD Foundation, Inc.</i></td></tr>
<tr><th id="5">5</th><td><i> * All rights reserved.</i></td></tr>
<tr><th id="6">6</th><td><i> *</i></td></tr>
<tr><th id="7">7</th><td><i> * This code is derived from software contributed to The NetBSD Foundation</i></td></tr>
<tr><th id="8">8</th><td><i> * by William Studenmund and Jason R. Thorpe.</i></td></tr>
<tr><th id="9">9</th><td><i> *</i></td></tr>
<tr><th id="10">10</th><td><i> * Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="11">11</th><td><i> * modification, are permitted provided that the following conditions</i></td></tr>
<tr><th id="12">12</th><td><i> * are met:</i></td></tr>
<tr><th id="13">13</th><td><i> * 1. Redistributions of source code must retain the above copyright</i></td></tr>
<tr><th id="14">14</th><td><i> *    notice, this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="15">15</th><td><i> * 2. Redistributions in binary form must reproduce the above copyright</i></td></tr>
<tr><th id="16">16</th><td><i> *    notice, this list of conditions and the following disclaimer in the</i></td></tr>
<tr><th id="17">17</th><td><i> *    documentation and/or other materials provided with the distribution.</i></td></tr>
<tr><th id="18">18</th><td><i> *</i></td></tr>
<tr><th id="19">19</th><td><i> * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS</i></td></tr>
<tr><th id="20">20</th><td><i> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</i></td></tr>
<tr><th id="21">21</th><td><i> * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</i></td></tr>
<tr><th id="22">22</th><td><i> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS</i></td></tr>
<tr><th id="23">23</th><td><i> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</i></td></tr>
<tr><th id="24">24</th><td><i> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</i></td></tr>
<tr><th id="25">25</th><td><i> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</i></td></tr>
<tr><th id="26">26</th><td><i> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</i></td></tr>
<tr><th id="27">27</th><td><i> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</i></td></tr>
<tr><th id="28">28</th><td><i> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</i></td></tr>
<tr><th id="29">29</th><td><i> * POSSIBILITY OF SUCH DAMAGE.</i></td></tr>
<tr><th id="30">30</th><td><i> */</i></td></tr>
<tr><th id="31">31</th><td></td></tr>
<tr><th id="32">32</th><td><i>/*</i></td></tr>
<tr><th id="33">33</th><td><i> * Copyright (c) 1982, 1986, 1989, 1993</i></td></tr>
<tr><th id="34">34</th><td><i> *	The Regents of the University of California.  All rights reserved.</i></td></tr>
<tr><th id="35">35</th><td><i> *</i></td></tr>
<tr><th id="36">36</th><td><i> * Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="37">37</th><td><i> * modification, are permitted provided that the following conditions</i></td></tr>
<tr><th id="38">38</th><td><i> * are met:</i></td></tr>
<tr><th id="39">39</th><td><i> * 1. Redistributions of source code must retain the above copyright</i></td></tr>
<tr><th id="40">40</th><td><i> *    notice, this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="41">41</th><td><i> * 2. Redistributions in binary form must reproduce the above copyright</i></td></tr>
<tr><th id="42">42</th><td><i> *    notice, this list of conditions and the following disclaimer in the</i></td></tr>
<tr><th id="43">43</th><td><i> *    documentation and/or other materials provided with the distribution.</i></td></tr>
<tr><th id="44">44</th><td><i> * 3. Neither the name of the University nor the names of its contributors</i></td></tr>
<tr><th id="45">45</th><td><i> *    may be used to endorse or promote products derived from this software</i></td></tr>
<tr><th id="46">46</th><td><i> *    without specific prior written permission.</i></td></tr>
<tr><th id="47">47</th><td><i> *</i></td></tr>
<tr><th id="48">48</th><td><i> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</i></td></tr>
<tr><th id="49">49</th><td><i> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</i></td></tr>
<tr><th id="50">50</th><td><i> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</i></td></tr>
<tr><th id="51">51</th><td><i> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</i></td></tr>
<tr><th id="52">52</th><td><i> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</i></td></tr>
<tr><th id="53">53</th><td><i> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</i></td></tr>
<tr><th id="54">54</th><td><i> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</i></td></tr>
<tr><th id="55">55</th><td><i> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</i></td></tr>
<tr><th id="56">56</th><td><i> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</i></td></tr>
<tr><th id="57">57</th><td><i> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</i></td></tr>
<tr><th id="58">58</th><td><i> * SUCH DAMAGE.</i></td></tr>
<tr><th id="59">59</th><td><i> *</i></td></tr>
<tr><th id="60">60</th><td><i> *	@(#)if.h	8.3 (Berkeley) 2/9/95</i></td></tr>
<tr><th id="61">61</th><td><i> */</i></td></tr>
<tr><th id="62">62</th><td></td></tr>
<tr><th id="63">63</th><td><u>#<span data-ppcond="63">ifndef</span> <span class="macro" data-ref="_M/_NET_IF_H_">_NET_IF_H_</span></u></td></tr>
<tr><th id="64">64</th><td><u>#define <dfn class="macro" id="_M/_NET_IF_H_" data-ref="_M/_NET_IF_H_">_NET_IF_H_</dfn></u></td></tr>
<tr><th id="65">65</th><td></td></tr>
<tr><th id="66">66</th><td><u>#<span data-ppcond="66">if</span> !defined(<span class="macro" data-ref="_M/_KERNEL">_KERNEL</span>) &amp;&amp; !defined(<span class="macro" data-ref="_M/_STANDALONE">_STANDALONE</span>)</u></td></tr>
<tr><th id="67">67</th><td><u>#include &lt;stdbool.h&gt;</u></td></tr>
<tr><th id="68">68</th><td><u>#<span data-ppcond="66">endif</span></u></td></tr>
<tr><th id="69">69</th><td></td></tr>
<tr><th id="70">70</th><td><u>#include <a href="../sys/featuretest.h.html">&lt;sys/featuretest.h&gt;</a></u></td></tr>
<tr><th id="71">71</th><td></td></tr>
<tr><th id="72">72</th><td><i>/*</i></td></tr>
<tr><th id="73">73</th><td><i> * Length of interface external name, including terminating '\0'.</i></td></tr>
<tr><th id="74">74</th><td><i> * Note: this is the same size as a generic device's external name.</i></td></tr>
<tr><th id="75">75</th><td><i> */</i></td></tr>
<tr><th id="76">76</th><td><u>#define <dfn class="macro" id="_M/IF_NAMESIZE" data-ref="_M/IF_NAMESIZE">IF_NAMESIZE</dfn> 16</u></td></tr>
<tr><th id="77">77</th><td></td></tr>
<tr><th id="78">78</th><td><i>/*</i></td></tr>
<tr><th id="79">79</th><td><i> * Length of interface description, including terminating '\0'.</i></td></tr>
<tr><th id="80">80</th><td><i> */</i></td></tr>
<tr><th id="81">81</th><td><u>#define	<dfn class="macro" id="_M/IFDESCRSIZE" data-ref="_M/IFDESCRSIZE">IFDESCRSIZE</dfn>	64</u></td></tr>
<tr><th id="82">82</th><td></td></tr>
<tr><th id="83">83</th><td><u>#<span data-ppcond="83">if</span> defined(<a class="macro" href="../sys/featuretest.h.html#70" data-ref="_M/_NETBSD_SOURCE">_NETBSD_SOURCE</a>)</u></td></tr>
<tr><th id="84">84</th><td></td></tr>
<tr><th id="85">85</th><td><u>#include <a href="../sys/socket.h.html">&lt;sys/socket.h&gt;</a></u></td></tr>
<tr><th id="86">86</th><td><u>#include <a href="../sys/queue.h.html">&lt;sys/queue.h&gt;</a></u></td></tr>
<tr><th id="87">87</th><td><u>#include <a href="../sys/mutex.h.html">&lt;sys/mutex.h&gt;</a></u></td></tr>
<tr><th id="88">88</th><td></td></tr>
<tr><th id="89">89</th><td><u>#include <a href="dlt.h.html">&lt;net/dlt.h&gt;</a></u></td></tr>
<tr><th id="90">90</th><td><u>#include <a href="pfil.h.html">&lt;net/pfil.h&gt;</a></u></td></tr>
<tr><th id="91">91</th><td><u>#<span data-ppcond="91">ifdef</span> <span class="macro" data-ref="_M/_KERNEL">_KERNEL</span></u></td></tr>
<tr><th id="92">92</th><td><u>#include &lt;net/pktqueue.h&gt;</u></td></tr>
<tr><th id="93">93</th><td><u>#include &lt;sys/pslist.h&gt;</u></td></tr>
<tr><th id="94">94</th><td><u>#include &lt;sys/pserialize.h&gt;</u></td></tr>
<tr><th id="95">95</th><td><u>#include &lt;sys/psref.h&gt;</u></td></tr>
<tr><th id="96">96</th><td><u>#include &lt;sys/module_hook.h&gt;</u></td></tr>
<tr><th id="97">97</th><td><u>#<span data-ppcond="91">endif</span></u></td></tr>
<tr><th id="98">98</th><td></td></tr>
<tr><th id="99">99</th><td><i>/*</i></td></tr>
<tr><th id="100">100</th><td><i> * Always include ALTQ glue here -- we use the ALTQ interface queue</i></td></tr>
<tr><th id="101">101</th><td><i> * structure even when ALTQ is not configured into the kernel so that</i></td></tr>
<tr><th id="102">102</th><td><i> * the size of struct ifnet does not changed based on the option.  The</i></td></tr>
<tr><th id="103">103</th><td><i> * ALTQ queue structure is API-compatible with the legacy ifqueue.</i></td></tr>
<tr><th id="104">104</th><td><i> */</i></td></tr>
<tr><th id="105">105</th><td><u>#include <a href="../altq/if_altq.h.html">&lt;altq/if_altq.h&gt;</a></u></td></tr>
<tr><th id="106">106</th><td></td></tr>
<tr><th id="107">107</th><td><i>/*</i></td></tr>
<tr><th id="108">108</th><td><i> * Structures defining a network interface, providing a packet</i></td></tr>
<tr><th id="109">109</th><td><i> * transport mechanism (ala level 0 of the PUP protocols).</i></td></tr>
<tr><th id="110">110</th><td><i> *</i></td></tr>
<tr><th id="111">111</th><td><i> * Each interface accepts output datagrams of a specified maximum</i></td></tr>
<tr><th id="112">112</th><td><i> * length, and provides higher level routines with input datagrams</i></td></tr>
<tr><th id="113">113</th><td><i> * received from its medium.</i></td></tr>
<tr><th id="114">114</th><td><i> *</i></td></tr>
<tr><th id="115">115</th><td><i> * Output occurs when the routine if_output is called, with four parameters:</i></td></tr>
<tr><th id="116">116</th><td><i> *	(*ifp-&gt;if_output)(ifp, m, dst, rt)</i></td></tr>
<tr><th id="117">117</th><td><i> * Here m is the mbuf chain to be sent and dst is the destination address.</i></td></tr>
<tr><th id="118">118</th><td><i> * The output routine encapsulates the supplied datagram if necessary,</i></td></tr>
<tr><th id="119">119</th><td><i> * and then transmits it on its medium.</i></td></tr>
<tr><th id="120">120</th><td><i> *</i></td></tr>
<tr><th id="121">121</th><td><i> * On input, each interface unwraps the data received by it, and either</i></td></tr>
<tr><th id="122">122</th><td><i> * places it on the input queue of a internetwork datagram routine</i></td></tr>
<tr><th id="123">123</th><td><i> * and posts the associated software interrupt, or passes the datagram to a raw</i></td></tr>
<tr><th id="124">124</th><td><i> * packet input routine.</i></td></tr>
<tr><th id="125">125</th><td><i> *</i></td></tr>
<tr><th id="126">126</th><td><i> * Routines exist for locating interfaces by their addresses</i></td></tr>
<tr><th id="127">127</th><td><i> * or for locating a interface on a certain network, as well as more general</i></td></tr>
<tr><th id="128">128</th><td><i> * routing and gateway routines maintaining information used to locate</i></td></tr>
<tr><th id="129">129</th><td><i> * interfaces.  These routines live in the files if.c and route.c</i></td></tr>
<tr><th id="130">130</th><td><i> */</i></td></tr>
<tr><th id="131">131</th><td><u>#include <a href="../sys/time.h.html">&lt;sys/time.h&gt;</a></u></td></tr>
<tr><th id="132">132</th><td></td></tr>
<tr><th id="133">133</th><td><u>#<span data-ppcond="133">if</span> defined(<span class="macro" data-ref="_M/_KERNEL_OPT">_KERNEL_OPT</span>)</u></td></tr>
<tr><th id="134">134</th><td><u>#include "opt_compat_netbsd.h"</u></td></tr>
<tr><th id="135">135</th><td><u>#include "opt_gateway.h"</u></td></tr>
<tr><th id="136">136</th><td><u>#<span data-ppcond="133">endif</span></u></td></tr>
<tr><th id="137">137</th><td></td></tr>
<tr><th id="138">138</th><td><b>struct</b> <a class="type" href="pfil.h.html#mbuf" title='mbuf' data-ref="mbuf" data-ref-filename="mbuf" id="mbuf">mbuf</a>;</td></tr>
<tr><th id="139">139</th><td><b>struct</b> <dfn class="type" id="proc" title='proc' data-ref="proc" data-ref-filename="proc">proc</dfn>;</td></tr>
<tr><th id="140">140</th><td><b>struct</b> <dfn class="type" id="rtentry" title='rtentry' data-ref="rtentry" data-ref-filename="rtentry">rtentry</dfn>;</td></tr>
<tr><th id="141">141</th><td><b>struct</b> <dfn class="type" id="socket" title='socket' data-ref="socket" data-ref-filename="socket">socket</dfn>;</td></tr>
<tr><th id="142">142</th><td><b>struct</b> <dfn class="type" id="ether_header" title='ether_header' data-ref="ether_header" data-ref-filename="ether_header">ether_header</dfn>;</td></tr>
<tr><th id="143">143</th><td><b>struct</b> <a class="type" href="#ifaddr" title='ifaddr' data-ref="ifaddr" data-ref-filename="ifaddr">ifaddr</a>;</td></tr>
<tr><th id="144">144</th><td><b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a>;</td></tr>
<tr><th id="145">145</th><td><b>struct</b> <dfn class="type" id="rt_addrinfo" title='rt_addrinfo' data-ref="rt_addrinfo" data-ref-filename="rt_addrinfo">rt_addrinfo</dfn>;</td></tr>
<tr><th id="146">146</th><td></td></tr>
<tr><th id="147">147</th><td><u>#define	<dfn class="macro" id="_M/IFNAMSIZ" data-ref="_M/IFNAMSIZ">IFNAMSIZ</dfn>	IF_NAMESIZE</u></td></tr>
<tr><th id="148">148</th><td></td></tr>
<tr><th id="149">149</th><td><i>/*</i></td></tr>
<tr><th id="150">150</th><td><i> * Structure describing a `cloning' interface.</i></td></tr>
<tr><th id="151">151</th><td><i> */</i></td></tr>
<tr><th id="152">152</th><td><b>struct</b> <dfn class="type def" id="if_clone" title='if_clone' data-ref="if_clone" data-ref-filename="if_clone">if_clone</dfn> {</td></tr>
<tr><th id="153">153</th><td>	<a class="macro" href="../sys/queue.h.html#196" title="struct { struct if_clone *le_next; struct if_clone **le_prev; }" data-ref="_M/LIST_ENTRY">LIST_ENTRY</a>(<a class="type" href="#if_clone" title='if_clone' data-ref="if_clone" data-ref-filename="if_clone">if_clone</a>) <dfn class="decl field" id="if_clone::ifc_list" title='if_clone::ifc_list' data-ref="if_clone::ifc_list" data-ref-filename="if_clone..ifc_list">ifc_list</dfn>;	<i>/* on list of cloners */</i></td></tr>
<tr><th id="154">154</th><td>	<em>const</em> <em>char</em> *<dfn class="decl field" id="if_clone::ifc_name" title='if_clone::ifc_name' data-ref="if_clone::ifc_name" data-ref-filename="if_clone..ifc_name">ifc_name</dfn>;		<i>/* name of device, e.g. `gif' */</i></td></tr>
<tr><th id="155">155</th><td>	<a class="typedef" href="../sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a> <dfn class="decl field" id="if_clone::ifc_namelen" title='if_clone::ifc_namelen' data-ref="if_clone::ifc_namelen" data-ref-filename="if_clone..ifc_namelen">ifc_namelen</dfn>;		<i>/* length of name */</i></td></tr>
<tr><th id="156">156</th><td></td></tr>
<tr><th id="157">157</th><td>	<em>int</em>	(*<dfn class="decl field" id="if_clone::ifc_create" title='if_clone::ifc_create' data-ref="if_clone::ifc_create" data-ref-filename="if_clone..ifc_create">ifc_create</dfn>)(<b>struct</b> <a class="type" href="#if_clone" title='if_clone' data-ref="if_clone" data-ref-filename="if_clone">if_clone</a> *, <em>int</em>);</td></tr>
<tr><th id="158">158</th><td>	<em>int</em>	(*<dfn class="decl field" id="if_clone::ifc_destroy" title='if_clone::ifc_destroy' data-ref="if_clone::ifc_destroy" data-ref-filename="if_clone..ifc_destroy">ifc_destroy</dfn>)(<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *);</td></tr>
<tr><th id="159">159</th><td>};</td></tr>
<tr><th id="160">160</th><td></td></tr>
<tr><th id="161">161</th><td><u>#define	<dfn class="macro" id="_M/IF_CLONE_INITIALIZER" data-ref="_M/IF_CLONE_INITIALIZER">IF_CLONE_INITIALIZER</dfn>(name, create, destroy)			\</u></td></tr>
<tr><th id="162">162</th><td><u>	{ { NULL, NULL }, name, sizeof(name) - 1, create, destroy }</u></td></tr>
<tr><th id="163">163</th><td></td></tr>
<tr><th id="164">164</th><td><i>/*</i></td></tr>
<tr><th id="165">165</th><td><i> * Structure used to query names of interface cloners.</i></td></tr>
<tr><th id="166">166</th><td><i> */</i></td></tr>
<tr><th id="167">167</th><td><b>struct</b> <dfn class="type def" id="if_clonereq" title='if_clonereq' data-ref="if_clonereq" data-ref-filename="if_clonereq">if_clonereq</dfn> {</td></tr>
<tr><th id="168">168</th><td>	<em>int</em>	<dfn class="decl field" id="if_clonereq::ifcr_total" title='if_clonereq::ifcr_total' data-ref="if_clonereq::ifcr_total" data-ref-filename="if_clonereq..ifcr_total">ifcr_total</dfn>;		<i>/* total cloners (out) */</i></td></tr>
<tr><th id="169">169</th><td>	<em>int</em>	<dfn class="decl field" id="if_clonereq::ifcr_count" title='if_clonereq::ifcr_count' data-ref="if_clonereq::ifcr_count" data-ref-filename="if_clonereq..ifcr_count">ifcr_count</dfn>;		<i>/* room for this many in user buffer */</i></td></tr>
<tr><th id="170">170</th><td>	<em>char</em>	*<dfn class="decl field" id="if_clonereq::ifcr_buffer" title='if_clonereq::ifcr_buffer' data-ref="if_clonereq::ifcr_buffer" data-ref-filename="if_clonereq..ifcr_buffer">ifcr_buffer</dfn>;		<i>/* buffer for cloner names */</i></td></tr>
<tr><th id="171">171</th><td>};</td></tr>
<tr><th id="172">172</th><td></td></tr>
<tr><th id="173">173</th><td><i>/*</i></td></tr>
<tr><th id="174">174</th><td><i> * Structure defining statistics and other data kept regarding a network</i></td></tr>
<tr><th id="175">175</th><td><i> * interface.</i></td></tr>
<tr><th id="176">176</th><td><i> */</i></td></tr>
<tr><th id="177">177</th><td><b>struct</b> <dfn class="type def" id="if_data" title='if_data' data-ref="if_data" data-ref-filename="if_data">if_data</dfn> {</td></tr>
<tr><th id="178">178</th><td>	<i>/* generic interface information */</i></td></tr>
<tr><th id="179">179</th><td>	<a class="typedef" href="../sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a>	<dfn class="decl field" id="if_data::ifi_type" title='if_data::ifi_type' data-ref="if_data::ifi_type" data-ref-filename="if_data..ifi_type">ifi_type</dfn>;		<i>/* ethernet, tokenring, etc. */</i></td></tr>
<tr><th id="180">180</th><td>	<a class="typedef" href="../sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a>	<dfn class="decl field" id="if_data::ifi_addrlen" title='if_data::ifi_addrlen' data-ref="if_data::ifi_addrlen" data-ref-filename="if_data..ifi_addrlen">ifi_addrlen</dfn>;		<i>/* media address length */</i></td></tr>
<tr><th id="181">181</th><td>	<a class="typedef" href="../sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a>	<dfn class="decl field" id="if_data::ifi_hdrlen" title='if_data::ifi_hdrlen' data-ref="if_data::ifi_hdrlen" data-ref-filename="if_data..ifi_hdrlen">ifi_hdrlen</dfn>;		<i>/* media header length */</i></td></tr>
<tr><th id="182">182</th><td>	<em>int</em>	<dfn class="decl field" id="if_data::ifi_link_state" title='if_data::ifi_link_state' data-ref="if_data::ifi_link_state" data-ref-filename="if_data..ifi_link_state">ifi_link_state</dfn>;		<i>/* current link state */</i></td></tr>
<tr><th id="183">183</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_mtu" title='if_data::ifi_mtu' data-ref="if_data::ifi_mtu" data-ref-filename="if_data..ifi_mtu">ifi_mtu</dfn>;		<i>/* maximum transmission unit */</i></td></tr>
<tr><th id="184">184</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_metric" title='if_data::ifi_metric' data-ref="if_data::ifi_metric" data-ref-filename="if_data..ifi_metric">ifi_metric</dfn>;		<i>/* routing metric (external only) */</i></td></tr>
<tr><th id="185">185</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_baudrate" title='if_data::ifi_baudrate' data-ref="if_data::ifi_baudrate" data-ref-filename="if_data..ifi_baudrate">ifi_baudrate</dfn>;		<i>/* linespeed */</i></td></tr>
<tr><th id="186">186</th><td>	<i>/* volatile statistics */</i></td></tr>
<tr><th id="187">187</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_ipackets" title='if_data::ifi_ipackets' data-ref="if_data::ifi_ipackets" data-ref-filename="if_data..ifi_ipackets">ifi_ipackets</dfn>;		<i>/* packets received on interface */</i></td></tr>
<tr><th id="188">188</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_ierrors" title='if_data::ifi_ierrors' data-ref="if_data::ifi_ierrors" data-ref-filename="if_data..ifi_ierrors">ifi_ierrors</dfn>;		<i>/* input errors on interface */</i></td></tr>
<tr><th id="189">189</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_opackets" title='if_data::ifi_opackets' data-ref="if_data::ifi_opackets" data-ref-filename="if_data..ifi_opackets">ifi_opackets</dfn>;		<i>/* packets sent on interface */</i></td></tr>
<tr><th id="190">190</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_oerrors" title='if_data::ifi_oerrors' data-ref="if_data::ifi_oerrors" data-ref-filename="if_data..ifi_oerrors">ifi_oerrors</dfn>;		<i>/* output errors on interface */</i></td></tr>
<tr><th id="191">191</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_collisions" title='if_data::ifi_collisions' data-ref="if_data::ifi_collisions" data-ref-filename="if_data..ifi_collisions">ifi_collisions</dfn>;	<i>/* collisions on csma interfaces */</i></td></tr>
<tr><th id="192">192</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_ibytes" title='if_data::ifi_ibytes' data-ref="if_data::ifi_ibytes" data-ref-filename="if_data..ifi_ibytes">ifi_ibytes</dfn>;		<i>/* total number of octets received */</i></td></tr>
<tr><th id="193">193</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_obytes" title='if_data::ifi_obytes' data-ref="if_data::ifi_obytes" data-ref-filename="if_data..ifi_obytes">ifi_obytes</dfn>;		<i>/* total number of octets sent */</i></td></tr>
<tr><th id="194">194</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_imcasts" title='if_data::ifi_imcasts' data-ref="if_data::ifi_imcasts" data-ref-filename="if_data..ifi_imcasts">ifi_imcasts</dfn>;		<i>/* packets received via multicast */</i></td></tr>
<tr><th id="195">195</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_omcasts" title='if_data::ifi_omcasts' data-ref="if_data::ifi_omcasts" data-ref-filename="if_data..ifi_omcasts">ifi_omcasts</dfn>;		<i>/* packets sent via multicast */</i></td></tr>
<tr><th id="196">196</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_iqdrops" title='if_data::ifi_iqdrops' data-ref="if_data::ifi_iqdrops" data-ref-filename="if_data..ifi_iqdrops">ifi_iqdrops</dfn>;		<i>/* dropped on input, this interface */</i></td></tr>
<tr><th id="197">197</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="if_data::ifi_noproto" title='if_data::ifi_noproto' data-ref="if_data::ifi_noproto" data-ref-filename="if_data..ifi_noproto">ifi_noproto</dfn>;		<i>/* destined for unsupported protocol */</i></td></tr>
<tr><th id="198">198</th><td>	<b>struct</b>	<a class="type" href="../sys/timespec.h.html#timespec" title='timespec' data-ref="timespec" data-ref-filename="timespec">timespec</a> <dfn class="decl field" id="if_data::ifi_lastchange" title='if_data::ifi_lastchange' data-ref="if_data::ifi_lastchange" data-ref-filename="if_data..ifi_lastchange">ifi_lastchange</dfn>;<i>/* last operational state change */</i></td></tr>
<tr><th id="199">199</th><td>};</td></tr>
<tr><th id="200">200</th><td></td></tr>
<tr><th id="201">201</th><td><i>/*</i></td></tr>
<tr><th id="202">202</th><td><i> * Values for if_link_state.</i></td></tr>
<tr><th id="203">203</th><td><i> */</i></td></tr>
<tr><th id="204">204</th><td><u>#define	<dfn class="macro" id="_M/LINK_STATE_UNKNOWN" data-ref="_M/LINK_STATE_UNKNOWN">LINK_STATE_UNKNOWN</dfn>	0	/* link invalid/unknown */</u></td></tr>
<tr><th id="205">205</th><td><u>#define	<dfn class="macro" id="_M/LINK_STATE_DOWN" data-ref="_M/LINK_STATE_DOWN">LINK_STATE_DOWN</dfn>		1	/* link is down */</u></td></tr>
<tr><th id="206">206</th><td><u>#define	<dfn class="macro" id="_M/LINK_STATE_UP" data-ref="_M/LINK_STATE_UP">LINK_STATE_UP</dfn>		2	/* link is up */</u></td></tr>
<tr><th id="207">207</th><td></td></tr>
<tr><th id="208">208</th><td><i>/*</i></td></tr>
<tr><th id="209">209</th><td><i> * Structure defining a queue for a network interface.</i></td></tr>
<tr><th id="210">210</th><td><i> */</i></td></tr>
<tr><th id="211">211</th><td><b>struct</b> <dfn class="type def" id="ifqueue" title='ifqueue' data-ref="ifqueue" data-ref-filename="ifqueue">ifqueue</dfn> {</td></tr>
<tr><th id="212">212</th><td>	<b>struct</b>		<a class="type" href="pfil.h.html#mbuf" title='mbuf' data-ref="mbuf" data-ref-filename="mbuf">mbuf</a> *<dfn class="decl field" id="ifqueue::ifq_head" title='ifqueue::ifq_head' data-ref="ifqueue::ifq_head" data-ref-filename="ifqueue..ifq_head">ifq_head</dfn>;</td></tr>
<tr><th id="213">213</th><td>	<b>struct</b>		<a class="type" href="pfil.h.html#mbuf" title='mbuf' data-ref="mbuf" data-ref-filename="mbuf">mbuf</a> *<dfn class="decl field" id="ifqueue::ifq_tail" title='ifqueue::ifq_tail' data-ref="ifqueue::ifq_tail" data-ref-filename="ifqueue..ifq_tail">ifq_tail</dfn>;</td></tr>
<tr><th id="214">214</th><td>	<em>int</em>		<dfn class="decl field" id="ifqueue::ifq_len" title='ifqueue::ifq_len' data-ref="ifqueue::ifq_len" data-ref-filename="ifqueue..ifq_len">ifq_len</dfn>;</td></tr>
<tr><th id="215">215</th><td>	<em>int</em>		<dfn class="decl field" id="ifqueue::ifq_maxlen" title='ifqueue::ifq_maxlen' data-ref="ifqueue::ifq_maxlen" data-ref-filename="ifqueue..ifq_maxlen">ifq_maxlen</dfn>;</td></tr>
<tr><th id="216">216</th><td>	<em>int</em>		<dfn class="decl field" id="ifqueue::ifq_drops" title='ifqueue::ifq_drops' data-ref="ifqueue::ifq_drops" data-ref-filename="ifqueue..ifq_drops">ifq_drops</dfn>;</td></tr>
<tr><th id="217">217</th><td>	<a class="typedef" href="../sys/mutex.h.html#kmutex_t" title='kmutex_t' data-type='struct kmutex' data-ref="kmutex_t" data-ref-filename="kmutex_t">kmutex_t</a>	*<dfn class="decl field" id="ifqueue::ifq_lock" title='ifqueue::ifq_lock' data-ref="ifqueue::ifq_lock" data-ref-filename="ifqueue..ifq_lock">ifq_lock</dfn>;</td></tr>
<tr><th id="218">218</th><td>};</td></tr>
<tr><th id="219">219</th><td></td></tr>
<tr><th id="220">220</th><td><u>#<span data-ppcond="220">ifdef</span> <span class="macro" data-ref="_M/_KERNEL">_KERNEL</span></u></td></tr>
<tr><th id="221">221</th><td><u>#include &lt;sys/percpu.h&gt;</u></td></tr>
<tr><th id="222">222</th><td><u>#include &lt;sys/callout.h&gt;</u></td></tr>
<tr><th id="223">223</th><td><u>#include &lt;sys/rwlock.h&gt;</u></td></tr>
<tr><th id="224">224</th><td></td></tr>
<tr><th id="225">225</th><td><u>#<span data-ppcond="220">endif</span> /* _KERNEL */</u></td></tr>
<tr><th id="226">226</th><td></td></tr>
<tr><th id="227">227</th><td><i>/*</i></td></tr>
<tr><th id="228">228</th><td><i> * Structure defining a queue for a network interface.</i></td></tr>
<tr><th id="229">229</th><td><i> *</i></td></tr>
<tr><th id="230">230</th><td><i> * (Would like to call this struct ``if'', but C isn't PL/1.)</i></td></tr>
<tr><th id="231">231</th><td><i> */</i></td></tr>
<tr><th id="232">232</th><td><a class="macro" href="../sys/queue.h.html#413" title="struct ifnet_head { struct ifnet *tqh_first; struct ifnet * *tqh_last; }" data-ref="_M/TAILQ_HEAD">TAILQ_HEAD</a>(<dfn class="type def" id="ifnet_head" title='ifnet_head' data-ref="ifnet_head" data-ref-filename="ifnet_head">ifnet_head</dfn>, <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a>);		<i>/* the actual queue head */</i></td></tr>
<tr><th id="233">233</th><td></td></tr>
<tr><th id="234">234</th><td><b>struct</b> <dfn class="type" id="bridge_softc" title='bridge_softc' data-ref="bridge_softc" data-ref-filename="bridge_softc">bridge_softc</dfn>;</td></tr>
<tr><th id="235">235</th><td><b>struct</b> <dfn class="type" id="bridge_iflist" title='bridge_iflist' data-ref="bridge_iflist" data-ref-filename="bridge_iflist">bridge_iflist</dfn>;</td></tr>
<tr><th id="236">236</th><td><b>struct</b> <dfn class="type" id="callout" title='callout' data-ref="callout" data-ref-filename="callout">callout</dfn>;</td></tr>
<tr><th id="237">237</th><td><b>struct</b> <dfn class="type" id="krwlock" title='krwlock' data-ref="krwlock" data-ref-filename="krwlock">krwlock</dfn>;</td></tr>
<tr><th id="238">238</th><td><b>struct</b> <dfn class="type" id="if_percpuq" title='if_percpuq' data-ref="if_percpuq" data-ref-filename="if_percpuq">if_percpuq</dfn>;</td></tr>
<tr><th id="239">239</th><td><b>struct</b> <dfn class="type" id="if_deferred_start" title='if_deferred_start' data-ref="if_deferred_start" data-ref-filename="if_deferred_start">if_deferred_start</dfn>;</td></tr>
<tr><th id="240">240</th><td><b>struct</b> <dfn class="type" id="in6_multi" title='in6_multi' data-ref="in6_multi" data-ref-filename="in6_multi">in6_multi</dfn>;</td></tr>
<tr><th id="241">241</th><td></td></tr>
<tr><th id="242">242</th><td><b>typedef</b> <em>unsigned</em> <em>short</em> <dfn class="typedef" id="if_index_t" title='if_index_t' data-type='unsigned short' data-ref="if_index_t" data-ref-filename="if_index_t">if_index_t</dfn>;</td></tr>
<tr><th id="243">243</th><td></td></tr>
<tr><th id="244">244</th><td><i>/*</i></td></tr>
<tr><th id="245">245</th><td><i> * Interface.  Field markings and the corresponding locks:</i></td></tr>
<tr><th id="246">246</th><td><i> *</i></td></tr>
<tr><th id="247">247</th><td><i> * i:	IFNET_LOCK (a.k.a., if_ioctl_lock)</i></td></tr>
<tr><th id="248">248</th><td><i> * q:	ifq_lock (struct ifaltq)</i></td></tr>
<tr><th id="249">249</th><td><i> * a:	if_afdata_lock</i></td></tr>
<tr><th id="250">250</th><td><i> * 6:	in6_multilock (global lock)</i></td></tr>
<tr><th id="251">251</th><td><i> * ::	unlocked, stable</i></td></tr>
<tr><th id="252">252</th><td><i> * ?:	unknown, maybe unsafe</i></td></tr>
<tr><th id="253">253</th><td><i> *</i></td></tr>
<tr><th id="254">254</th><td><i> * Lock order: IFNET_LOCK =&gt; in6_multilock =&gt; if_afdata_lock =&gt; ifq_lock</i></td></tr>
<tr><th id="255">255</th><td><i> *   Note that currently if_afdata_lock and ifq_lock aren't held</i></td></tr>
<tr><th id="256">256</th><td><i> *   at the same time, but define the order anyway.</i></td></tr>
<tr><th id="257">257</th><td><i> *</i></td></tr>
<tr><th id="258">258</th><td><i> * Lock order of IFNET_LOCK with other locks:</i></td></tr>
<tr><th id="259">259</th><td><i> *     softnet_lock =&gt; solock =&gt; IFNET_LOCK =&gt; ND6_LOCK, in_multilock</i></td></tr>
<tr><th id="260">260</th><td><i> */</i></td></tr>
<tr><th id="261">261</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet"><a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a></dfn> {</td></tr>
<tr><th id="262">262</th><td>	<em>void</em>		*<dfn class="decl field" id="ifnet::if_softc" title='ifnet::if_softc' data-ref="ifnet::if_softc" data-ref-filename="ifnet..if_softc">if_softc</dfn>;	<i>/* :: lower-level data for this if */</i></td></tr>
<tr><th id="263">263</th><td>	<i>/* DEPRECATED. Keep it to avoid breaking kvm(3) users */</i></td></tr>
<tr><th id="264">264</th><td>	<a class="macro" href="../sys/queue.h.html#423" title="struct { struct ifnet *tqe_next; struct ifnet * *tqe_prev; }" data-ref="_M/TAILQ_ENTRY">TAILQ_ENTRY</a>(<a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a>)</td></tr>
<tr><th id="265">265</th><td>			<dfn class="decl field" id="ifnet::if_list" title='ifnet::if_list' data-ref="ifnet::if_list" data-ref-filename="ifnet..if_list">if_list</dfn>;	<i>/* i: all struct ifnets are chained */</i></td></tr>
<tr><th id="266">266</th><td>	<a class="macro" href="../sys/queue.h.html#413" title="struct { struct ifaddr *tqh_first; struct ifaddr * *tqh_last; }" data-ref="_M/TAILQ_HEAD">TAILQ_HEAD</a>(, <a class="type" href="#ifaddr" title='ifaddr' data-ref="ifaddr" data-ref-filename="ifaddr">ifaddr</a>)</td></tr>
<tr><th id="267">267</th><td>			<dfn class="decl field" id="ifnet::if_addrlist" title='ifnet::if_addrlist' data-ref="ifnet::if_addrlist" data-ref-filename="ifnet..if_addrlist">if_addrlist</dfn>;	<i>/* i: linked list of addresses per if */</i></td></tr>
<tr><th id="268">268</th><td>	<em>char</em>		<dfn class="decl field" id="ifnet::if_xname" title='ifnet::if_xname' data-ref="ifnet::if_xname" data-ref-filename="ifnet..if_xname">if_xname</dfn>[<a class="macro" href="#147" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];</td></tr>
<tr><th id="269">269</th><td>					<i>/* :: external name (name + unit) */</i></td></tr>
<tr><th id="270">270</th><td>	<em>int</em>		<dfn class="decl field" id="ifnet::if_pcount" title='ifnet::if_pcount' data-ref="ifnet::if_pcount" data-ref-filename="ifnet..if_pcount">if_pcount</dfn>;	<i>/* i: number of promiscuous listeners */</i></td></tr>
<tr><th id="271">271</th><td>	<b>struct</b> <dfn class="type" id="bpf_if" title='bpf_if' data-ref="bpf_if" data-ref-filename="bpf_if"><a class="type" href="#bpf_if" title='bpf_if' data-ref="bpf_if" data-ref-filename="bpf_if">bpf_if</a></dfn>	*<dfn class="decl field" id="ifnet::if_bpf" title='ifnet::if_bpf' data-ref="ifnet::if_bpf" data-ref-filename="ifnet..if_bpf">if_bpf</dfn>;	<i>/* :: packet filter structure */</i></td></tr>
<tr><th id="272">272</th><td>	<a class="typedef" href="#if_index_t" title='if_index_t' data-type='unsigned short' data-ref="if_index_t" data-ref-filename="if_index_t">if_index_t</a>	<dfn class="decl field" id="ifnet::if_index" title='ifnet::if_index' data-ref="ifnet::if_index" data-ref-filename="ifnet..if_index">if_index</dfn>;	<i>/* :: numeric abbreviation for this if */</i></td></tr>
<tr><th id="273">273</th><td>	<em>short</em>		<dfn class="decl field" id="ifnet::if_timer" title='ifnet::if_timer' data-ref="ifnet::if_timer" data-ref-filename="ifnet..if_timer">if_timer</dfn>;	<i>/* ?: time 'til if_slowtimo called */</i></td></tr>
<tr><th id="274">274</th><td>	<em>unsigned</em> <em>short</em>	<dfn class="decl field" id="ifnet::if_flags" title='ifnet::if_flags' data-ref="ifnet::if_flags" data-ref-filename="ifnet..if_flags">if_flags</dfn>;	<i>/* i: up/down, broadcast, etc. */</i></td></tr>
<tr><th id="275">275</th><td>	<em>short</em>		<dfn class="decl field" id="ifnet::if_extflags" title='ifnet::if_extflags' data-ref="ifnet::if_extflags" data-ref-filename="ifnet..if_extflags">if_extflags</dfn>;	<i>/* :: if_output MP-safe, etc. */</i></td></tr>
<tr><th id="276">276</th><td>	<b>struct</b> <a class="type" href="#if_data" title='if_data' data-ref="if_data" data-ref-filename="if_data">if_data</a>	<dfn class="decl field" id="ifnet::if_data" title='ifnet::if_data' data-ref="ifnet::if_data" data-ref-filename="ifnet..if_data">if_data</dfn>;	<i>/* ?: statistics and other data about if */</i></td></tr>
<tr><th id="277">277</th><td>	<i>/*</i></td></tr>
<tr><th id="278">278</th><td><i>	 * Procedure handles.  If you add more of these, don't forget the</i></td></tr>
<tr><th id="279">279</th><td><i>	 * corresponding NULL stub in if.c.</i></td></tr>
<tr><th id="280">280</th><td><i>	 */</i></td></tr>
<tr><th id="281">281</th><td>	<em>int</em>		(*<dfn class="decl field" id="ifnet::if_output" title='ifnet::if_output' data-ref="ifnet::if_output" data-ref-filename="ifnet..if_output">if_output</dfn>)	<i>/* :: output routine (enqueue) */</i></td></tr>
<tr><th id="282">282</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *, <b>struct</b> <a class="type" href="pfil.h.html#mbuf" title='mbuf' data-ref="mbuf" data-ref-filename="mbuf">mbuf</a> *, <em>const</em> <b>struct</b> <a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *,</td></tr>
<tr><th id="283">283</th><td>			     <em>const</em> <b>struct</b> <a class="type" href="#rtentry" title='rtentry' data-ref="rtentry" data-ref-filename="rtentry">rtentry</a> *);</td></tr>
<tr><th id="284">284</th><td>	<em>void</em>		(*<dfn class="decl field" id="ifnet::_if_input" title='ifnet::_if_input' data-ref="ifnet::_if_input" data-ref-filename="ifnet.._if_input">_if_input</dfn>)	<i>/* :: input routine (from h/w driver) */</i></td></tr>
<tr><th id="285">285</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *, <b>struct</b> <a class="type" href="pfil.h.html#mbuf" title='mbuf' data-ref="mbuf" data-ref-filename="mbuf">mbuf</a> *);</td></tr>
<tr><th id="286">286</th><td>	<em>void</em>		(*<dfn class="decl field" id="ifnet::if_start" title='ifnet::if_start' data-ref="ifnet::if_start" data-ref-filename="ifnet..if_start">if_start</dfn>)	<i>/* :: initiate output routine */</i></td></tr>
<tr><th id="287">287</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *);</td></tr>
<tr><th id="288">288</th><td>	<em>int</em>		(*<dfn class="decl field" id="ifnet::if_transmit" title='ifnet::if_transmit' data-ref="ifnet::if_transmit" data-ref-filename="ifnet..if_transmit">if_transmit</dfn>)	<i>/* :: output routine, must be MP-safe */</i></td></tr>
<tr><th id="289">289</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *, <b>struct</b> <a class="type" href="pfil.h.html#mbuf" title='mbuf' data-ref="mbuf" data-ref-filename="mbuf">mbuf</a> *);</td></tr>
<tr><th id="290">290</th><td>	<em>int</em>		(*<dfn class="decl field" id="ifnet::if_ioctl" title='ifnet::if_ioctl' data-ref="ifnet::if_ioctl" data-ref-filename="ifnet..if_ioctl">if_ioctl</dfn>)	<i>/* :: ioctl routine */</i></td></tr>
<tr><th id="291">291</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *, <a class="typedef" href="../sys/types.h.html#u_long" title='u_long' data-type='unsigned long' data-ref="u_long" data-ref-filename="u_long">u_long</a>, <em>void</em> *);</td></tr>
<tr><th id="292">292</th><td>	<em>int</em>		(*<dfn class="decl field" id="ifnet::if_init" title='ifnet::if_init' data-ref="ifnet::if_init" data-ref-filename="ifnet..if_init">if_init</dfn>)	<i>/* :: init routine */</i></td></tr>
<tr><th id="293">293</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *);</td></tr>
<tr><th id="294">294</th><td>	<em>void</em>		(*<dfn class="decl field" id="ifnet::if_stop" title='ifnet::if_stop' data-ref="ifnet::if_stop" data-ref-filename="ifnet..if_stop">if_stop</dfn>)	<i>/* :: stop routine */</i></td></tr>
<tr><th id="295">295</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *, <em>int</em>);</td></tr>
<tr><th id="296">296</th><td>	<em>void</em>		(*<dfn class="decl field" id="ifnet::if_slowtimo" title='ifnet::if_slowtimo' data-ref="ifnet::if_slowtimo" data-ref-filename="ifnet..if_slowtimo">if_slowtimo</dfn>)	<i>/* :: timer routine */</i></td></tr>
<tr><th id="297">297</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *);</td></tr>
<tr><th id="298">298</th><td><u>#define	<dfn class="macro" id="_M/if_watchdog" data-ref="_M/if_watchdog">if_watchdog</dfn>	if_slowtimo</u></td></tr>
<tr><th id="299">299</th><td>	<em>void</em>		(*<dfn class="decl field" id="ifnet::if_drain" title='ifnet::if_drain' data-ref="ifnet::if_drain" data-ref-filename="ifnet..if_drain">if_drain</dfn>)	<i>/* :: routine to release resources */</i></td></tr>
<tr><th id="300">300</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *);</td></tr>
<tr><th id="301">301</th><td>	<b>struct</b> <a class="type" href="../altq/if_altq.h.html#ifaltq" title='ifaltq' data-ref="ifaltq" data-ref-filename="ifaltq">ifaltq</a>	<dfn class="decl field" id="ifnet::if_snd" title='ifnet::if_snd' data-ref="ifnet::if_snd" data-ref-filename="ifnet..if_snd">if_snd</dfn>;		<i>/* q: output queue (includes altq) */</i></td></tr>
<tr><th id="302">302</th><td>	<b>struct</b> <a class="type" href="#ifaddr" title='ifaddr' data-ref="ifaddr" data-ref-filename="ifaddr">ifaddr</a>	*<dfn class="decl field" id="ifnet::if_dl" title='ifnet::if_dl' data-ref="ifnet::if_dl" data-ref-filename="ifnet..if_dl">if_dl</dfn>;		<i>/* i: identity of this interface. */</i></td></tr>
<tr><th id="303">303</th><td>	<em>const</em> <b>struct</b> <dfn class="type" id="sockaddr_dl" title='sockaddr_dl' data-ref="sockaddr_dl" data-ref-filename="sockaddr_dl"><a class="type" href="#sockaddr_dl" title='sockaddr_dl' data-ref="sockaddr_dl" data-ref-filename="sockaddr_dl">sockaddr_dl</a></dfn></td></tr>
<tr><th id="304">304</th><td>			*<dfn class="decl field" id="ifnet::if_sadl" title='ifnet::if_sadl' data-ref="ifnet::if_sadl" data-ref-filename="ifnet..if_sadl">if_sadl</dfn>;	<i>/* i: pointer to sockaddr_dl of if_dl */</i></td></tr>
<tr><th id="305">305</th><td>	<i>/*</i></td></tr>
<tr><th id="306">306</th><td><i>	 * May be NULL.  If not NULL, it is the address assigned</i></td></tr>
<tr><th id="307">307</th><td><i>	 * to the interface by the manufacturer, so it very likely</i></td></tr>
<tr><th id="308">308</th><td><i>	 * to be unique.  It MUST NOT be deleted.  It is highly</i></td></tr>
<tr><th id="309">309</th><td><i>	 * suitable for deriving the EUI64 for the interface.</i></td></tr>
<tr><th id="310">310</th><td><i>	 */</i></td></tr>
<tr><th id="311">311</th><td>	<b>struct</b> <a class="type" href="#ifaddr" title='ifaddr' data-ref="ifaddr" data-ref-filename="ifaddr">ifaddr</a>	*<dfn class="decl field" id="ifnet::if_hwdl" title='ifnet::if_hwdl' data-ref="ifnet::if_hwdl" data-ref-filename="ifnet..if_hwdl">if_hwdl</dfn>;	<i>/* i: h/w identity */</i></td></tr>
<tr><th id="312">312</th><td>	<em>const</em> <a class="typedef" href="../sys/types.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a>	*<dfn class="decl field" id="ifnet::if_broadcastaddr" title='ifnet::if_broadcastaddr' data-ref="ifnet::if_broadcastaddr" data-ref-filename="ifnet..if_broadcastaddr">if_broadcastaddr</dfn>;</td></tr>
<tr><th id="313">313</th><td>					<i>/* :: linklevel broadcast bytestring */</i></td></tr>
<tr><th id="314">314</th><td>	<b>struct</b> <a class="type" href="#bridge_softc" title='bridge_softc' data-ref="bridge_softc" data-ref-filename="bridge_softc">bridge_softc</a></td></tr>
<tr><th id="315">315</th><td>			*<dfn class="decl field" id="ifnet::if_bridge" title='ifnet::if_bridge' data-ref="ifnet::if_bridge" data-ref-filename="ifnet..if_bridge">if_bridge</dfn>;	<i>/* i: bridge glue */</i></td></tr>
<tr><th id="316">316</th><td>	<b>struct</b> <a class="type" href="#bridge_iflist" title='bridge_iflist' data-ref="bridge_iflist" data-ref-filename="bridge_iflist">bridge_iflist</a></td></tr>
<tr><th id="317">317</th><td>			*<dfn class="decl field" id="ifnet::if_bridgeif" title='ifnet::if_bridgeif' data-ref="ifnet::if_bridgeif" data-ref-filename="ifnet..if_bridgeif">if_bridgeif</dfn>;	<i>/* i: shortcut to interface list entry */</i></td></tr>
<tr><th id="318">318</th><td>	<em>int</em>		<dfn class="decl field" id="ifnet::if_dlt" title='ifnet::if_dlt' data-ref="ifnet::if_dlt" data-ref-filename="ifnet..if_dlt">if_dlt</dfn>;		<i>/* :: data link type (&lt;net/dlt.h&gt;) */</i></td></tr>
<tr><th id="319">319</th><td>	<a class="typedef" href="pfil.h.html#pfil_head_t" title='pfil_head_t' data-type='struct pfil_head' data-ref="pfil_head_t" data-ref-filename="pfil_head_t">pfil_head_t</a> *	<dfn class="decl field" id="ifnet::if_pfil" title='ifnet::if_pfil' data-ref="ifnet::if_pfil" data-ref-filename="ifnet..if_pfil">if_pfil</dfn>;	<i>/* :: filtering point */</i></td></tr>
<tr><th id="320">320</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a>	<dfn class="decl field" id="ifnet::if_capabilities" title='ifnet::if_capabilities' data-ref="ifnet::if_capabilities" data-ref-filename="ifnet..if_capabilities">if_capabilities</dfn>;</td></tr>
<tr><th id="321">321</th><td>					<i>/* i: interface capabilities */</i></td></tr>
<tr><th id="322">322</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a>	<dfn class="decl field" id="ifnet::if_capenable" title='ifnet::if_capenable' data-ref="ifnet::if_capenable" data-ref-filename="ifnet..if_capenable">if_capenable</dfn>;	<i>/* i: capabilities enabled */</i></td></tr>
<tr><th id="323">323</th><td>	<b>union</b> {</td></tr>
<tr><th id="324">324</th><td>		<em>void</em> *		<dfn class="decl field" id="ifnet::(anonymous)::carp_s" title='ifnet::(anonymous union)::carp_s' data-ref="ifnet::(anonymous)::carp_s" data-ref-filename="ifnet..(anonymous)..carp_s">carp_s</dfn>;	<i>/* carp structure (used by !carp ifs) */</i></td></tr>
<tr><th id="325">325</th><td>		<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a>	*<dfn class="decl field" id="ifnet::(anonymous)::carp_d" title='ifnet::(anonymous union)::carp_d' data-ref="ifnet::(anonymous)::carp_d" data-ref-filename="ifnet..(anonymous)..carp_d">carp_d</dfn>;<i>/* ptr to carpdev (used by carp ifs) */</i></td></tr>
<tr><th id="326">326</th><td>	}		<dfn class="decl field" id="ifnet::if_carp_ptr" title='ifnet::if_carp_ptr' data-ref="ifnet::if_carp_ptr" data-ref-filename="ifnet..if_carp_ptr">if_carp_ptr</dfn>;	<i>/* ?: */</i></td></tr>
<tr><th id="327">327</th><td><u>#define <dfn class="macro" id="_M/if_carp" data-ref="_M/if_carp">if_carp</dfn>		if_carp_ptr.carp_s</u></td></tr>
<tr><th id="328">328</th><td><u>#define <dfn class="macro" id="_M/if_carpdev" data-ref="_M/if_carpdev">if_carpdev</dfn>	if_carp_ptr.carp_d</u></td></tr>
<tr><th id="329">329</th><td>	<i>/*</i></td></tr>
<tr><th id="330">330</th><td><i>	 * These are pre-computed based on an interfaces enabled</i></td></tr>
<tr><th id="331">331</th><td><i>	 * capabilities, for speed elsewhere.</i></td></tr>
<tr><th id="332">332</th><td><i>	 */</i></td></tr>
<tr><th id="333">333</th><td>	<em>int</em>		<dfn class="decl field" id="ifnet::if_csum_flags_tx" title='ifnet::if_csum_flags_tx' data-ref="ifnet::if_csum_flags_tx" data-ref-filename="ifnet..if_csum_flags_tx">if_csum_flags_tx</dfn>;</td></tr>
<tr><th id="334">334</th><td>					<i>/* i: M_CSUM_* flags for Tx */</i></td></tr>
<tr><th id="335">335</th><td>	<em>int</em>		<dfn class="decl field" id="ifnet::if_csum_flags_rx" title='ifnet::if_csum_flags_rx' data-ref="ifnet::if_csum_flags_rx" data-ref-filename="ifnet..if_csum_flags_rx">if_csum_flags_rx</dfn>;</td></tr>
<tr><th id="336">336</th><td>					<i>/* i: M_CSUM_* flags for Rx */</i></td></tr>
<tr><th id="337">337</th><td></td></tr>
<tr><th id="338">338</th><td>	<em>void</em>		*<dfn class="decl field" id="ifnet::if_afdata" title='ifnet::if_afdata' data-ref="ifnet::if_afdata" data-ref-filename="ifnet..if_afdata">if_afdata</dfn>[<a class="macro" href="../sys/socket.h.html#249" title="37" data-ref="_M/AF_MAX">AF_MAX</a>];</td></tr>
<tr><th id="339">339</th><td>					<i>/* a: */</i></td></tr>
<tr><th id="340">340</th><td>	<b>struct</b> <dfn class="type" id="mowner" title='mowner' data-ref="mowner" data-ref-filename="mowner"><a class="type" href="#mowner" title='mowner' data-ref="mowner" data-ref-filename="mowner">mowner</a></dfn>	*<dfn class="decl field" id="ifnet::if_mowner" title='ifnet::if_mowner' data-ref="ifnet::if_mowner" data-ref-filename="ifnet..if_mowner">if_mowner</dfn>;	<i>/* ?: who owns mbufs for this interface */</i></td></tr>
<tr><th id="341">341</th><td></td></tr>
<tr><th id="342">342</th><td>	<em>void</em>		*<dfn class="decl field" id="ifnet::if_agrprivate" title='ifnet::if_agrprivate' data-ref="ifnet::if_agrprivate" data-ref-filename="ifnet..if_agrprivate">if_agrprivate</dfn>;	<i>/* ?: used only when #if NAGR &gt; 0 */</i></td></tr>
<tr><th id="343">343</th><td></td></tr>
<tr><th id="344">344</th><td>	<i>/*</i></td></tr>
<tr><th id="345">345</th><td><i>	 * pf specific data, used only when #if NPF &gt; 0.</i></td></tr>
<tr><th id="346">346</th><td><i>	 */</i></td></tr>
<tr><th id="347">347</th><td>	<em>void</em>		*<dfn class="decl field" id="ifnet::if_pf_kif" title='ifnet::if_pf_kif' data-ref="ifnet::if_pf_kif" data-ref-filename="ifnet..if_pf_kif">if_pf_kif</dfn>;	<i>/* ?: pf interface abstraction */</i></td></tr>
<tr><th id="348">348</th><td>	<em>void</em>		*<dfn class="decl field" id="ifnet::if_pf_groups" title='ifnet::if_pf_groups' data-ref="ifnet::if_pf_groups" data-ref-filename="ifnet..if_pf_groups">if_pf_groups</dfn>;	<i>/* ?: pf interface groups */</i></td></tr>
<tr><th id="349">349</th><td>	<i>/*</i></td></tr>
<tr><th id="350">350</th><td><i>	 * During an ifnet's lifetime, it has only one if_index, but</i></td></tr>
<tr><th id="351">351</th><td><i>	 * and if_index is not sufficient to identify an ifnet</i></td></tr>
<tr><th id="352">352</th><td><i>	 * because during the lifetime of the system, many ifnets may occupy a</i></td></tr>
<tr><th id="353">353</th><td><i>	 * given if_index.  Let us tell different ifnets at the same</i></td></tr>
<tr><th id="354">354</th><td><i>	 * if_index apart by their if_index_gen, a unique number that each ifnet</i></td></tr>
<tr><th id="355">355</th><td><i>	 * is assigned when it if_attach()s.  Now, the kernel can use the</i></td></tr>
<tr><th id="356">356</th><td><i>	 * pair (if_index, if_index_gen) as a weak reference to an ifnet.</i></td></tr>
<tr><th id="357">357</th><td><i>	 */</i></td></tr>
<tr><th id="358">358</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a>	<dfn class="decl field" id="ifnet::if_index_gen" title='ifnet::if_index_gen' data-ref="ifnet::if_index_gen" data-ref-filename="ifnet..if_index_gen">if_index_gen</dfn>;	<i>/* :: generation number for the ifnet</i></td></tr>
<tr><th id="359">359</th><td><i>					 * at if_index: if two ifnets' index</i></td></tr>
<tr><th id="360">360</th><td><i>					 * and generation number are both the</i></td></tr>
<tr><th id="361">361</th><td><i>					 * same, they are the same ifnet.</i></td></tr>
<tr><th id="362">362</th><td><i>					 */</i></td></tr>
<tr><th id="363">363</th><td>	<b>struct</b> <dfn class="type" id="sysctllog" title='sysctllog' data-ref="sysctllog" data-ref-filename="sysctllog"><a class="type" href="#sysctllog" title='sysctllog' data-ref="sysctllog" data-ref-filename="sysctllog">sysctllog</a></dfn></td></tr>
<tr><th id="364">364</th><td>			*<dfn class="decl field" id="ifnet::if_sysctl_log" title='ifnet::if_sysctl_log' data-ref="ifnet::if_sysctl_log" data-ref-filename="ifnet..if_sysctl_log">if_sysctl_log</dfn>;	<i>/* :: */</i></td></tr>
<tr><th id="365">365</th><td>	<em>int</em>		(*<dfn class="decl field" id="ifnet::if_initaddr" title='ifnet::if_initaddr' data-ref="ifnet::if_initaddr" data-ref-filename="ifnet..if_initaddr">if_initaddr</dfn>)  <i>/* :: */</i></td></tr>
<tr><th id="366">366</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *, <b>struct</b> <a class="type" href="#ifaddr" title='ifaddr' data-ref="ifaddr" data-ref-filename="ifaddr">ifaddr</a> *, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span>);</td></tr>
<tr><th id="367">367</th><td>	<em>int</em>		(*<dfn class="decl field" id="ifnet::if_mcastop" title='ifnet::if_mcastop' data-ref="ifnet::if_mcastop" data-ref-filename="ifnet..if_mcastop">if_mcastop</dfn>)	<i>/* :: */</i></td></tr>
<tr><th id="368">368</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *, <em>const</em> <em>unsigned</em> <em>long</em>,</td></tr>
<tr><th id="369">369</th><td>			    <em>const</em> <b>struct</b> <a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *);</td></tr>
<tr><th id="370">370</th><td>	<em>int</em>		(*<dfn class="decl field" id="ifnet::if_setflags" title='ifnet::if_setflags' data-ref="ifnet::if_setflags" data-ref-filename="ifnet..if_setflags">if_setflags</dfn>)	<i>/* :: */</i></td></tr>
<tr><th id="371">371</th><td>			    (<b>struct</b> <a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *, <em>const</em> <em>short</em>);</td></tr>
<tr><th id="372">372</th><td>	<a class="typedef" href="../sys/mutex.h.html#kmutex_t" title='kmutex_t' data-type='struct kmutex' data-ref="kmutex_t" data-ref-filename="kmutex_t">kmutex_t</a>	*<dfn class="decl field" id="ifnet::if_ioctl_lock" title='ifnet::if_ioctl_lock' data-ref="ifnet::if_ioctl_lock" data-ref-filename="ifnet..if_ioctl_lock">if_ioctl_lock</dfn>;	<i>/* :: */</i></td></tr>
<tr><th id="373">373</th><td>	<em>char</em>		*<dfn class="decl field" id="ifnet::if_description" title='ifnet::if_description' data-ref="ifnet::if_description" data-ref-filename="ifnet..if_description">if_description</dfn>;	<i>/* i: interface description */</i></td></tr>
<tr><th id="374">374</th><td><u>#<span data-ppcond="374">ifdef</span> <span class="macro" data-ref="_M/_KERNEL">_KERNEL</span> /* XXX kvm(3) */</u></td></tr>
<tr><th id="375">375</th><td>	<b>struct</b> callout	*if_slowtimo_ch;<i>/* :: */</i></td></tr>
<tr><th id="376">376</th><td>	<b>struct</b> krwlock	*if_afdata_lock;<i>/* :: */</i></td></tr>
<tr><th id="377">377</th><td>	<b>struct</b> if_percpuq</td></tr>
<tr><th id="378">378</th><td>			*if_percpuq;	<i>/* :: we should remove it in the future */</i></td></tr>
<tr><th id="379">379</th><td>	<em>void</em>		*if_link_si;	<i>/* :: softint to handle link state changes */</i></td></tr>
<tr><th id="380">380</th><td>	uint16_t	if_link_queue;	<i>/* q: masked link state change queue */</i></td></tr>
<tr><th id="381">381</th><td>	<b>struct</b> pslist_entry</td></tr>
<tr><th id="382">382</th><td>			if_pslist_entry;<i>/* i: */</i></td></tr>
<tr><th id="383">383</th><td>	<b>struct</b> psref_target</td></tr>
<tr><th id="384">384</th><td>			if_psref;	<i>/* :: */</i></td></tr>
<tr><th id="385">385</th><td>	<b>struct</b> pslist_head</td></tr>
<tr><th id="386">386</th><td>			if_addr_pslist;	<i>/* i: */</i></td></tr>
<tr><th id="387">387</th><td>	<b>struct</b> if_deferred_start</td></tr>
<tr><th id="388">388</th><td>			*if_deferred_start;</td></tr>
<tr><th id="389">389</th><td>					<i>/* :: */</i></td></tr>
<tr><th id="390">390</th><td>	<i>/* XXX should be protocol independent */</i></td></tr>
<tr><th id="391">391</th><td>	LIST_HEAD(, in6_multi)</td></tr>
<tr><th id="392">392</th><td>			if_multiaddrs;	<i>/* 6: */</i></td></tr>
<tr><th id="393">393</th><td><u>#<span data-ppcond="374">endif</span></u></td></tr>
<tr><th id="394">394</th><td>} <dfn class="typedef" id="ifnet_t" title='ifnet_t' data-type='struct ifnet' data-ref="ifnet_t" data-ref-filename="ifnet_t">ifnet_t</dfn>;</td></tr>
<tr><th id="395">395</th><td> </td></tr>
<tr><th id="396">396</th><td><u>#define	<dfn class="macro" id="_M/if_mtu" data-ref="_M/if_mtu">if_mtu</dfn>		if_data.ifi_mtu</u></td></tr>
<tr><th id="397">397</th><td><u>#define	<dfn class="macro" id="_M/if_type" data-ref="_M/if_type">if_type</dfn>		if_data.ifi_type</u></td></tr>
<tr><th id="398">398</th><td><u>#define	<dfn class="macro" id="_M/if_addrlen" data-ref="_M/if_addrlen">if_addrlen</dfn>	if_data.ifi_addrlen</u></td></tr>
<tr><th id="399">399</th><td><u>#define	<dfn class="macro" id="_M/if_hdrlen" data-ref="_M/if_hdrlen">if_hdrlen</dfn>	if_data.ifi_hdrlen</u></td></tr>
<tr><th id="400">400</th><td><u>#define	<dfn class="macro" id="_M/if_metric" data-ref="_M/if_metric">if_metric</dfn>	if_data.ifi_metric</u></td></tr>
<tr><th id="401">401</th><td><u>#define	<dfn class="macro" id="_M/if_link_state" data-ref="_M/if_link_state">if_link_state</dfn>	if_data.ifi_link_state</u></td></tr>
<tr><th id="402">402</th><td><u>#define	<dfn class="macro" id="_M/if_baudrate" data-ref="_M/if_baudrate">if_baudrate</dfn>	if_data.ifi_baudrate</u></td></tr>
<tr><th id="403">403</th><td><u>#define	<dfn class="macro" id="_M/if_ipackets" data-ref="_M/if_ipackets">if_ipackets</dfn>	if_data.ifi_ipackets</u></td></tr>
<tr><th id="404">404</th><td><u>#define	<dfn class="macro" id="_M/if_ierrors" data-ref="_M/if_ierrors">if_ierrors</dfn>	if_data.ifi_ierrors</u></td></tr>
<tr><th id="405">405</th><td><u>#define	<dfn class="macro" id="_M/if_opackets" data-ref="_M/if_opackets">if_opackets</dfn>	if_data.ifi_opackets</u></td></tr>
<tr><th id="406">406</th><td><u>#define	<dfn class="macro" id="_M/if_oerrors" data-ref="_M/if_oerrors">if_oerrors</dfn>	if_data.ifi_oerrors</u></td></tr>
<tr><th id="407">407</th><td><u>#define	<dfn class="macro" id="_M/if_collisions" data-ref="_M/if_collisions">if_collisions</dfn>	if_data.ifi_collisions</u></td></tr>
<tr><th id="408">408</th><td><u>#define	<dfn class="macro" id="_M/if_ibytes" data-ref="_M/if_ibytes">if_ibytes</dfn>	if_data.ifi_ibytes</u></td></tr>
<tr><th id="409">409</th><td><u>#define	<dfn class="macro" id="_M/if_obytes" data-ref="_M/if_obytes">if_obytes</dfn>	if_data.ifi_obytes</u></td></tr>
<tr><th id="410">410</th><td><u>#define	<dfn class="macro" id="_M/if_imcasts" data-ref="_M/if_imcasts">if_imcasts</dfn>	if_data.ifi_imcasts</u></td></tr>
<tr><th id="411">411</th><td><u>#define	<dfn class="macro" id="_M/if_omcasts" data-ref="_M/if_omcasts">if_omcasts</dfn>	if_data.ifi_omcasts</u></td></tr>
<tr><th id="412">412</th><td><u>#define	<dfn class="macro" id="_M/if_iqdrops" data-ref="_M/if_iqdrops">if_iqdrops</dfn>	if_data.ifi_iqdrops</u></td></tr>
<tr><th id="413">413</th><td><u>#define	<dfn class="macro" id="_M/if_noproto" data-ref="_M/if_noproto">if_noproto</dfn>	if_data.ifi_noproto</u></td></tr>
<tr><th id="414">414</th><td><u>#define	<dfn class="macro" id="_M/if_lastchange" data-ref="_M/if_lastchange">if_lastchange</dfn>	if_data.ifi_lastchange</u></td></tr>
<tr><th id="415">415</th><td><u>#define	<dfn class="macro" id="_M/if_name" data-ref="_M/if_name">if_name</dfn>(ifp)	((ifp)-&gt;if_xname)</u></td></tr>
<tr><th id="416">416</th><td></td></tr>
<tr><th id="417">417</th><td><u>#define	<dfn class="macro" id="_M/IFF_UP" data-ref="_M/IFF_UP">IFF_UP</dfn>		0x0001		/* interface is up */</u></td></tr>
<tr><th id="418">418</th><td><u>#define	<dfn class="macro" id="_M/IFF_BROADCAST" data-ref="_M/IFF_BROADCAST">IFF_BROADCAST</dfn>	0x0002		/* broadcast address valid */</u></td></tr>
<tr><th id="419">419</th><td><u>#define	<dfn class="macro" id="_M/IFF_DEBUG" data-ref="_M/IFF_DEBUG">IFF_DEBUG</dfn>	0x0004		/* turn on debugging */</u></td></tr>
<tr><th id="420">420</th><td><u>#define	<dfn class="macro" id="_M/IFF_LOOPBACK" data-ref="_M/IFF_LOOPBACK">IFF_LOOPBACK</dfn>	0x0008		/* is a loopback net */</u></td></tr>
<tr><th id="421">421</th><td><u>#define	<dfn class="macro" id="_M/IFF_POINTOPOINT" data-ref="_M/IFF_POINTOPOINT">IFF_POINTOPOINT</dfn>	0x0010		/* interface is point-to-point link */</u></td></tr>
<tr><th id="422">422</th><td><i>/*			0x0020		   was IFF_NOTRAILERS */</i></td></tr>
<tr><th id="423">423</th><td><u>#define	<dfn class="macro" id="_M/IFF_RUNNING" data-ref="_M/IFF_RUNNING">IFF_RUNNING</dfn>	0x0040		/* resources allocated */</u></td></tr>
<tr><th id="424">424</th><td><u>#define	<dfn class="macro" id="_M/IFF_NOARP" data-ref="_M/IFF_NOARP">IFF_NOARP</dfn>	0x0080		/* no address resolution protocol */</u></td></tr>
<tr><th id="425">425</th><td><u>#define	<dfn class="macro" id="_M/IFF_PROMISC" data-ref="_M/IFF_PROMISC">IFF_PROMISC</dfn>	0x0100		/* receive all packets */</u></td></tr>
<tr><th id="426">426</th><td><u>#define	<dfn class="macro" id="_M/IFF_ALLMULTI" data-ref="_M/IFF_ALLMULTI">IFF_ALLMULTI</dfn>	0x0200		/* receive all multicast packets */</u></td></tr>
<tr><th id="427">427</th><td><u>#define	<dfn class="macro" id="_M/IFF_OACTIVE" data-ref="_M/IFF_OACTIVE">IFF_OACTIVE</dfn>	0x0400		/* transmission in progress */</u></td></tr>
<tr><th id="428">428</th><td><u>#define	<dfn class="macro" id="_M/IFF_SIMPLEX" data-ref="_M/IFF_SIMPLEX">IFF_SIMPLEX</dfn>	0x0800		/* can't hear own transmissions */</u></td></tr>
<tr><th id="429">429</th><td><u>#define	<dfn class="macro" id="_M/IFF_LINK0" data-ref="_M/IFF_LINK0">IFF_LINK0</dfn>	0x1000		/* per link layer defined bit */</u></td></tr>
<tr><th id="430">430</th><td><u>#define	<dfn class="macro" id="_M/IFF_LINK1" data-ref="_M/IFF_LINK1">IFF_LINK1</dfn>	0x2000		/* per link layer defined bit */</u></td></tr>
<tr><th id="431">431</th><td><u>#define	<dfn class="macro" id="_M/IFF_LINK2" data-ref="_M/IFF_LINK2">IFF_LINK2</dfn>	0x4000		/* per link layer defined bit */</u></td></tr>
<tr><th id="432">432</th><td><u>#define	<dfn class="macro" id="_M/IFF_MULTICAST" data-ref="_M/IFF_MULTICAST">IFF_MULTICAST</dfn>	0x8000		/* supports multicast */</u></td></tr>
<tr><th id="433">433</th><td></td></tr>
<tr><th id="434">434</th><td><u>#define	<dfn class="macro" id="_M/IFEF_MPSAFE" data-ref="_M/IFEF_MPSAFE">IFEF_MPSAFE</dfn>			__BIT(0)	/* handlers can run in parallel (see below) */</u></td></tr>
<tr><th id="435">435</th><td><u>#define	<dfn class="macro" id="_M/IFEF_NO_LINK_STATE_CHANGE" data-ref="_M/IFEF_NO_LINK_STATE_CHANGE">IFEF_NO_LINK_STATE_CHANGE</dfn>	__BIT(1)	/* doesn't use link state interrupts */</u></td></tr>
<tr><th id="436">436</th><td></td></tr>
<tr><th id="437">437</th><td><i>/*</i></td></tr>
<tr><th id="438">438</th><td><i> * The guidelines for converting an interface to IFEF_MPSAFE are as follows</i></td></tr>
<tr><th id="439">439</th><td><i> *</i></td></tr>
<tr><th id="440">440</th><td><i> * Enabling IFEF_MPSAFE on an interface suppresses taking KERNEL_LOCK when</i></td></tr>
<tr><th id="441">441</th><td><i> * calling the following handlers:</i></td></tr>
<tr><th id="442">442</th><td><i> * - if_start</i></td></tr>
<tr><th id="443">443</th><td><i> *   - Note that if_transmit is always called without KERNEL_LOCK</i></td></tr>
<tr><th id="444">444</th><td><i> * - if_output</i></td></tr>
<tr><th id="445">445</th><td><i> * - if_ioctl</i></td></tr>
<tr><th id="446">446</th><td><i> * - if_init</i></td></tr>
<tr><th id="447">447</th><td><i> * - if_stop</i></td></tr>
<tr><th id="448">448</th><td><i> *</i></td></tr>
<tr><th id="449">449</th><td><i> * This means that an interface with IFEF_MPSAFE must make the above handlers</i></td></tr>
<tr><th id="450">450</th><td><i> * MP-safe or take KERNEL_LOCK by itself inside handlers that aren't MP-safe</i></td></tr>
<tr><th id="451">451</th><td><i> * yet.</i></td></tr>
<tr><th id="452">452</th><td><i> *</i></td></tr>
<tr><th id="453">453</th><td><i> * There are some additional restrictions to access member variables of struct</i></td></tr>
<tr><th id="454">454</th><td><i> * ifnet:</i></td></tr>
<tr><th id="455">455</th><td><i> * - if_flags</i></td></tr>
<tr><th id="456">456</th><td><i> *   - Must be updated with holding IFNET_LOCK</i></td></tr>
<tr><th id="457">457</th><td><i> *   - You cannot use the flag in Tx/Rx paths anymore because there is no</i></td></tr>
<tr><th id="458">458</th><td><i> *     synchronization on the flag except for IFNET_LOCK</i></td></tr>
<tr><th id="459">459</th><td><i> *   - Note that IFNET_LOCK can't be taken in softint because it's known</i></td></tr>
<tr><th id="460">460</th><td><i> *     that it causes a deadlock</i></td></tr>
<tr><th id="461">461</th><td><i> *     - Some synchronization mechanisms such as pserialize_perform are called</i></td></tr>
<tr><th id="462">462</th><td><i> *       with IFNET_LOCK and also require context switches on every CPUs</i></td></tr>
<tr><th id="463">463</th><td><i> *       that mean softints finish so trying to take IFNET_LOCK in softint</i></td></tr>
<tr><th id="464">464</th><td><i> *       might block on IFNET_LOCK and prevent such synchronization mechanisms</i></td></tr>
<tr><th id="465">465</th><td><i> *       from being completed</i></td></tr>
<tr><th id="466">466</th><td><i> *     - Currently the deadlock occurs only if NET_MPSAFE is enabled, however,</i></td></tr>
<tr><th id="467">467</th><td><i> *       we should deal with the restriction because NET_MPSAFE will be enabled</i></td></tr>
<tr><th id="468">468</th><td><i> *       by default in the future</i></td></tr>
<tr><th id="469">469</th><td><i> * - if_watchdog and if_timer</i></td></tr>
<tr><th id="470">470</th><td><i> *   - The watchdog framework works only for non-IFEF_MPSAFE interfaces</i></td></tr>
<tr><th id="471">471</th><td><i> *     that rely on KERNEL_LOCK</i></td></tr>
<tr><th id="472">472</th><td><i> *   - Interfaces with IFEF_MPSAFE have to provide its own watchdog mechanism</i></td></tr>
<tr><th id="473">473</th><td><i> *     if needed</i></td></tr>
<tr><th id="474">474</th><td><i> *     - Keep if_watchdog NULL when calling if_attach</i></td></tr>
<tr><th id="475">475</th><td><i> */</i></td></tr>
<tr><th id="476">476</th><td></td></tr>
<tr><th id="477">477</th><td><u>#<span data-ppcond="477">ifdef</span> <span class="macro" data-ref="_M/_KERNEL">_KERNEL</span></u></td></tr>
<tr><th id="478">478</th><td><em>static</em> <b>__inline</b> bool</td></tr>
<tr><th id="479">479</th><td>if_is_mpsafe(<b>struct</b> ifnet *ifp)</td></tr>
<tr><th id="480">480</th><td>{</td></tr>
<tr><th id="481">481</th><td></td></tr>
<tr><th id="482">482</th><td>	<b>return</b> ((ifp-&gt;if_extflags &amp; IFEF_MPSAFE) != <var>0</var>);</td></tr>
<tr><th id="483">483</th><td>}</td></tr>
<tr><th id="484">484</th><td></td></tr>
<tr><th id="485">485</th><td><em>static</em> <b>__inline</b> <em>int</em></td></tr>
<tr><th id="486">486</th><td>if_output_lock(<b>struct</b> ifnet *cifp, <b>struct</b> ifnet *ifp, <b>struct</b> mbuf *m,</td></tr>
<tr><th id="487">487</th><td>    <em>const</em> <b>struct</b> sockaddr *dst, <em>const</em> <b>struct</b> rtentry *rt)</td></tr>
<tr><th id="488">488</th><td>{</td></tr>
<tr><th id="489">489</th><td></td></tr>
<tr><th id="490">490</th><td>	<b>if</b> (if_is_mpsafe(cifp)) {</td></tr>
<tr><th id="491">491</th><td>		<b>return</b> (*cifp-&gt;if_output)(ifp, m, dst, rt);</td></tr>
<tr><th id="492">492</th><td>	} <b>else</b> {</td></tr>
<tr><th id="493">493</th><td>		<em>int</em> ret;</td></tr>
<tr><th id="494">494</th><td></td></tr>
<tr><th id="495">495</th><td>		KERNEL_LOCK(<var>1</var>, NULL);</td></tr>
<tr><th id="496">496</th><td>		ret = (*cifp-&gt;if_output)(ifp, m, dst, rt);</td></tr>
<tr><th id="497">497</th><td>		KERNEL_UNLOCK_ONE(NULL);</td></tr>
<tr><th id="498">498</th><td>		<b>return</b> ret;</td></tr>
<tr><th id="499">499</th><td>	}</td></tr>
<tr><th id="500">500</th><td>}</td></tr>
<tr><th id="501">501</th><td></td></tr>
<tr><th id="502">502</th><td><em>static</em> <b>__inline</b> <em>void</em></td></tr>
<tr><th id="503">503</th><td>if_start_lock(<b>struct</b> ifnet *ifp)</td></tr>
<tr><th id="504">504</th><td>{</td></tr>
<tr><th id="505">505</th><td></td></tr>
<tr><th id="506">506</th><td>	<b>if</b> (if_is_mpsafe(ifp)) {</td></tr>
<tr><th id="507">507</th><td>		(*ifp-&gt;if_start)(ifp);</td></tr>
<tr><th id="508">508</th><td>	} <b>else</b> {</td></tr>
<tr><th id="509">509</th><td>		KERNEL_LOCK(<var>1</var>, NULL);</td></tr>
<tr><th id="510">510</th><td>		(*ifp-&gt;if_start)(ifp);</td></tr>
<tr><th id="511">511</th><td>		KERNEL_UNLOCK_ONE(NULL);</td></tr>
<tr><th id="512">512</th><td>	}</td></tr>
<tr><th id="513">513</th><td>}</td></tr>
<tr><th id="514">514</th><td></td></tr>
<tr><th id="515">515</th><td><em>static</em> <b>__inline</b> bool</td></tr>
<tr><th id="516">516</th><td>if_is_link_state_changeable(<b>struct</b> ifnet *ifp)</td></tr>
<tr><th id="517">517</th><td>{</td></tr>
<tr><th id="518">518</th><td></td></tr>
<tr><th id="519">519</th><td>	<b>return</b> ((ifp-&gt;if_extflags &amp; IFEF_NO_LINK_STATE_CHANGE) == <var>0</var>);</td></tr>
<tr><th id="520">520</th><td>}</td></tr>
<tr><th id="521">521</th><td></td></tr>
<tr><th id="522">522</th><td><u>#define KERNEL_LOCK_IF_IFP_MPSAFE(ifp)					\</u></td></tr>
<tr><th id="523">523</th><td><u>	do { if (if_is_mpsafe(ifp)) { KERNEL_LOCK(1, NULL); } } while (0)</u></td></tr>
<tr><th id="524">524</th><td><u>#define KERNEL_UNLOCK_IF_IFP_MPSAFE(ifp)				\</u></td></tr>
<tr><th id="525">525</th><td><u>	do { if (if_is_mpsafe(ifp)) { KERNEL_UNLOCK_ONE(NULL); } } while (0)</u></td></tr>
<tr><th id="526">526</th><td></td></tr>
<tr><th id="527">527</th><td><u>#define KERNEL_LOCK_UNLESS_IFP_MPSAFE(ifp)				\</u></td></tr>
<tr><th id="528">528</th><td><u>	do { if (!if_is_mpsafe(ifp)) { KERNEL_LOCK(1, NULL); } } while (0)</u></td></tr>
<tr><th id="529">529</th><td><u>#define KERNEL_UNLOCK_UNLESS_IFP_MPSAFE(ifp)				\</u></td></tr>
<tr><th id="530">530</th><td><u>	do { if (!if_is_mpsafe(ifp)) { KERNEL_UNLOCK_ONE(NULL); } } while (0)</u></td></tr>
<tr><th id="531">531</th><td></td></tr>
<tr><th id="532">532</th><td><u>#ifdef _KERNEL_OPT</u></td></tr>
<tr><th id="533">533</th><td><u>#include "opt_net_mpsafe.h"</u></td></tr>
<tr><th id="534">534</th><td><u>#endif</u></td></tr>
<tr><th id="535">535</th><td></td></tr>
<tr><th id="536">536</th><td><i>/* XXX explore a better place to define */</i></td></tr>
<tr><th id="537">537</th><td><u>#ifdef NET_MPSAFE</u></td></tr>
<tr><th id="538">538</th><td></td></tr>
<tr><th id="539">539</th><td><u>#define KERNEL_LOCK_UNLESS_NET_MPSAFE()		do { } while (0)</u></td></tr>
<tr><th id="540">540</th><td><u>#define KERNEL_UNLOCK_UNLESS_NET_MPSAFE()	do { } while (0)</u></td></tr>
<tr><th id="541">541</th><td></td></tr>
<tr><th id="542">542</th><td><u>#define SOFTNET_LOCK_UNLESS_NET_MPSAFE()	do { } while (0)</u></td></tr>
<tr><th id="543">543</th><td><u>#define SOFTNET_UNLOCK_UNLESS_NET_MPSAFE()	do { } while (0)</u></td></tr>
<tr><th id="544">544</th><td></td></tr>
<tr><th id="545">545</th><td><u>#define SOFTNET_LOCK_IF_NET_MPSAFE()					\</u></td></tr>
<tr><th id="546">546</th><td><u>	do { mutex_enter(softnet_lock); } while (0)</u></td></tr>
<tr><th id="547">547</th><td><u>#define SOFTNET_UNLOCK_IF_NET_MPSAFE()					\</u></td></tr>
<tr><th id="548">548</th><td><u>	do { mutex_exit(softnet_lock); } while (0)</u></td></tr>
<tr><th id="549">549</th><td></td></tr>
<tr><th id="550">550</th><td><u>#else /* NET_MPSAFE */</u></td></tr>
<tr><th id="551">551</th><td></td></tr>
<tr><th id="552">552</th><td><u>#define KERNEL_LOCK_UNLESS_NET_MPSAFE()					\</u></td></tr>
<tr><th id="553">553</th><td><u>	do { KERNEL_LOCK(1, NULL); } while (0)</u></td></tr>
<tr><th id="554">554</th><td><u>#define KERNEL_UNLOCK_UNLESS_NET_MPSAFE()				\</u></td></tr>
<tr><th id="555">555</th><td><u>	do { KERNEL_UNLOCK_ONE(NULL); } while (0)</u></td></tr>
<tr><th id="556">556</th><td></td></tr>
<tr><th id="557">557</th><td><u>#define SOFTNET_LOCK_UNLESS_NET_MPSAFE()				\</u></td></tr>
<tr><th id="558">558</th><td><u>	do { mutex_enter(softnet_lock); } while (0)</u></td></tr>
<tr><th id="559">559</th><td><u>#define SOFTNET_UNLOCK_UNLESS_NET_MPSAFE()				\</u></td></tr>
<tr><th id="560">560</th><td><u>	do { mutex_exit(softnet_lock); } while (0)</u></td></tr>
<tr><th id="561">561</th><td></td></tr>
<tr><th id="562">562</th><td><u>#define SOFTNET_LOCK_IF_NET_MPSAFE()		do { } while (0)</u></td></tr>
<tr><th id="563">563</th><td><u>#define SOFTNET_UNLOCK_IF_NET_MPSAFE()		do { } while (0)</u></td></tr>
<tr><th id="564">564</th><td></td></tr>
<tr><th id="565">565</th><td><u>#endif /* NET_MPSAFE */</u></td></tr>
<tr><th id="566">566</th><td></td></tr>
<tr><th id="567">567</th><td><u>#define SOFTNET_KERNEL_LOCK_UNLESS_NET_MPSAFE()				\</u></td></tr>
<tr><th id="568">568</th><td><u>	do {								\</u></td></tr>
<tr><th id="569">569</th><td><u>		SOFTNET_LOCK_UNLESS_NET_MPSAFE();			\</u></td></tr>
<tr><th id="570">570</th><td><u>		KERNEL_LOCK_UNLESS_NET_MPSAFE();			\</u></td></tr>
<tr><th id="571">571</th><td><u>	} while (0)</u></td></tr>
<tr><th id="572">572</th><td></td></tr>
<tr><th id="573">573</th><td><u>#define SOFTNET_KERNEL_UNLOCK_UNLESS_NET_MPSAFE()			\</u></td></tr>
<tr><th id="574">574</th><td><u>	do {								\</u></td></tr>
<tr><th id="575">575</th><td><u>		KERNEL_UNLOCK_UNLESS_NET_MPSAFE();			\</u></td></tr>
<tr><th id="576">576</th><td><u>		SOFTNET_UNLOCK_UNLESS_NET_MPSAFE();			\</u></td></tr>
<tr><th id="577">577</th><td><u>	} while (0)</u></td></tr>
<tr><th id="578">578</th><td></td></tr>
<tr><th id="579">579</th><td><u>#<span data-ppcond="477">endif</span> /* _KERNEL */</u></td></tr>
<tr><th id="580">580</th><td></td></tr>
<tr><th id="581">581</th><td><u>#define	<dfn class="macro" id="_M/IFFBITS" data-ref="_M/IFFBITS">IFFBITS</dfn> \</u></td></tr>
<tr><th id="582">582</th><td><u>    "\020\1UP\2BROADCAST\3DEBUG\4LOOPBACK\5POINTOPOINT" \</u></td></tr>
<tr><th id="583">583</th><td><u>    "\7RUNNING\10NOARP\11PROMISC\12ALLMULTI\13OACTIVE\14SIMPLEX" \</u></td></tr>
<tr><th id="584">584</th><td><u>    "\15LINK0\16LINK1\17LINK2\20MULTICAST"</u></td></tr>
<tr><th id="585">585</th><td></td></tr>
<tr><th id="586">586</th><td><i>/* flags set internally only: */</i></td></tr>
<tr><th id="587">587</th><td><u>#define	<dfn class="macro" id="_M/IFF_CANTCHANGE" data-ref="_M/IFF_CANTCHANGE">IFF_CANTCHANGE</dfn> \</u></td></tr>
<tr><th id="588">588</th><td><u>	(IFF_BROADCAST|IFF_POINTOPOINT|IFF_RUNNING|IFF_OACTIVE|\</u></td></tr>
<tr><th id="589">589</th><td><u>	    IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI|IFF_PROMISC)</u></td></tr>
<tr><th id="590">590</th><td></td></tr>
<tr><th id="591">591</th><td><i>/*</i></td></tr>
<tr><th id="592">592</th><td><i> * Some convenience macros used for setting ifi_baudrate.</i></td></tr>
<tr><th id="593">593</th><td><i> */</i></td></tr>
<tr><th id="594">594</th><td><u>#define	<dfn class="macro" id="_M/IF_Kbps" data-ref="_M/IF_Kbps">IF_Kbps</dfn>(x)	((x) * 1000ULL)			/* kilobits/sec. */</u></td></tr>
<tr><th id="595">595</th><td><u>#define	<dfn class="macro" id="_M/IF_Mbps" data-ref="_M/IF_Mbps">IF_Mbps</dfn>(x)	(IF_Kbps((x) * 1000ULL))	/* megabits/sec. */</u></td></tr>
<tr><th id="596">596</th><td><u>#define	<dfn class="macro" id="_M/IF_Gbps" data-ref="_M/IF_Gbps">IF_Gbps</dfn>(x)	(IF_Mbps((x) * 1000ULL))	/* gigabits/sec. */</u></td></tr>
<tr><th id="597">597</th><td></td></tr>
<tr><th id="598">598</th><td><i>/* Capabilities that interfaces can advertise. */</i></td></tr>
<tr><th id="599">599</th><td>					<i>/* 0x01 .. 0x40 were previously used */</i></td></tr>
<tr><th id="600">600</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_TSOv4" data-ref="_M/IFCAP_TSOv4">IFCAP_TSOv4</dfn>		0x00080	/* can do TCPv4 segmentation offload */</u></td></tr>
<tr><th id="601">601</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_CSUM_IPv4_Rx" data-ref="_M/IFCAP_CSUM_IPv4_Rx">IFCAP_CSUM_IPv4_Rx</dfn>	0x00100	/* can do IPv4 header checksums (Rx) */</u></td></tr>
<tr><th id="602">602</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_CSUM_IPv4_Tx" data-ref="_M/IFCAP_CSUM_IPv4_Tx">IFCAP_CSUM_IPv4_Tx</dfn>	0x00200	/* can do IPv4 header checksums (Tx) */</u></td></tr>
<tr><th id="603">603</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_CSUM_TCPv4_Rx" data-ref="_M/IFCAP_CSUM_TCPv4_Rx">IFCAP_CSUM_TCPv4_Rx</dfn>	0x00400	/* can do IPv4/TCP checksums (Rx) */</u></td></tr>
<tr><th id="604">604</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_CSUM_TCPv4_Tx" data-ref="_M/IFCAP_CSUM_TCPv4_Tx">IFCAP_CSUM_TCPv4_Tx</dfn>	0x00800	/* can do IPv4/TCP checksums (Tx) */</u></td></tr>
<tr><th id="605">605</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_CSUM_UDPv4_Rx" data-ref="_M/IFCAP_CSUM_UDPv4_Rx">IFCAP_CSUM_UDPv4_Rx</dfn>	0x01000	/* can do IPv4/UDP checksums (Rx) */</u></td></tr>
<tr><th id="606">606</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_CSUM_UDPv4_Tx" data-ref="_M/IFCAP_CSUM_UDPv4_Tx">IFCAP_CSUM_UDPv4_Tx</dfn>	0x02000	/* can do IPv4/UDP checksums (Tx) */</u></td></tr>
<tr><th id="607">607</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_CSUM_TCPv6_Rx" data-ref="_M/IFCAP_CSUM_TCPv6_Rx">IFCAP_CSUM_TCPv6_Rx</dfn>	0x04000	/* can do IPv6/TCP checksums (Rx) */</u></td></tr>
<tr><th id="608">608</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_CSUM_TCPv6_Tx" data-ref="_M/IFCAP_CSUM_TCPv6_Tx">IFCAP_CSUM_TCPv6_Tx</dfn>	0x08000	/* can do IPv6/TCP checksums (Tx) */</u></td></tr>
<tr><th id="609">609</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_CSUM_UDPv6_Rx" data-ref="_M/IFCAP_CSUM_UDPv6_Rx">IFCAP_CSUM_UDPv6_Rx</dfn>	0x10000	/* can do IPv6/UDP checksums (Rx) */</u></td></tr>
<tr><th id="610">610</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_CSUM_UDPv6_Tx" data-ref="_M/IFCAP_CSUM_UDPv6_Tx">IFCAP_CSUM_UDPv6_Tx</dfn>	0x20000	/* can do IPv6/UDP checksums (Tx) */</u></td></tr>
<tr><th id="611">611</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_TSOv6" data-ref="_M/IFCAP_TSOv6">IFCAP_TSOv6</dfn>		0x40000	/* can do TCPv6 segmentation offload */</u></td></tr>
<tr><th id="612">612</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_LRO" data-ref="_M/IFCAP_LRO">IFCAP_LRO</dfn>		0x80000	/* can do Large Receive Offload */</u></td></tr>
<tr><th id="613">613</th><td><u>#define	<dfn class="macro" id="_M/IFCAP_MASK" data-ref="_M/IFCAP_MASK">IFCAP_MASK</dfn>		0xfff80 /* currently valid capabilities */</u></td></tr>
<tr><th id="614">614</th><td></td></tr>
<tr><th id="615">615</th><td><u>#define	<dfn class="macro" id="_M/IFCAPBITS" data-ref="_M/IFCAPBITS">IFCAPBITS</dfn>		\</u></td></tr>
<tr><th id="616">616</th><td><u>	"\020"			\</u></td></tr>
<tr><th id="617">617</th><td><u>	"\10TSO4"		\</u></td></tr>
<tr><th id="618">618</th><td><u>	"\11IP4CSUM_Rx"		\</u></td></tr>
<tr><th id="619">619</th><td><u>	"\12IP4CSUM_Tx"		\</u></td></tr>
<tr><th id="620">620</th><td><u>	"\13TCP4CSUM_Rx"	\</u></td></tr>
<tr><th id="621">621</th><td><u>	"\14TCP4CSUM_Tx"	\</u></td></tr>
<tr><th id="622">622</th><td><u>	"\15UDP4CSUM_Rx"	\</u></td></tr>
<tr><th id="623">623</th><td><u>	"\16UDP4CSUM_Tx"	\</u></td></tr>
<tr><th id="624">624</th><td><u>	"\17TCP6CSUM_Rx"	\</u></td></tr>
<tr><th id="625">625</th><td><u>	"\20TCP6CSUM_Tx"	\</u></td></tr>
<tr><th id="626">626</th><td><u>	"\21UDP6CSUM_Rx"	\</u></td></tr>
<tr><th id="627">627</th><td><u>	"\22UDP6CSUM_Tx"	\</u></td></tr>
<tr><th id="628">628</th><td><u>	"\23TSO6"		\</u></td></tr>
<tr><th id="629">629</th><td><u>	"\24LRO"</u>		\</td></tr>
<tr><th id="630">630</th><td></td></tr>
<tr><th id="631">631</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_LOCK_INIT" data-ref="_M/IF_AFDATA_LOCK_INIT">IF_AFDATA_LOCK_INIT</dfn>(ifp)	\</u></td></tr>
<tr><th id="632">632</th><td><u>	do {(ifp)-&gt;if_afdata_lock = rw_obj_alloc();} while (0)</u></td></tr>
<tr><th id="633">633</th><td></td></tr>
<tr><th id="634">634</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_LOCK_DESTROY" data-ref="_M/IF_AFDATA_LOCK_DESTROY">IF_AFDATA_LOCK_DESTROY</dfn>(ifp)	rw_obj_free((ifp)-&gt;if_afdata_lock)</u></td></tr>
<tr><th id="635">635</th><td></td></tr>
<tr><th id="636">636</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_WLOCK" data-ref="_M/IF_AFDATA_WLOCK">IF_AFDATA_WLOCK</dfn>(ifp)	rw_enter((ifp)-&gt;if_afdata_lock, RW_WRITER)</u></td></tr>
<tr><th id="637">637</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_RLOCK" data-ref="_M/IF_AFDATA_RLOCK">IF_AFDATA_RLOCK</dfn>(ifp)	rw_enter((ifp)-&gt;if_afdata_lock, RW_READER)</u></td></tr>
<tr><th id="638">638</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_WUNLOCK" data-ref="_M/IF_AFDATA_WUNLOCK">IF_AFDATA_WUNLOCK</dfn>(ifp)	rw_exit((ifp)-&gt;if_afdata_lock)</u></td></tr>
<tr><th id="639">639</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_RUNLOCK" data-ref="_M/IF_AFDATA_RUNLOCK">IF_AFDATA_RUNLOCK</dfn>(ifp)	rw_exit((ifp)-&gt;if_afdata_lock)</u></td></tr>
<tr><th id="640">640</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_LOCK" data-ref="_M/IF_AFDATA_LOCK">IF_AFDATA_LOCK</dfn>(ifp)	IF_AFDATA_WLOCK(ifp)</u></td></tr>
<tr><th id="641">641</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_UNLOCK" data-ref="_M/IF_AFDATA_UNLOCK">IF_AFDATA_UNLOCK</dfn>(ifp)	IF_AFDATA_WUNLOCK(ifp)</u></td></tr>
<tr><th id="642">642</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_TRYLOCK" data-ref="_M/IF_AFDATA_TRYLOCK">IF_AFDATA_TRYLOCK</dfn>(ifp)	rw_tryenter((ifp)-&gt;if_afdata_lock, RW_WRITER)</u></td></tr>
<tr><th id="643">643</th><td></td></tr>
<tr><th id="644">644</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_LOCK_ASSERT" data-ref="_M/IF_AFDATA_LOCK_ASSERT">IF_AFDATA_LOCK_ASSERT</dfn>(ifp)	\</u></td></tr>
<tr><th id="645">645</th><td><u>	KASSERT(rw_lock_held((ifp)-&gt;if_afdata_lock))</u></td></tr>
<tr><th id="646">646</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_RLOCK_ASSERT" data-ref="_M/IF_AFDATA_RLOCK_ASSERT">IF_AFDATA_RLOCK_ASSERT</dfn>(ifp)	\</u></td></tr>
<tr><th id="647">647</th><td><u>	KASSERT(rw_read_held((ifp)-&gt;if_afdata_lock))</u></td></tr>
<tr><th id="648">648</th><td><u>#define	<dfn class="macro" id="_M/IF_AFDATA_WLOCK_ASSERT" data-ref="_M/IF_AFDATA_WLOCK_ASSERT">IF_AFDATA_WLOCK_ASSERT</dfn>(ifp)	\</u></td></tr>
<tr><th id="649">649</th><td><u>	KASSERT(rw_write_held((ifp)-&gt;if_afdata_lock))</u></td></tr>
<tr><th id="650">650</th><td></td></tr>
<tr><th id="651">651</th><td><i>/*</i></td></tr>
<tr><th id="652">652</th><td><i> * Output queues (ifp-&gt;if_snd) and internetwork datagram level (pup level 1)</i></td></tr>
<tr><th id="653">653</th><td><i> * input routines have queues of messages stored on ifqueue structures</i></td></tr>
<tr><th id="654">654</th><td><i> * (defined above).  Entries are added to and deleted from these structures</i></td></tr>
<tr><th id="655">655</th><td><i> * by these macros, which should be called with ipl raised to splnet().</i></td></tr>
<tr><th id="656">656</th><td><i> */</i></td></tr>
<tr><th id="657">657</th><td><u>#define	<dfn class="macro" id="_M/IF_QFULL" data-ref="_M/IF_QFULL">IF_QFULL</dfn>(ifq)		((ifq)-&gt;ifq_len &gt;= (ifq)-&gt;ifq_maxlen)</u></td></tr>
<tr><th id="658">658</th><td><u>#define	<dfn class="macro" id="_M/IF_DROP" data-ref="_M/IF_DROP">IF_DROP</dfn>(ifq)		((ifq)-&gt;ifq_drops++)</u></td></tr>
<tr><th id="659">659</th><td><u>#define	<dfn class="macro" id="_M/IF_ENQUEUE" data-ref="_M/IF_ENQUEUE">IF_ENQUEUE</dfn>(ifq, m) do { \</u></td></tr>
<tr><th id="660">660</th><td><u>	(m)-&gt;m_nextpkt = 0; \</u></td></tr>
<tr><th id="661">661</th><td><u>	if ((ifq)-&gt;ifq_tail == 0) \</u></td></tr>
<tr><th id="662">662</th><td><u>		(ifq)-&gt;ifq_head = m; \</u></td></tr>
<tr><th id="663">663</th><td><u>	else \</u></td></tr>
<tr><th id="664">664</th><td><u>		(ifq)-&gt;ifq_tail-&gt;m_nextpkt = m; \</u></td></tr>
<tr><th id="665">665</th><td><u>	(ifq)-&gt;ifq_tail = m; \</u></td></tr>
<tr><th id="666">666</th><td><u>	(ifq)-&gt;ifq_len++; \</u></td></tr>
<tr><th id="667">667</th><td><u>} while (/*CONSTCOND*/0)</u></td></tr>
<tr><th id="668">668</th><td><u>#define	<dfn class="macro" id="_M/IF_PREPEND" data-ref="_M/IF_PREPEND">IF_PREPEND</dfn>(ifq, m) do { \</u></td></tr>
<tr><th id="669">669</th><td><u>	(m)-&gt;m_nextpkt = (ifq)-&gt;ifq_head; \</u></td></tr>
<tr><th id="670">670</th><td><u>	if ((ifq)-&gt;ifq_tail == 0) \</u></td></tr>
<tr><th id="671">671</th><td><u>		(ifq)-&gt;ifq_tail = (m); \</u></td></tr>
<tr><th id="672">672</th><td><u>	(ifq)-&gt;ifq_head = (m); \</u></td></tr>
<tr><th id="673">673</th><td><u>	(ifq)-&gt;ifq_len++; \</u></td></tr>
<tr><th id="674">674</th><td><u>} while (/*CONSTCOND*/0)</u></td></tr>
<tr><th id="675">675</th><td><u>#define	<dfn class="macro" id="_M/IF_DEQUEUE" data-ref="_M/IF_DEQUEUE">IF_DEQUEUE</dfn>(ifq, m) do { \</u></td></tr>
<tr><th id="676">676</th><td><u>	(m) = (ifq)-&gt;ifq_head; \</u></td></tr>
<tr><th id="677">677</th><td><u>	if (m) { \</u></td></tr>
<tr><th id="678">678</th><td><u>		if (((ifq)-&gt;ifq_head = (m)-&gt;m_nextpkt) == 0) \</u></td></tr>
<tr><th id="679">679</th><td><u>			(ifq)-&gt;ifq_tail = 0; \</u></td></tr>
<tr><th id="680">680</th><td><u>		(m)-&gt;m_nextpkt = 0; \</u></td></tr>
<tr><th id="681">681</th><td><u>		(ifq)-&gt;ifq_len--; \</u></td></tr>
<tr><th id="682">682</th><td><u>	} \</u></td></tr>
<tr><th id="683">683</th><td><u>} while (/*CONSTCOND*/0)</u> </td></tr>
<tr><th id="684">684</th><td><u>#define	<dfn class="macro" id="_M/IF_POLL" data-ref="_M/IF_POLL">IF_POLL</dfn>(ifq, m)		((m) = (ifq)-&gt;ifq_head)</u></td></tr>
<tr><th id="685">685</th><td><u>#define	<dfn class="macro" id="_M/IF_PURGE" data-ref="_M/IF_PURGE">IF_PURGE</dfn>(ifq)							\</u></td></tr>
<tr><th id="686">686</th><td><u>do {									\</u></td></tr>
<tr><th id="687">687</th><td><u>	struct mbuf *__m0;						\</u></td></tr>
<tr><th id="688">688</th><td><u>									\</u></td></tr>
<tr><th id="689">689</th><td><u>	for (;;) {							\</u></td></tr>
<tr><th id="690">690</th><td><u>		IF_DEQUEUE((ifq), __m0);				\</u></td></tr>
<tr><th id="691">691</th><td><u>		if (__m0 == NULL)					\</u></td></tr>
<tr><th id="692">692</th><td><u>			break;						\</u></td></tr>
<tr><th id="693">693</th><td><u>		else							\</u></td></tr>
<tr><th id="694">694</th><td><u>			m_freem(__m0);					\</u></td></tr>
<tr><th id="695">695</th><td><u>	}								\</u></td></tr>
<tr><th id="696">696</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="697">697</th><td><u>#define	<dfn class="macro" id="_M/IF_IS_EMPTY" data-ref="_M/IF_IS_EMPTY">IF_IS_EMPTY</dfn>(ifq)	((ifq)-&gt;ifq_len == 0)</u></td></tr>
<tr><th id="698">698</th><td></td></tr>
<tr><th id="699">699</th><td><u>#<span data-ppcond="699">ifndef</span> <span class="macro" data-ref="_M/IFQ_MAXLEN">IFQ_MAXLEN</span></u></td></tr>
<tr><th id="700">700</th><td><u>#define	<dfn class="macro" id="_M/IFQ_MAXLEN" data-ref="_M/IFQ_MAXLEN">IFQ_MAXLEN</dfn>	256</u></td></tr>
<tr><th id="701">701</th><td><u>#<span data-ppcond="699">endif</span></u></td></tr>
<tr><th id="702">702</th><td><u>#define	<dfn class="macro" id="_M/IFNET_SLOWHZ" data-ref="_M/IFNET_SLOWHZ">IFNET_SLOWHZ</dfn>	1		/* granularity is 1 second */</u></td></tr>
<tr><th id="703">703</th><td></td></tr>
<tr><th id="704">704</th><td><i>/*</i></td></tr>
<tr><th id="705">705</th><td><i> * Structure defining statistics and other data kept regarding an address</i></td></tr>
<tr><th id="706">706</th><td><i> * on a network interface.</i></td></tr>
<tr><th id="707">707</th><td><i> */</i></td></tr>
<tr><th id="708">708</th><td><b>struct</b> <dfn class="type def" id="ifaddr_data" title='ifaddr_data' data-ref="ifaddr_data" data-ref-filename="ifaddr_data">ifaddr_data</dfn> {</td></tr>
<tr><th id="709">709</th><td>	<a class="typedef" href="../sys/types.h.html#int64_t" title='int64_t' data-type='__int64_t' data-ref="int64_t" data-ref-filename="int64_t">int64_t</a>	<dfn class="decl field" id="ifaddr_data::ifad_inbytes" title='ifaddr_data::ifad_inbytes' data-ref="ifaddr_data::ifad_inbytes" data-ref-filename="ifaddr_data..ifad_inbytes">ifad_inbytes</dfn>;</td></tr>
<tr><th id="710">710</th><td>	<a class="typedef" href="../sys/types.h.html#int64_t" title='int64_t' data-type='__int64_t' data-ref="int64_t" data-ref-filename="int64_t">int64_t</a>	<dfn class="decl field" id="ifaddr_data::ifad_outbytes" title='ifaddr_data::ifad_outbytes' data-ref="ifaddr_data::ifad_outbytes" data-ref-filename="ifaddr_data..ifad_outbytes">ifad_outbytes</dfn>;</td></tr>
<tr><th id="711">711</th><td>};</td></tr>
<tr><th id="712">712</th><td></td></tr>
<tr><th id="713">713</th><td><i>/*</i></td></tr>
<tr><th id="714">714</th><td><i> * The ifaddr structure contains information about one address</i></td></tr>
<tr><th id="715">715</th><td><i> * of an interface.  They are maintained by the different address families,</i></td></tr>
<tr><th id="716">716</th><td><i> * are allocated and attached when an address is set, and are linked</i></td></tr>
<tr><th id="717">717</th><td><i> * together so all addresses for an interface can be located.</i></td></tr>
<tr><th id="718">718</th><td><i> */</i></td></tr>
<tr><th id="719">719</th><td><b>struct</b> <dfn class="type def" id="ifaddr" title='ifaddr' data-ref="ifaddr" data-ref-filename="ifaddr">ifaddr</dfn> {</td></tr>
<tr><th id="720">720</th><td>	<b>struct</b>	<a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *<dfn class="decl field" id="ifaddr::ifa_addr" title='ifaddr::ifa_addr' data-ref="ifaddr::ifa_addr" data-ref-filename="ifaddr..ifa_addr">ifa_addr</dfn>;	<i>/* address of interface */</i></td></tr>
<tr><th id="721">721</th><td>	<b>struct</b>	<a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *<dfn class="decl field" id="ifaddr::ifa_dstaddr" title='ifaddr::ifa_dstaddr' data-ref="ifaddr::ifa_dstaddr" data-ref-filename="ifaddr..ifa_dstaddr">ifa_dstaddr</dfn>;	<i>/* other end of p-to-p link */</i></td></tr>
<tr><th id="722">722</th><td><u>#define	<dfn class="macro" id="_M/ifa_broadaddr" data-ref="_M/ifa_broadaddr">ifa_broadaddr</dfn>	ifa_dstaddr	/* broadcast address interface */</u></td></tr>
<tr><th id="723">723</th><td>	<b>struct</b>	<a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *<dfn class="decl field" id="ifaddr::ifa_netmask" title='ifaddr::ifa_netmask' data-ref="ifaddr::ifa_netmask" data-ref-filename="ifaddr..ifa_netmask">ifa_netmask</dfn>;	<i>/* used to determine subnet */</i></td></tr>
<tr><th id="724">724</th><td>	<b>struct</b>	<a class="type" href="#ifnet" title='ifnet' data-ref="ifnet" data-ref-filename="ifnet">ifnet</a> *<dfn class="decl field" id="ifaddr::ifa_ifp" title='ifaddr::ifa_ifp' data-ref="ifaddr::ifa_ifp" data-ref-filename="ifaddr..ifa_ifp">ifa_ifp</dfn>;		<i>/* back-pointer to interface */</i></td></tr>
<tr><th id="725">725</th><td>	<a class="macro" href="../sys/queue.h.html#423" title="struct { struct ifaddr *tqe_next; struct ifaddr * *tqe_prev; }" data-ref="_M/TAILQ_ENTRY">TAILQ_ENTRY</a>(<a class="type" href="#ifaddr" title='ifaddr' data-ref="ifaddr" data-ref-filename="ifaddr">ifaddr</a>) <dfn class="decl field" id="ifaddr::ifa_list" title='ifaddr::ifa_list' data-ref="ifaddr::ifa_list" data-ref-filename="ifaddr..ifa_list">ifa_list</dfn>;	<i>/* list of addresses for interface */</i></td></tr>
<tr><th id="726">726</th><td>	<b>struct</b>	<a class="type" href="#ifaddr_data" title='ifaddr_data' data-ref="ifaddr_data" data-ref-filename="ifaddr_data">ifaddr_data</a>	<dfn class="decl field" id="ifaddr::ifa_data" title='ifaddr::ifa_data' data-ref="ifaddr::ifa_data" data-ref-filename="ifaddr..ifa_data">ifa_data</dfn>;	<i>/* statistics on the address */</i></td></tr>
<tr><th id="727">727</th><td>	<em>void</em>	(*<dfn class="decl field" id="ifaddr::ifa_rtrequest" title='ifaddr::ifa_rtrequest' data-ref="ifaddr::ifa_rtrequest" data-ref-filename="ifaddr..ifa_rtrequest">ifa_rtrequest</dfn>)	<i>/* check or clean routes (+ or -)'d */</i></td></tr>
<tr><th id="728">728</th><td>		        (<em>int</em>, <b>struct</b> <a class="type" href="#rtentry" title='rtentry' data-ref="rtentry" data-ref-filename="rtentry">rtentry</a> *, <em>const</em> <b>struct</b> <a class="type" href="#rt_addrinfo" title='rt_addrinfo' data-ref="rt_addrinfo" data-ref-filename="rt_addrinfo">rt_addrinfo</a> *);</td></tr>
<tr><th id="729">729</th><td>	<a class="typedef" href="../sys/types.h.html#u_int" title='u_int' data-type='unsigned int' data-ref="u_int" data-ref-filename="u_int">u_int</a>	<dfn class="decl field" id="ifaddr::ifa_flags" title='ifaddr::ifa_flags' data-ref="ifaddr::ifa_flags" data-ref-filename="ifaddr..ifa_flags">ifa_flags</dfn>;		<i>/* mostly rt_flags for cloning */</i></td></tr>
<tr><th id="730">730</th><td>	<em>int</em>	<dfn class="decl field" id="ifaddr::ifa_refcnt" title='ifaddr::ifa_refcnt' data-ref="ifaddr::ifa_refcnt" data-ref-filename="ifaddr..ifa_refcnt">ifa_refcnt</dfn>;		<i>/* count of references */</i></td></tr>
<tr><th id="731">731</th><td>	<em>int</em>	<dfn class="decl field" id="ifaddr::ifa_metric" title='ifaddr::ifa_metric' data-ref="ifaddr::ifa_metric" data-ref-filename="ifaddr..ifa_metric">ifa_metric</dfn>;		<i>/* cost of going out this interface */</i></td></tr>
<tr><th id="732">732</th><td>	<b>struct</b> <a class="type" href="#ifaddr" title='ifaddr' data-ref="ifaddr" data-ref-filename="ifaddr">ifaddr</a>	*(*<dfn class="decl field" id="ifaddr::ifa_getifa" title='ifaddr::ifa_getifa' data-ref="ifaddr::ifa_getifa" data-ref-filename="ifaddr..ifa_getifa">ifa_getifa</dfn>)(<b>struct</b> <a class="type" href="#ifaddr" title='ifaddr' data-ref="ifaddr" data-ref-filename="ifaddr">ifaddr</a> *,</td></tr>
<tr><th id="733">733</th><td>			               <em>const</em> <b>struct</b> <a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> *);</td></tr>
<tr><th id="734">734</th><td>	<a class="typedef" href="../sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	*<dfn class="decl field" id="ifaddr::ifa_seqno" title='ifaddr::ifa_seqno' data-ref="ifaddr::ifa_seqno" data-ref-filename="ifaddr..ifa_seqno">ifa_seqno</dfn>;</td></tr>
<tr><th id="735">735</th><td>	<a class="typedef" href="../sys/types.h.html#int16_t" title='int16_t' data-type='__int16_t' data-ref="int16_t" data-ref-filename="int16_t">int16_t</a>	<dfn class="decl field" id="ifaddr::ifa_preference" title='ifaddr::ifa_preference' data-ref="ifaddr::ifa_preference" data-ref-filename="ifaddr..ifa_preference">ifa_preference</dfn>;	<i>/* preference level for this address */</i></td></tr>
<tr><th id="736">736</th><td><u>#<span data-ppcond="736">ifdef</span> <span class="macro" data-ref="_M/_KERNEL">_KERNEL</span></u></td></tr>
<tr><th id="737">737</th><td>	<b>struct</b> pslist_entry     ifa_pslist_entry;</td></tr>
<tr><th id="738">738</th><td>	<b>struct</b> psref_target	ifa_psref;</td></tr>
<tr><th id="739">739</th><td><u>#<span data-ppcond="736">endif</span></u></td></tr>
<tr><th id="740">740</th><td>};</td></tr>
<tr><th id="741">741</th><td><u>#define	<dfn class="macro" id="_M/IFA_ROUTE" data-ref="_M/IFA_ROUTE">IFA_ROUTE</dfn>	RTF_UP	/* (0x01) route installed */</u></td></tr>
<tr><th id="742">742</th><td><u>#define	<dfn class="macro" id="_M/IFA_DESTROYING" data-ref="_M/IFA_DESTROYING">IFA_DESTROYING</dfn>	0x2</u></td></tr>
<tr><th id="743">743</th><td></td></tr>
<tr><th id="744">744</th><td><i>/*</i></td></tr>
<tr><th id="745">745</th><td><i> * Message format for use in obtaining information about interfaces from</i></td></tr>
<tr><th id="746">746</th><td><i> * sysctl and the routing socket.  We need to force 64-bit alignment if we</i></td></tr>
<tr><th id="747">747</th><td><i> * aren't using compatiblity definitons.</i></td></tr>
<tr><th id="748">748</th><td><i> */</i></td></tr>
<tr><th id="749">749</th><td><u>#<span data-ppcond="749">if</span> !defined(<span class="macro" data-ref="_M/_KERNEL">_KERNEL</span>) || !defined(<span class="macro" data-ref="_M/COMPAT_RTSOCK">COMPAT_RTSOCK</span>)</u></td></tr>
<tr><th id="750">750</th><td><u>#define	<dfn class="macro" id="_M/__align64" data-ref="_M/__align64">__align64</dfn>	__aligned(sizeof(<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a>))</u></td></tr>
<tr><th id="751">751</th><td><u>#<span data-ppcond="749">else</span></u></td></tr>
<tr><th id="752">752</th><td><u>#define	__align64</u></td></tr>
<tr><th id="753">753</th><td><u>#<span data-ppcond="749">endif</span></u></td></tr>
<tr><th id="754">754</th><td><b>struct</b> <dfn class="type def" id="if_msghdr" title='if_msghdr' data-ref="if_msghdr" data-ref-filename="if_msghdr">if_msghdr</dfn> {</td></tr>
<tr><th id="755">755</th><td>	<a class="typedef" href="../sys/types.h.html#u_short" title='u_short' data-type='unsigned short' data-ref="u_short" data-ref-filename="u_short">u_short</a>	<dfn class="decl field" id="if_msghdr::ifm_msglen" title='if_msghdr::ifm_msglen' data-ref="if_msghdr::ifm_msglen" data-ref-filename="if_msghdr..ifm_msglen">ifm_msglen</dfn> <a class="macro" href="#750" title="__attribute__((__aligned__(sizeof(uint64_t))))" data-ref="_M/__align64">__align64</a>;</td></tr>
<tr><th id="756">756</th><td>				<i>/* to skip over non-understood messages */</i></td></tr>
<tr><th id="757">757</th><td>	<a class="typedef" href="../sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a>	<dfn class="decl field" id="if_msghdr::ifm_version" title='if_msghdr::ifm_version' data-ref="if_msghdr::ifm_version" data-ref-filename="if_msghdr..ifm_version">ifm_version</dfn>;	<i>/* future binary compatibility */</i></td></tr>
<tr><th id="758">758</th><td>	<a class="typedef" href="../sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a>	<dfn class="decl field" id="if_msghdr::ifm_type" title='if_msghdr::ifm_type' data-ref="if_msghdr::ifm_type" data-ref-filename="if_msghdr..ifm_type">ifm_type</dfn>;	<i>/* message type */</i></td></tr>
<tr><th id="759">759</th><td>	<em>int</em>	<dfn class="decl field" id="if_msghdr::ifm_addrs" title='if_msghdr::ifm_addrs' data-ref="if_msghdr::ifm_addrs" data-ref-filename="if_msghdr..ifm_addrs">ifm_addrs</dfn>;	<i>/* like rtm_addrs */</i></td></tr>
<tr><th id="760">760</th><td>	<em>int</em>	<dfn class="decl field" id="if_msghdr::ifm_flags" title='if_msghdr::ifm_flags' data-ref="if_msghdr::ifm_flags" data-ref-filename="if_msghdr..ifm_flags">ifm_flags</dfn>;	<i>/* value of if_flags */</i></td></tr>
<tr><th id="761">761</th><td>	<a class="typedef" href="../sys/types.h.html#u_short" title='u_short' data-type='unsigned short' data-ref="u_short" data-ref-filename="u_short">u_short</a>	<dfn class="decl field" id="if_msghdr::ifm_index" title='if_msghdr::ifm_index' data-ref="if_msghdr::ifm_index" data-ref-filename="if_msghdr..ifm_index">ifm_index</dfn>;	<i>/* index for associated ifp */</i></td></tr>
<tr><th id="762">762</th><td>	<b>struct</b>	<a class="type" href="#if_data" title='if_data' data-ref="if_data" data-ref-filename="if_data">if_data</a> <dfn class="decl field" id="if_msghdr::ifm_data" title='if_msghdr::ifm_data' data-ref="if_msghdr::ifm_data" data-ref-filename="if_msghdr..ifm_data">ifm_data</dfn> <a class="macro" href="#750" title="__attribute__((__aligned__(sizeof(uint64_t))))" data-ref="_M/__align64">__align64</a>;</td></tr>
<tr><th id="763">763</th><td>				<i>/* statistics and other data about if */</i></td></tr>
<tr><th id="764">764</th><td>};</td></tr>
<tr><th id="765">765</th><td></td></tr>
<tr><th id="766">766</th><td><i>/*</i></td></tr>
<tr><th id="767">767</th><td><i> * Message format for use in obtaining information about interface addresses</i></td></tr>
<tr><th id="768">768</th><td><i> * from sysctl and the routing socket.</i></td></tr>
<tr><th id="769">769</th><td><i> */</i></td></tr>
<tr><th id="770">770</th><td><b>struct</b> <dfn class="type def" id="ifa_msghdr" title='ifa_msghdr' data-ref="ifa_msghdr" data-ref-filename="ifa_msghdr">ifa_msghdr</dfn> {</td></tr>
<tr><th id="771">771</th><td>	<a class="typedef" href="../sys/types.h.html#u_short" title='u_short' data-type='unsigned short' data-ref="u_short" data-ref-filename="u_short">u_short</a>	<dfn class="decl field" id="ifa_msghdr::ifam_msglen" title='ifa_msghdr::ifam_msglen' data-ref="ifa_msghdr::ifam_msglen" data-ref-filename="ifa_msghdr..ifam_msglen">ifam_msglen</dfn> <a class="macro" href="#750" title="__attribute__((__aligned__(sizeof(uint64_t))))" data-ref="_M/__align64">__align64</a>;</td></tr>
<tr><th id="772">772</th><td>				<i>/* to skip over non-understood messages */</i></td></tr>
<tr><th id="773">773</th><td>	<a class="typedef" href="../sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a>	<dfn class="decl field" id="ifa_msghdr::ifam_version" title='ifa_msghdr::ifam_version' data-ref="ifa_msghdr::ifam_version" data-ref-filename="ifa_msghdr..ifam_version">ifam_version</dfn>;	<i>/* future binary compatibility */</i></td></tr>
<tr><th id="774">774</th><td>	<a class="typedef" href="../sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a>	<dfn class="decl field" id="ifa_msghdr::ifam_type" title='ifa_msghdr::ifam_type' data-ref="ifa_msghdr::ifam_type" data-ref-filename="ifa_msghdr..ifam_type">ifam_type</dfn>;	<i>/* message type */</i></td></tr>
<tr><th id="775">775</th><td>	<a class="typedef" href="../sys/types.h.html#u_short" title='u_short' data-type='unsigned short' data-ref="u_short" data-ref-filename="u_short">u_short</a>	<dfn class="decl field" id="ifa_msghdr::ifam_index" title='ifa_msghdr::ifam_index' data-ref="ifa_msghdr::ifam_index" data-ref-filename="ifa_msghdr..ifam_index">ifam_index</dfn>;	<i>/* index for associated ifp */</i></td></tr>
<tr><th id="776">776</th><td>	<em>int</em>	<dfn class="decl field" id="ifa_msghdr::ifam_flags" title='ifa_msghdr::ifam_flags' data-ref="ifa_msghdr::ifam_flags" data-ref-filename="ifa_msghdr..ifam_flags">ifam_flags</dfn>;	<i>/* value of ifa_flags */</i></td></tr>
<tr><th id="777">777</th><td>	<em>int</em>	<dfn class="decl field" id="ifa_msghdr::ifam_addrs" title='ifa_msghdr::ifam_addrs' data-ref="ifa_msghdr::ifam_addrs" data-ref-filename="ifa_msghdr..ifam_addrs">ifam_addrs</dfn>;	<i>/* like rtm_addrs */</i></td></tr>
<tr><th id="778">778</th><td>	<a class="macro" href="../sys/types.h.html#183" title="__pid_t" data-ref="_M/pid_t">pid_t</a>	<dfn class="decl field" id="ifa_msghdr::ifam_pid" title='ifa_msghdr::ifam_pid' data-ref="ifa_msghdr::ifam_pid" data-ref-filename="ifa_msghdr..ifam_pid">ifam_pid</dfn>;	<i>/* identify sender */</i></td></tr>
<tr><th id="779">779</th><td>	<em>int</em>	<dfn class="decl field" id="ifa_msghdr::ifam_addrflags" title='ifa_msghdr::ifam_addrflags' data-ref="ifa_msghdr::ifam_addrflags" data-ref-filename="ifa_msghdr..ifam_addrflags">ifam_addrflags</dfn>;	<i>/* family specific address flags */</i></td></tr>
<tr><th id="780">780</th><td>	<em>int</em>	<dfn class="decl field" id="ifa_msghdr::ifam_metric" title='ifa_msghdr::ifam_metric' data-ref="ifa_msghdr::ifam_metric" data-ref-filename="ifa_msghdr..ifam_metric">ifam_metric</dfn>;	<i>/* value of ifa_metric */</i></td></tr>
<tr><th id="781">781</th><td>};</td></tr>
<tr><th id="782">782</th><td></td></tr>
<tr><th id="783">783</th><td><i>/*</i></td></tr>
<tr><th id="784">784</th><td><i> * Message format announcing the arrival or departure of a network interface.</i></td></tr>
<tr><th id="785">785</th><td><i> */</i></td></tr>
<tr><th id="786">786</th><td><b>struct</b> <dfn class="type def" id="if_announcemsghdr" title='if_announcemsghdr' data-ref="if_announcemsghdr" data-ref-filename="if_announcemsghdr">if_announcemsghdr</dfn> {</td></tr>
<tr><th id="787">787</th><td>	<a class="typedef" href="../sys/types.h.html#u_short" title='u_short' data-type='unsigned short' data-ref="u_short" data-ref-filename="u_short">u_short</a>	<dfn class="decl field" id="if_announcemsghdr::ifan_msglen" title='if_announcemsghdr::ifan_msglen' data-ref="if_announcemsghdr::ifan_msglen" data-ref-filename="if_announcemsghdr..ifan_msglen">ifan_msglen</dfn> <a class="macro" href="#750" title="__attribute__((__aligned__(sizeof(uint64_t))))" data-ref="_M/__align64">__align64</a>;</td></tr>
<tr><th id="788">788</th><td>				<i>/* to skip over non-understood messages */</i></td></tr>
<tr><th id="789">789</th><td>	<a class="typedef" href="../sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a>	<dfn class="decl field" id="if_announcemsghdr::ifan_version" title='if_announcemsghdr::ifan_version' data-ref="if_announcemsghdr::ifan_version" data-ref-filename="if_announcemsghdr..ifan_version">ifan_version</dfn>;	<i>/* future binary compatibility */</i></td></tr>
<tr><th id="790">790</th><td>	<a class="typedef" href="../sys/types.h.html#u_char" title='u_char' data-type='unsigned char' data-ref="u_char" data-ref-filename="u_char">u_char</a>	<dfn class="decl field" id="if_announcemsghdr::ifan_type" title='if_announcemsghdr::ifan_type' data-ref="if_announcemsghdr::ifan_type" data-ref-filename="if_announcemsghdr..ifan_type">ifan_type</dfn>;	<i>/* message type */</i></td></tr>
<tr><th id="791">791</th><td>	<a class="typedef" href="../sys/types.h.html#u_short" title='u_short' data-type='unsigned short' data-ref="u_short" data-ref-filename="u_short">u_short</a>	<dfn class="decl field" id="if_announcemsghdr::ifan_index" title='if_announcemsghdr::ifan_index' data-ref="if_announcemsghdr::ifan_index" data-ref-filename="if_announcemsghdr..ifan_index">ifan_index</dfn>;	<i>/* index for associated ifp */</i></td></tr>
<tr><th id="792">792</th><td>	<em>char</em>	<dfn class="decl field" id="if_announcemsghdr::ifan_name" title='if_announcemsghdr::ifan_name' data-ref="if_announcemsghdr::ifan_name" data-ref-filename="if_announcemsghdr..ifan_name">ifan_name</dfn>[<a class="macro" href="#147" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>]; <i>/* if name, e.g. "en0" */</i></td></tr>
<tr><th id="793">793</th><td>	<a class="typedef" href="../sys/types.h.html#u_short" title='u_short' data-type='unsigned short' data-ref="u_short" data-ref-filename="u_short">u_short</a>	<dfn class="decl field" id="if_announcemsghdr::ifan_what" title='if_announcemsghdr::ifan_what' data-ref="if_announcemsghdr::ifan_what" data-ref-filename="if_announcemsghdr..ifan_what">ifan_what</dfn>;	<i>/* what type of announcement */</i></td></tr>
<tr><th id="794">794</th><td>};</td></tr>
<tr><th id="795">795</th><td></td></tr>
<tr><th id="796">796</th><td><u>#define	<dfn class="macro" id="_M/IFAN_ARRIVAL" data-ref="_M/IFAN_ARRIVAL">IFAN_ARRIVAL</dfn>	0	/* interface arrival */</u></td></tr>
<tr><th id="797">797</th><td><u>#define	<dfn class="macro" id="_M/IFAN_DEPARTURE" data-ref="_M/IFAN_DEPARTURE">IFAN_DEPARTURE</dfn>	1	/* interface departure */</u></td></tr>
<tr><th id="798">798</th><td></td></tr>
<tr><th id="799">799</th><td><u>#undef <a class="macro" href="#750" data-ref="_M/__align64">__align64</a></u></td></tr>
<tr><th id="800">800</th><td></td></tr>
<tr><th id="801">801</th><td><i>/*</i></td></tr>
<tr><th id="802">802</th><td><i> * Interface request structure used for socket</i></td></tr>
<tr><th id="803">803</th><td><i> * ioctl's.  All interface ioctl's must have parameter</i></td></tr>
<tr><th id="804">804</th><td><i> * definitions which begin with ifr_name.  The</i></td></tr>
<tr><th id="805">805</th><td><i> * remainder may be interface specific.</i></td></tr>
<tr><th id="806">806</th><td><i> */</i></td></tr>
<tr><th id="807">807</th><td><b>struct</b>	<dfn class="type def" id="ifreq" title='ifreq' data-ref="ifreq" data-ref-filename="ifreq">ifreq</dfn> {</td></tr>
<tr><th id="808">808</th><td>	<em>char</em>	<dfn class="decl field" id="ifreq::ifr_name" title='ifreq::ifr_name' data-ref="ifreq::ifr_name" data-ref-filename="ifreq..ifr_name">ifr_name</dfn>[<a class="macro" href="#147" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];		<i>/* if name, e.g. "en0" */</i></td></tr>
<tr><th id="809">809</th><td>	<b>union</b> {</td></tr>
<tr><th id="810">810</th><td>		<b>struct</b>	<a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> <dfn class="decl field" id="ifreq::(anonymous)::ifru_addr" title='ifreq::(anonymous union)::ifru_addr' data-ref="ifreq::(anonymous)::ifru_addr" data-ref-filename="ifreq..(anonymous)..ifru_addr">ifru_addr</dfn>;</td></tr>
<tr><th id="811">811</th><td>		<b>struct</b>	<a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> <dfn class="decl field" id="ifreq::(anonymous)::ifru_dstaddr" title='ifreq::(anonymous union)::ifru_dstaddr' data-ref="ifreq::(anonymous)::ifru_dstaddr" data-ref-filename="ifreq..(anonymous)..ifru_dstaddr">ifru_dstaddr</dfn>;</td></tr>
<tr><th id="812">812</th><td>		<b>struct</b>	<a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> <dfn class="decl field" id="ifreq::(anonymous)::ifru_broadaddr" title='ifreq::(anonymous union)::ifru_broadaddr' data-ref="ifreq::(anonymous)::ifru_broadaddr" data-ref-filename="ifreq..(anonymous)..ifru_broadaddr">ifru_broadaddr</dfn>;</td></tr>
<tr><th id="813">813</th><td>		<b>struct</b>	<a class="type" href="../sys/socket.h.html#sockaddr_storage" title='sockaddr_storage' data-ref="sockaddr_storage" data-ref-filename="sockaddr_storage">sockaddr_storage</a> <dfn class="decl field" id="ifreq::(anonymous)::ifru_space" title='ifreq::(anonymous union)::ifru_space' data-ref="ifreq::(anonymous)::ifru_space" data-ref-filename="ifreq..(anonymous)..ifru_space">ifru_space</dfn>;</td></tr>
<tr><th id="814">814</th><td>		<em>short</em>	<dfn class="decl field" id="ifreq::(anonymous)::ifru_flags" title='ifreq::(anonymous union)::ifru_flags' data-ref="ifreq::(anonymous)::ifru_flags" data-ref-filename="ifreq..(anonymous)..ifru_flags">ifru_flags</dfn>;</td></tr>
<tr><th id="815">815</th><td>		<em>int</em>	<dfn class="decl field" id="ifreq::(anonymous)::ifru_addrflags" title='ifreq::(anonymous union)::ifru_addrflags' data-ref="ifreq::(anonymous)::ifru_addrflags" data-ref-filename="ifreq..(anonymous)..ifru_addrflags">ifru_addrflags</dfn>;</td></tr>
<tr><th id="816">816</th><td>		<em>int</em>	<dfn class="decl field" id="ifreq::(anonymous)::ifru_metric" title='ifreq::(anonymous union)::ifru_metric' data-ref="ifreq::(anonymous)::ifru_metric" data-ref-filename="ifreq..(anonymous)..ifru_metric">ifru_metric</dfn>;</td></tr>
<tr><th id="817">817</th><td>		<em>int</em>	<dfn class="decl field" id="ifreq::(anonymous)::ifru_mtu" title='ifreq::(anonymous union)::ifru_mtu' data-ref="ifreq::(anonymous)::ifru_mtu" data-ref-filename="ifreq..(anonymous)..ifru_mtu">ifru_mtu</dfn>;</td></tr>
<tr><th id="818">818</th><td>		<em>int</em>	<dfn class="decl field" id="ifreq::(anonymous)::ifru_dlt" title='ifreq::(anonymous union)::ifru_dlt' data-ref="ifreq::(anonymous)::ifru_dlt" data-ref-filename="ifreq..(anonymous)..ifru_dlt">ifru_dlt</dfn>;</td></tr>
<tr><th id="819">819</th><td>		<a class="typedef" href="../sys/types.h.html#u_int" title='u_int' data-type='unsigned int' data-ref="u_int" data-ref-filename="u_int">u_int</a>	<dfn class="decl field" id="ifreq::(anonymous)::ifru_value" title='ifreq::(anonymous union)::ifru_value' data-ref="ifreq::(anonymous)::ifru_value" data-ref-filename="ifreq..(anonymous)..ifru_value">ifru_value</dfn>;</td></tr>
<tr><th id="820">820</th><td>		<em>void</em> *	<dfn class="decl field" id="ifreq::(anonymous)::ifru_data" title='ifreq::(anonymous union)::ifru_data' data-ref="ifreq::(anonymous)::ifru_data" data-ref-filename="ifreq..(anonymous)..ifru_data">ifru_data</dfn>;</td></tr>
<tr><th id="821">821</th><td>		<b>struct</b> {</td></tr>
<tr><th id="822">822</th><td>			<a class="typedef" href="../sys/types.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>	<dfn class="decl field" id="ifreq::(anonymousunion)::(anonymous)::b_buflen" title='ifreq::(anonymous union)::(anonymous struct)::b_buflen' data-ref="ifreq::(anonymousunion)::(anonymous)::b_buflen" data-ref-filename="ifreq..(anonymousunion)..(anonymous)..b_buflen">b_buflen</dfn>;</td></tr>
<tr><th id="823">823</th><td>			<em>void</em>		*<dfn class="decl field" id="ifreq::(anonymousunion)::(anonymous)::b_buf" title='ifreq::(anonymous union)::(anonymous struct)::b_buf' data-ref="ifreq::(anonymousunion)::(anonymous)::b_buf" data-ref-filename="ifreq..(anonymousunion)..(anonymous)..b_buf">b_buf</dfn>;</td></tr>
<tr><th id="824">824</th><td>		} <dfn class="decl field" id="ifreq::(anonymous)::ifru_b" title='ifreq::(anonymous union)::ifru_b' data-ref="ifreq::(anonymous)::ifru_b" data-ref-filename="ifreq..(anonymous)..ifru_b">ifru_b</dfn>;</td></tr>
<tr><th id="825">825</th><td>	} <dfn class="decl field" id="ifreq::ifr_ifru" title='ifreq::ifr_ifru' data-ref="ifreq::ifr_ifru" data-ref-filename="ifreq..ifr_ifru">ifr_ifru</dfn>;</td></tr>
<tr><th id="826">826</th><td><u>#define	<dfn class="macro" id="_M/ifr_addr" data-ref="_M/ifr_addr">ifr_addr</dfn>	ifr_ifru.ifru_addr	/* address */</u></td></tr>
<tr><th id="827">827</th><td><u>#define	<dfn class="macro" id="_M/ifr_dstaddr" data-ref="_M/ifr_dstaddr">ifr_dstaddr</dfn>	ifr_ifru.ifru_dstaddr	/* other end of p-to-p link */</u></td></tr>
<tr><th id="828">828</th><td><u>#define	<dfn class="macro" id="_M/ifr_broadaddr" data-ref="_M/ifr_broadaddr">ifr_broadaddr</dfn>	ifr_ifru.ifru_broadaddr	/* broadcast address */</u></td></tr>
<tr><th id="829">829</th><td><u>#define	<dfn class="macro" id="_M/ifr_space" data-ref="_M/ifr_space">ifr_space</dfn>	ifr_ifru.ifru_space	/* sockaddr_storage */</u></td></tr>
<tr><th id="830">830</th><td><u>#define	<dfn class="macro" id="_M/ifr_flags" data-ref="_M/ifr_flags">ifr_flags</dfn>	ifr_ifru.ifru_flags	/* flags */</u></td></tr>
<tr><th id="831">831</th><td><u>#define	<dfn class="macro" id="_M/ifr_addrflags" data-ref="_M/ifr_addrflags">ifr_addrflags</dfn>	ifr_ifru.ifru_addrflags	/* addr flags */</u></td></tr>
<tr><th id="832">832</th><td><u>#define	<dfn class="macro" id="_M/ifr_metric" data-ref="_M/ifr_metric">ifr_metric</dfn>	ifr_ifru.ifru_metric	/* metric */</u></td></tr>
<tr><th id="833">833</th><td><u>#define	<dfn class="macro" id="_M/ifr_mtu" data-ref="_M/ifr_mtu">ifr_mtu</dfn>		ifr_ifru.ifru_mtu	/* mtu */</u></td></tr>
<tr><th id="834">834</th><td><u>#define	<dfn class="macro" id="_M/ifr_dlt" data-ref="_M/ifr_dlt">ifr_dlt</dfn>		ifr_ifru.ifru_dlt	/* data link type (DLT_*) */</u></td></tr>
<tr><th id="835">835</th><td><u>#define	<dfn class="macro" id="_M/ifr_value" data-ref="_M/ifr_value">ifr_value</dfn>	ifr_ifru.ifru_value	/* generic value */</u></td></tr>
<tr><th id="836">836</th><td><u>#define	<dfn class="macro" id="_M/ifr_media" data-ref="_M/ifr_media">ifr_media</dfn>	ifr_ifru.ifru_metric	/* media options (overload) */</u></td></tr>
<tr><th id="837">837</th><td><u>#define	<dfn class="macro" id="_M/ifr_data" data-ref="_M/ifr_data">ifr_data</dfn>	ifr_ifru.ifru_data	/* for use by interface</u></td></tr>
<tr><th id="838">838</th><td><u>						 * XXX deprecated</u></td></tr>
<tr><th id="839">839</th><td><u>						 */</u></td></tr>
<tr><th id="840">840</th><td><u>#define	<dfn class="macro" id="_M/ifr_buf" data-ref="_M/ifr_buf">ifr_buf</dfn>		ifr_ifru.ifru_b.b_buf	/* new interface ioctls */</u></td></tr>
<tr><th id="841">841</th><td><u>#define	<dfn class="macro" id="_M/ifr_buflen" data-ref="_M/ifr_buflen">ifr_buflen</dfn>	ifr_ifru.ifru_b.b_buflen</u></td></tr>
<tr><th id="842">842</th><td><u>#define	<dfn class="macro" id="_M/ifr_index" data-ref="_M/ifr_index">ifr_index</dfn>	ifr_ifru.ifru_value	/* interface index, BSD */</u></td></tr>
<tr><th id="843">843</th><td><u>#define	<dfn class="macro" id="_M/ifr_ifindex" data-ref="_M/ifr_ifindex">ifr_ifindex</dfn>	ifr_index		/* interface index, linux */</u></td></tr>
<tr><th id="844">844</th><td>};</td></tr>
<tr><th id="845">845</th><td></td></tr>
<tr><th id="846">846</th><td><u>#<span data-ppcond="846">ifdef</span> <span class="macro" data-ref="_M/_KERNEL">_KERNEL</span></u></td></tr>
<tr><th id="847">847</th><td><u>#define	ifreq_setdstaddr	ifreq_setaddr</u></td></tr>
<tr><th id="848">848</th><td><u>#define	ifreq_setbroadaddr	ifreq_setaddr</u></td></tr>
<tr><th id="849">849</th><td><u>#define	ifreq_getdstaddr	ifreq_getaddr</u></td></tr>
<tr><th id="850">850</th><td><u>#define	ifreq_getbroadaddr	ifreq_getaddr</u></td></tr>
<tr><th id="851">851</th><td></td></tr>
<tr><th id="852">852</th><td><em>static</em> <b>__inline</b> <em>const</em> <b>struct</b> sockaddr *</td></tr>
<tr><th id="853">853</th><td><i>/*ARGSUSED*/</i></td></tr>
<tr><th id="854">854</th><td>ifreq_getaddr(u_long cmd, <em>const</em> <b>struct</b> ifreq *ifr)</td></tr>
<tr><th id="855">855</th><td>{</td></tr>
<tr><th id="856">856</th><td>	<b>return</b> &amp;ifr-&gt;ifr_addr;</td></tr>
<tr><th id="857">857</th><td>}</td></tr>
<tr><th id="858">858</th><td><u>#<span data-ppcond="846">endif</span> /* _KERNEL */</u></td></tr>
<tr><th id="859">859</th><td></td></tr>
<tr><th id="860">860</th><td><b>struct</b> <dfn class="type def" id="ifcapreq" title='ifcapreq' data-ref="ifcapreq" data-ref-filename="ifcapreq">ifcapreq</dfn> {</td></tr>
<tr><th id="861">861</th><td>	<em>char</em>		<dfn class="decl field" id="ifcapreq::ifcr_name" title='ifcapreq::ifcr_name' data-ref="ifcapreq::ifcr_name" data-ref-filename="ifcapreq..ifcr_name">ifcr_name</dfn>[<a class="macro" href="#147" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];	<i>/* if name, e.g. "en0" */</i></td></tr>
<tr><th id="862">862</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a>	<dfn class="decl field" id="ifcapreq::ifcr_capabilities" title='ifcapreq::ifcr_capabilities' data-ref="ifcapreq::ifcr_capabilities" data-ref-filename="ifcapreq..ifcr_capabilities">ifcr_capabilities</dfn>;	<i>/* supported capabiliites */</i></td></tr>
<tr><th id="863">863</th><td>	<a class="typedef" href="../sys/types.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a>	<dfn class="decl field" id="ifcapreq::ifcr_capenable" title='ifcapreq::ifcr_capenable' data-ref="ifcapreq::ifcr_capenable" data-ref-filename="ifcapreq..ifcr_capenable">ifcr_capenable</dfn>;		<i>/* capabilities enabled */</i></td></tr>
<tr><th id="864">864</th><td>};</td></tr>
<tr><th id="865">865</th><td></td></tr>
<tr><th id="866">866</th><td><b>struct</b> <dfn class="type def" id="ifaliasreq" title='ifaliasreq' data-ref="ifaliasreq" data-ref-filename="ifaliasreq">ifaliasreq</dfn> {</td></tr>
<tr><th id="867">867</th><td>	<em>char</em>	<dfn class="decl field" id="ifaliasreq::ifra_name" title='ifaliasreq::ifra_name' data-ref="ifaliasreq::ifra_name" data-ref-filename="ifaliasreq..ifra_name">ifra_name</dfn>[<a class="macro" href="#147" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];		<i>/* if name, e.g. "en0" */</i></td></tr>
<tr><th id="868">868</th><td>	<b>struct</b>	<a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> <dfn class="decl field" id="ifaliasreq::ifra_addr" title='ifaliasreq::ifra_addr' data-ref="ifaliasreq::ifra_addr" data-ref-filename="ifaliasreq..ifra_addr">ifra_addr</dfn>;</td></tr>
<tr><th id="869">869</th><td>	<b>struct</b>	<a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> <dfn class="decl field" id="ifaliasreq::ifra_dstaddr" title='ifaliasreq::ifra_dstaddr' data-ref="ifaliasreq::ifra_dstaddr" data-ref-filename="ifaliasreq..ifra_dstaddr">ifra_dstaddr</dfn>;</td></tr>
<tr><th id="870">870</th><td><u>#define	<dfn class="macro" id="_M/ifra_broadaddr" data-ref="_M/ifra_broadaddr">ifra_broadaddr</dfn>	ifra_dstaddr</u></td></tr>
<tr><th id="871">871</th><td>	<b>struct</b>	<a class="type" href="../sys/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr" data-ref-filename="sockaddr">sockaddr</a> <dfn class="decl field" id="ifaliasreq::ifra_mask" title='ifaliasreq::ifra_mask' data-ref="ifaliasreq::ifra_mask" data-ref-filename="ifaliasreq..ifra_mask">ifra_mask</dfn>;</td></tr>
<tr><th id="872">872</th><td>};</td></tr>
<tr><th id="873">873</th><td></td></tr>
<tr><th id="874">874</th><td><b>struct</b> <dfn class="type def" id="ifdatareq" title='ifdatareq' data-ref="ifdatareq" data-ref-filename="ifdatareq">ifdatareq</dfn> {</td></tr>
<tr><th id="875">875</th><td>	<em>char</em>	<dfn class="decl field" id="ifdatareq::ifdr_name" title='ifdatareq::ifdr_name' data-ref="ifdatareq::ifdr_name" data-ref-filename="ifdatareq..ifdr_name">ifdr_name</dfn>[<a class="macro" href="#147" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];		<i>/* if name, e.g. "en0" */</i></td></tr>
<tr><th id="876">876</th><td>	<b>struct</b>	<a class="type" href="#if_data" title='if_data' data-ref="if_data" data-ref-filename="if_data">if_data</a> <dfn class="decl field" id="ifdatareq::ifdr_data" title='ifdatareq::ifdr_data' data-ref="ifdatareq::ifdr_data" data-ref-filename="ifdatareq..ifdr_data">ifdr_data</dfn>;</td></tr>
<tr><th id="877">877</th><td>};</td></tr>
<tr><th id="878">878</th><td></td></tr>
<tr><th id="879">879</th><td><b>struct</b> <dfn class="type def" id="ifmediareq" title='ifmediareq' data-ref="ifmediareq" data-ref-filename="ifmediareq">ifmediareq</dfn> {</td></tr>
<tr><th id="880">880</th><td>	<em>char</em>	<dfn class="decl field" id="ifmediareq::ifm_name" title='ifmediareq::ifm_name' data-ref="ifmediareq::ifm_name" data-ref-filename="ifmediareq..ifm_name">ifm_name</dfn>[<a class="macro" href="#147" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];	<i>/* if name, e.g. "en0" */</i></td></tr>
<tr><th id="881">881</th><td>	<em>int</em>	<dfn class="decl field" id="ifmediareq::ifm_current" title='ifmediareq::ifm_current' data-ref="ifmediareq::ifm_current" data-ref-filename="ifmediareq..ifm_current">ifm_current</dfn>;		<i>/* IFMWD: current media options */</i></td></tr>
<tr><th id="882">882</th><td>	<em>int</em>	<dfn class="decl field" id="ifmediareq::ifm_mask" title='ifmediareq::ifm_mask' data-ref="ifmediareq::ifm_mask" data-ref-filename="ifmediareq..ifm_mask">ifm_mask</dfn>;		<i>/* IFMWD: don't care mask */</i></td></tr>
<tr><th id="883">883</th><td>	<em>int</em>	<dfn class="decl field" id="ifmediareq::ifm_status" title='ifmediareq::ifm_status' data-ref="ifmediareq::ifm_status" data-ref-filename="ifmediareq..ifm_status">ifm_status</dfn>;		<i>/* media status */</i></td></tr>
<tr><th id="884">884</th><td>	<em>int</em>	<dfn class="decl field" id="ifmediareq::ifm_active" title='ifmediareq::ifm_active' data-ref="ifmediareq::ifm_active" data-ref-filename="ifmediareq..ifm_active">ifm_active</dfn>;		<i>/* IFMWD: active options */</i></td></tr>
<tr><th id="885">885</th><td>	<em>int</em>	<dfn class="decl field" id="ifmediareq::ifm_count" title='ifmediareq::ifm_count' data-ref="ifmediareq::ifm_count" data-ref-filename="ifmediareq..ifm_count">ifm_count</dfn>;		<i>/* # entries in ifm_ulist</i></td></tr>
<tr><th id="886">886</th><td><i>					   array */</i></td></tr>
<tr><th id="887">887</th><td>	<em>int</em>	*<dfn class="decl field" id="ifmediareq::ifm_ulist" title='ifmediareq::ifm_ulist' data-ref="ifmediareq::ifm_ulist" data-ref-filename="ifmediareq..ifm_ulist">ifm_ulist</dfn>;		<i>/* array of ifmedia word */</i></td></tr>
<tr><th id="888">888</th><td>};</td></tr>
<tr><th id="889">889</th><td></td></tr>
<tr><th id="890">890</th><td></td></tr>
<tr><th id="891">891</th><td><b>struct</b>  <dfn class="type def" id="ifdrv" title='ifdrv' data-ref="ifdrv" data-ref-filename="ifdrv">ifdrv</dfn> {</td></tr>
<tr><th id="892">892</th><td>	<em>char</em>		<dfn class="decl field" id="ifdrv::ifd_name" title='ifdrv::ifd_name' data-ref="ifdrv::ifd_name" data-ref-filename="ifdrv..ifd_name">ifd_name</dfn>[<a class="macro" href="#147" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];	<i>/* if name, e.g. "en0" */</i></td></tr>
<tr><th id="893">893</th><td>	<em>unsigned</em> <em>long</em>	<dfn class="decl field" id="ifdrv::ifd_cmd" title='ifdrv::ifd_cmd' data-ref="ifdrv::ifd_cmd" data-ref-filename="ifdrv..ifd_cmd">ifd_cmd</dfn>;</td></tr>
<tr><th id="894">894</th><td>	<a class="typedef" href="../sys/types.h.html#size_t" title='size_t' data-type='unsigned int' data-ref="size_t" data-ref-filename="size_t">size_t</a>		<dfn class="decl field" id="ifdrv::ifd_len" title='ifdrv::ifd_len' data-ref="ifdrv::ifd_len" data-ref-filename="ifdrv..ifd_len">ifd_len</dfn>;</td></tr>
<tr><th id="895">895</th><td>	<em>void</em>		*<dfn class="decl field" id="ifdrv::ifd_data" title='ifdrv::ifd_data' data-ref="ifdrv::ifd_data" data-ref-filename="ifdrv..ifd_data">ifd_data</dfn>;</td></tr>
<tr><th id="896">896</th><td>};</td></tr>
<tr><th id="897">897</th><td><u>#define <dfn class="macro" id="_M/IFLINKSTR_QUERYLEN" data-ref="_M/IFLINKSTR_QUERYLEN">IFLINKSTR_QUERYLEN</dfn>	0x01</u></td></tr>
<tr><th id="898">898</th><td><u>#define <dfn class="macro" id="_M/IFLINKSTR_UNSET" data-ref="_M/IFLINKSTR_UNSET">IFLINKSTR_UNSET</dfn>		0x02</u></td></tr>
<tr><th id="899">899</th><td></td></tr>
<tr><th id="900">900</th><td><i>/*</i></td></tr>
<tr><th id="901">901</th><td><i> * Structure used in SIOCGIFCONF request.</i></td></tr>
<tr><th id="902">902</th><td><i> * Used to retrieve interface configuration</i></td></tr>
<tr><th id="903">903</th><td><i> * for machine (useful for programs which</i></td></tr>
<tr><th id="904">904</th><td><i> * must know all networks accessible).</i></td></tr>
<tr><th id="905">905</th><td><i> */</i></td></tr>
<tr><th id="906">906</th><td><b>struct</b>	<dfn class="type def" id="ifconf" title='ifconf' data-ref="ifconf" data-ref-filename="ifconf">ifconf</dfn> {</td></tr>
<tr><th id="907">907</th><td>	<em>int</em>	<dfn class="decl field" id="ifconf::ifc_len" title='ifconf::ifc_len' data-ref="ifconf::ifc_len" data-ref-filename="ifconf..ifc_len">ifc_len</dfn>;		<i>/* size of associated buffer */</i></td></tr>
<tr><th id="908">908</th><td>	<b>union</b> {</td></tr>
<tr><th id="909">909</th><td>		<em>void</em> *	<dfn class="decl field" id="ifconf::(anonymous)::ifcu_buf" title='ifconf::(anonymous union)::ifcu_buf' data-ref="ifconf::(anonymous)::ifcu_buf" data-ref-filename="ifconf..(anonymous)..ifcu_buf">ifcu_buf</dfn>;</td></tr>
<tr><th id="910">910</th><td>		<b>struct</b>	<a class="type" href="#ifreq" title='ifreq' data-ref="ifreq" data-ref-filename="ifreq">ifreq</a> *<dfn class="decl field" id="ifconf::(anonymous)::ifcu_req" title='ifconf::(anonymous union)::ifcu_req' data-ref="ifconf::(anonymous)::ifcu_req" data-ref-filename="ifconf..(anonymous)..ifcu_req">ifcu_req</dfn>;</td></tr>
<tr><th id="911">911</th><td>	} <dfn class="decl field" id="ifconf::ifc_ifcu" title='ifconf::ifc_ifcu' data-ref="ifconf::ifc_ifcu" data-ref-filename="ifconf..ifc_ifcu">ifc_ifcu</dfn>;</td></tr>
<tr><th id="912">912</th><td><u>#define	<dfn class="macro" id="_M/ifc_buf" data-ref="_M/ifc_buf">ifc_buf</dfn>	ifc_ifcu.ifcu_buf	/* buffer address */</u></td></tr>
<tr><th id="913">913</th><td><u>#define	<dfn class="macro" id="_M/ifc_req" data-ref="_M/ifc_req">ifc_req</dfn>	ifc_ifcu.ifcu_req	/* array of structures returned */</u></td></tr>
<tr><th id="914">914</th><td>};</td></tr>
<tr><th id="915">915</th><td></td></tr>
<tr><th id="916">916</th><td><i>/*</i></td></tr>
<tr><th id="917">917</th><td><i> * Structure for SIOC[AGD]LIFADDR</i></td></tr>
<tr><th id="918">918</th><td><i> */</i></td></tr>
<tr><th id="919">919</th><td><b>struct</b> <dfn class="type def" id="if_laddrreq" title='if_laddrreq' data-ref="if_laddrreq" data-ref-filename="if_laddrreq">if_laddrreq</dfn> {</td></tr>
<tr><th id="920">920</th><td>	<em>char</em> <dfn class="decl field" id="if_laddrreq::iflr_name" title='if_laddrreq::iflr_name' data-ref="if_laddrreq::iflr_name" data-ref-filename="if_laddrreq..iflr_name">iflr_name</dfn>[<a class="macro" href="#147" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];</td></tr>
<tr><th id="921">921</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="if_laddrreq::flags" title='if_laddrreq::flags' data-ref="if_laddrreq::flags" data-ref-filename="if_laddrreq..flags">flags</dfn>;</td></tr>
<tr><th id="922">922</th><td><u>#define <dfn class="macro" id="_M/IFLR_PREFIX" data-ref="_M/IFLR_PREFIX">IFLR_PREFIX</dfn>	0x8000	/* in: prefix given  out: kernel fills id */</u></td></tr>
<tr><th id="923">923</th><td><u>#define <dfn class="macro" id="_M/IFLR_ACTIVE" data-ref="_M/IFLR_ACTIVE">IFLR_ACTIVE</dfn>	0x4000	/* in/out: link-layer address activation */</u></td></tr>
<tr><th id="924">924</th><td><u>#define <dfn class="macro" id="_M/IFLR_FACTORY" data-ref="_M/IFLR_FACTORY">IFLR_FACTORY</dfn>	0x2000	/* in/out: factory link-layer address */</u></td></tr>
<tr><th id="925">925</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="if_laddrreq::prefixlen" title='if_laddrreq::prefixlen' data-ref="if_laddrreq::prefixlen" data-ref-filename="if_laddrreq..prefixlen">prefixlen</dfn>;		<i>/* in/out */</i></td></tr>
<tr><th id="926">926</th><td>	<b>struct</b> <a class="type" href="../sys/socket.h.html#sockaddr_storage" title='sockaddr_storage' data-ref="sockaddr_storage" data-ref-filename="sockaddr_storage">sockaddr_storage</a> <dfn class="decl field" id="if_laddrreq::addr" title='if_laddrreq::addr' data-ref="if_laddrreq::addr" data-ref-filename="if_laddrreq..addr">addr</dfn>;	<i>/* in/out */</i></td></tr>
<tr><th id="927">927</th><td>	<b>struct</b> <a class="type" href="../sys/socket.h.html#sockaddr_storage" title='sockaddr_storage' data-ref="sockaddr_storage" data-ref-filename="sockaddr_storage">sockaddr_storage</a> <dfn class="decl field" id="if_laddrreq::dstaddr" title='if_laddrreq::dstaddr' data-ref="if_laddrreq::dstaddr" data-ref-filename="if_laddrreq..dstaddr">dstaddr</dfn>; <i>/* out */</i></td></tr>
<tr><th id="928">928</th><td>};</td></tr>
<tr><th id="929">929</th><td></td></tr>
<tr><th id="930">930</th><td><i>/*</i></td></tr>
<tr><th id="931">931</th><td><i> * Structure for SIOC[SG]IFADDRPREF</i></td></tr>
<tr><th id="932">932</th><td><i> */</i></td></tr>
<tr><th id="933">933</th><td><b>struct</b> <dfn class="type def" id="if_addrprefreq" title='if_addrprefreq' data-ref="if_addrprefreq" data-ref-filename="if_addrprefreq">if_addrprefreq</dfn> {</td></tr>
<tr><th id="934">934</th><td>	<em>char</em>			<dfn class="decl field" id="if_addrprefreq::ifap_name" title='if_addrprefreq::ifap_name' data-ref="if_addrprefreq::ifap_name" data-ref-filename="if_addrprefreq..ifap_name">ifap_name</dfn>[<a class="macro" href="#147" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];</td></tr>
<tr><th id="935">935</th><td>	<a class="typedef" href="../sys/types.h.html#int16_t" title='int16_t' data-type='__int16_t' data-ref="int16_t" data-ref-filename="int16_t">int16_t</a>			<dfn class="decl field" id="if_addrprefreq::ifap_preference" title='if_addrprefreq::ifap_preference' data-ref="if_addrprefreq::ifap_preference" data-ref-filename="if_addrprefreq..ifap_preference">ifap_preference</dfn>;	<i>/* in/out */</i></td></tr>
<tr><th id="936">936</th><td>	<b>struct</b> <a class="type" href="../sys/socket.h.html#sockaddr_storage" title='sockaddr_storage' data-ref="sockaddr_storage" data-ref-filename="sockaddr_storage">sockaddr_storage</a>	<dfn class="decl field" id="if_addrprefreq::ifap_addr" title='if_addrprefreq::ifap_addr' data-ref="if_addrprefreq::ifap_addr" data-ref-filename="if_addrprefreq..ifap_addr">ifap_addr</dfn>;		<i>/* in/out */</i></td></tr>
<tr><th id="937">937</th><td>};</td></tr>
<tr><th id="938">938</th><td></td></tr>
<tr><th id="939">939</th><td><u>#include <a href="if_arp.h.html">&lt;net/if_arp.h&gt;</a></u></td></tr>
<tr><th id="940">940</th><td></td></tr>
<tr><th id="941">941</th><td><u>#<span data-ppcond="83">endif</span> /* _NETBSD_SOURCE */</u></td></tr>
<tr><th id="942">942</th><td></td></tr>
<tr><th id="943">943</th><td><u>#<span data-ppcond="943">ifdef</span> <span class="macro" data-ref="_M/_KERNEL">_KERNEL</span></u></td></tr>
<tr><th id="944">944</th><td><u>#ifdef ALTQ</u></td></tr>
<tr><th id="945">945</th><td><u>#define IFQ_ENQUEUE(ifq, m, err)					\</u></td></tr>
<tr><th id="946">946</th><td><u>do {									\</u></td></tr>
<tr><th id="947">947</th><td><u>	mutex_enter((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="948">948</th><td><u>	if (ALTQ_IS_ENABLED(ifq))					\</u></td></tr>
<tr><th id="949">949</th><td><u>		ALTQ_ENQUEUE((ifq), (m), (err));			\</u></td></tr>
<tr><th id="950">950</th><td><u>	else {								\</u></td></tr>
<tr><th id="951">951</th><td><u>		if (IF_QFULL(ifq)) {					\</u></td></tr>
<tr><th id="952">952</th><td><u>			m_freem(m);					\</u></td></tr>
<tr><th id="953">953</th><td><u>			(err) = ENOBUFS;				\</u></td></tr>
<tr><th id="954">954</th><td><u>		} else {						\</u></td></tr>
<tr><th id="955">955</th><td><u>			IF_ENQUEUE((ifq), (m));				\</u></td></tr>
<tr><th id="956">956</th><td><u>			(err) = 0;					\</u></td></tr>
<tr><th id="957">957</th><td><u>		}							\</u></td></tr>
<tr><th id="958">958</th><td><u>	}								\</u></td></tr>
<tr><th id="959">959</th><td><u>	if ((err))							\</u></td></tr>
<tr><th id="960">960</th><td><u>		(ifq)-&gt;ifq_drops++;					\</u></td></tr>
<tr><th id="961">961</th><td><u>	mutex_exit((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="962">962</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="963">963</th><td></td></tr>
<tr><th id="964">964</th><td><u>#define IFQ_DEQUEUE(ifq, m)						\</u></td></tr>
<tr><th id="965">965</th><td><u>do {									\</u></td></tr>
<tr><th id="966">966</th><td><u>	mutex_enter((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="967">967</th><td><u>	if (TBR_IS_ENABLED(ifq))					\</u></td></tr>
<tr><th id="968">968</th><td><u>		(m) = tbr_dequeue((ifq), ALTDQ_REMOVE);			\</u></td></tr>
<tr><th id="969">969</th><td><u>	else if (ALTQ_IS_ENABLED(ifq))					\</u></td></tr>
<tr><th id="970">970</th><td><u>		ALTQ_DEQUEUE((ifq), (m));				\</u></td></tr>
<tr><th id="971">971</th><td><u>	else								\</u></td></tr>
<tr><th id="972">972</th><td><u>		IF_DEQUEUE((ifq), (m));					\</u></td></tr>
<tr><th id="973">973</th><td><u>	mutex_exit((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="974">974</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="975">975</th><td></td></tr>
<tr><th id="976">976</th><td><u>#define	IFQ_POLL(ifq, m)						\</u></td></tr>
<tr><th id="977">977</th><td><u>do {									\</u></td></tr>
<tr><th id="978">978</th><td><u>	mutex_enter((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="979">979</th><td><u>	if (TBR_IS_ENABLED(ifq))					\</u></td></tr>
<tr><th id="980">980</th><td><u>		(m) = tbr_dequeue((ifq), ALTDQ_POLL);			\</u></td></tr>
<tr><th id="981">981</th><td><u>	else if (ALTQ_IS_ENABLED(ifq))					\</u></td></tr>
<tr><th id="982">982</th><td><u>		ALTQ_POLL((ifq), (m));					\</u></td></tr>
<tr><th id="983">983</th><td><u>	else								\</u></td></tr>
<tr><th id="984">984</th><td><u>		IF_POLL((ifq), (m));					\</u></td></tr>
<tr><th id="985">985</th><td><u>	mutex_exit((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="986">986</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="987">987</th><td></td></tr>
<tr><th id="988">988</th><td><u>#define	IFQ_PURGE(ifq)							\</u></td></tr>
<tr><th id="989">989</th><td><u>do {									\</u></td></tr>
<tr><th id="990">990</th><td><u>	mutex_enter((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="991">991</th><td><u>	if (ALTQ_IS_ENABLED(ifq))					\</u></td></tr>
<tr><th id="992">992</th><td><u>		ALTQ_PURGE(ifq);					\</u></td></tr>
<tr><th id="993">993</th><td><u>	else								\</u></td></tr>
<tr><th id="994">994</th><td><u>		IF_PURGE(ifq);						\</u></td></tr>
<tr><th id="995">995</th><td><u>	mutex_exit((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="996">996</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="997">997</th><td></td></tr>
<tr><th id="998">998</th><td><u>#define	IFQ_SET_READY(ifq)						\</u></td></tr>
<tr><th id="999">999</th><td><u>do {									\</u></td></tr>
<tr><th id="1000">1000</th><td><u>	(ifq)-&gt;altq_flags |= ALTQF_READY;				\</u></td></tr>
<tr><th id="1001">1001</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="1002">1002</th><td></td></tr>
<tr><th id="1003">1003</th><td><u>#define	IFQ_CLASSIFY(ifq, m, af)					\</u></td></tr>
<tr><th id="1004">1004</th><td><u>do {									\</u></td></tr>
<tr><th id="1005">1005</th><td><u>	KASSERT(((m)-&gt;m_flags &amp; M_PKTHDR) != 0);			\</u></td></tr>
<tr><th id="1006">1006</th><td><u>	mutex_enter((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="1007">1007</th><td><u>	if (ALTQ_IS_ENABLED(ifq)) {					\</u></td></tr>
<tr><th id="1008">1008</th><td><u>		if (ALTQ_NEEDS_CLASSIFY(ifq))				\</u></td></tr>
<tr><th id="1009">1009</th><td><u>			(m)-&gt;m_pkthdr.pattr_class = (*(ifq)-&gt;altq_classify) \</u></td></tr>
<tr><th id="1010">1010</th><td><u>				((ifq)-&gt;altq_clfier, (m), (af));	\</u></td></tr>
<tr><th id="1011">1011</th><td><u>		(m)-&gt;m_pkthdr.pattr_af = (af);				\</u></td></tr>
<tr><th id="1012">1012</th><td><u>		(m)-&gt;m_pkthdr.pattr_hdr = mtod((m), void *);		\</u></td></tr>
<tr><th id="1013">1013</th><td><u>	}								\</u></td></tr>
<tr><th id="1014">1014</th><td><u>	mutex_exit((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="1015">1015</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="1016">1016</th><td><u>#else /* ! ALTQ */</u></td></tr>
<tr><th id="1017">1017</th><td><u>#define	IFQ_ENQUEUE(ifq, m, err)					\</u></td></tr>
<tr><th id="1018">1018</th><td><u>do {									\</u></td></tr>
<tr><th id="1019">1019</th><td><u>	mutex_enter((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="1020">1020</th><td><u>	if (IF_QFULL(ifq)) {						\</u></td></tr>
<tr><th id="1021">1021</th><td><u>		m_freem(m);						\</u></td></tr>
<tr><th id="1022">1022</th><td><u>		(err) = ENOBUFS;					\</u></td></tr>
<tr><th id="1023">1023</th><td><u>	} else {							\</u></td></tr>
<tr><th id="1024">1024</th><td><u>		IF_ENQUEUE((ifq), (m));					\</u></td></tr>
<tr><th id="1025">1025</th><td><u>		(err) = 0;						\</u></td></tr>
<tr><th id="1026">1026</th><td><u>	}								\</u></td></tr>
<tr><th id="1027">1027</th><td><u>	if (err)							\</u></td></tr>
<tr><th id="1028">1028</th><td><u>		(ifq)-&gt;ifq_drops++;					\</u></td></tr>
<tr><th id="1029">1029</th><td><u>	mutex_exit((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="1030">1030</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="1031">1031</th><td></td></tr>
<tr><th id="1032">1032</th><td><u>#define	IFQ_DEQUEUE(ifq, m)						\</u></td></tr>
<tr><th id="1033">1033</th><td><u>do {									\</u></td></tr>
<tr><th id="1034">1034</th><td><u>	mutex_enter((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="1035">1035</th><td><u>	IF_DEQUEUE((ifq), (m));						\</u></td></tr>
<tr><th id="1036">1036</th><td><u>	mutex_exit((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="1037">1037</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="1038">1038</th><td></td></tr>
<tr><th id="1039">1039</th><td><u>#define	IFQ_POLL(ifq, m)						\</u></td></tr>
<tr><th id="1040">1040</th><td><u>do {									\</u></td></tr>
<tr><th id="1041">1041</th><td><u>	mutex_enter((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="1042">1042</th><td><u>	IF_POLL((ifq), (m));						\</u></td></tr>
<tr><th id="1043">1043</th><td><u>	mutex_exit((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="1044">1044</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="1045">1045</th><td></td></tr>
<tr><th id="1046">1046</th><td><u>#define	IFQ_PURGE(ifq)							\</u></td></tr>
<tr><th id="1047">1047</th><td><u>do {									\</u></td></tr>
<tr><th id="1048">1048</th><td><u>	mutex_enter((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="1049">1049</th><td><u>	IF_PURGE(ifq);							\</u></td></tr>
<tr><th id="1050">1050</th><td><u>	mutex_exit((ifq)-&gt;ifq_lock);					\</u></td></tr>
<tr><th id="1051">1051</th><td><u>} while (/*CONSTCOND*/ 0)</u></td></tr>
<tr><th id="1052">1052</th><td></td></tr>
<tr><th id="1053">1053</th><td><u>#define	IFQ_SET_READY(ifq)	/* nothing */</u></td></tr>
<tr><th id="1054">1054</th><td></td></tr>
<tr><th id="1055">1055</th><td><u>#define	IFQ_CLASSIFY(ifq, m, af) /* nothing */</u></td></tr>
<tr><th id="1056">1056</th><td></td></tr>
<tr><th id="1057">1057</th><td><u>#endif /* ALTQ */</u></td></tr>
<tr><th id="1058">1058</th><td></td></tr>
<tr><th id="1059">1059</th><td><u>#define IFQ_LOCK_INIT(ifq)	(ifq)-&gt;ifq_lock =			\</u></td></tr>
<tr><th id="1060">1060</th><td><u>	    mutex_obj_alloc(MUTEX_DEFAULT, IPL_NET)</u></td></tr>
<tr><th id="1061">1061</th><td><u>#define IFQ_LOCK_DESTROY(ifq)	mutex_obj_free((ifq)-&gt;ifq_lock)</u></td></tr>
<tr><th id="1062">1062</th><td><u>#define IFQ_LOCK(ifq)		mutex_enter((ifq)-&gt;ifq_lock)</u></td></tr>
<tr><th id="1063">1063</th><td><u>#define IFQ_UNLOCK(ifq)		mutex_exit((ifq)-&gt;ifq_lock)</u></td></tr>
<tr><th id="1064">1064</th><td></td></tr>
<tr><th id="1065">1065</th><td><u>#define	IFQ_IS_EMPTY(ifq)		IF_IS_EMPTY(ifq)</u></td></tr>
<tr><th id="1066">1066</th><td><u>#define	IFQ_INC_LEN(ifq)		((ifq)-&gt;ifq_len++)</u></td></tr>
<tr><th id="1067">1067</th><td><u>#define	IFQ_DEC_LEN(ifq)		(--(ifq)-&gt;ifq_len)</u></td></tr>
<tr><th id="1068">1068</th><td><u>#define	IFQ_INC_DROPS(ifq)		((ifq)-&gt;ifq_drops++)</u></td></tr>
<tr><th id="1069">1069</th><td><u>#define	IFQ_SET_MAXLEN(ifq, len)	((ifq)-&gt;ifq_maxlen = (len))</u></td></tr>
<tr><th id="1070">1070</th><td></td></tr>
<tr><th id="1071">1071</th><td><u>#include &lt;sys/mallocvar.h&gt;</u></td></tr>
<tr><th id="1072">1072</th><td>MALLOC_DECLARE(M_IFADDR);</td></tr>
<tr><th id="1073">1073</th><td>MALLOC_DECLARE(M_IFMADDR);</td></tr>
<tr><th id="1074">1074</th><td></td></tr>
<tr><th id="1075">1075</th><td><em>int</em> ifreq_setaddr(u_long, <b>struct</b> ifreq *, <em>const</em> <b>struct</b> sockaddr *);</td></tr>
<tr><th id="1076">1076</th><td></td></tr>
<tr><th id="1077">1077</th><td><b>struct</b> ifnet *if_alloc(u_char);</td></tr>
<tr><th id="1078">1078</th><td><em>void</em> if_free(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1079">1079</th><td><em>void</em> if_initname(<b>struct</b> ifnet *, <em>const</em> <em>char</em> *, <em>int</em>);</td></tr>
<tr><th id="1080">1080</th><td><b>struct</b> ifaddr *if_dl_create(<em>const</em> <b>struct</b> ifnet *, <em>const</em> <b>struct</b> sockaddr_dl **);</td></tr>
<tr><th id="1081">1081</th><td><em>void</em> if_activate_sadl(<b>struct</b> ifnet *, <b>struct</b> ifaddr *,</td></tr>
<tr><th id="1082">1082</th><td>    <em>const</em> <b>struct</b> sockaddr_dl *);</td></tr>
<tr><th id="1083">1083</th><td><em>void</em>	if_set_sadl(<b>struct</b> ifnet *, <em>const</em> <em>void</em> *, u_char, bool);</td></tr>
<tr><th id="1084">1084</th><td><em>void</em>	if_alloc_sadl(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1085">1085</th><td><em>void</em>	if_free_sadl(<b>struct</b> ifnet *, <em>int</em>);</td></tr>
<tr><th id="1086">1086</th><td><em>int</em>	if_initialize(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1087">1087</th><td><em>void</em>	if_register(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1088">1088</th><td><em>int</em>	if_attach(<b>struct</b> ifnet *); <i>/* Deprecated. Use if_initialize and if_register */</i></td></tr>
<tr><th id="1089">1089</th><td><em>void</em>	if_attachdomain(<em>void</em>);</td></tr>
<tr><th id="1090">1090</th><td><em>void</em>	if_deactivate(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1091">1091</th><td>bool	if_is_deactivated(<em>const</em> <b>struct</b> ifnet *);</td></tr>
<tr><th id="1092">1092</th><td><em>void</em>	if_purgeaddrs(<b>struct</b> ifnet *, <em>int</em>, <em>void</em> (*)(<b>struct</b> ifaddr *));</td></tr>
<tr><th id="1093">1093</th><td><em>void</em>	if_detach(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1094">1094</th><td><em>void</em>	if_down(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1095">1095</th><td><em>void</em>	if_down_locked(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1096">1096</th><td><em>void</em>	if_link_state_change(<b>struct</b> ifnet *, <em>int</em>);</td></tr>
<tr><th id="1097">1097</th><td><em>void</em>	if_link_state_change_softint(<b>struct</b> ifnet *, <em>int</em>);</td></tr>
<tr><th id="1098">1098</th><td><em>void</em>	if_up(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1099">1099</th><td><em>void</em>	ifinit(<em>void</em>);</td></tr>
<tr><th id="1100">1100</th><td><em>void</em>	ifinit1(<em>void</em>);</td></tr>
<tr><th id="1101">1101</th><td><em>void</em>	ifinit_post(<em>void</em>);</td></tr>
<tr><th id="1102">1102</th><td><em>int</em>	ifaddrpref_ioctl(<b>struct</b> socket *, u_long, <em>void</em> *, <b>struct</b> ifnet *);</td></tr>
<tr><th id="1103">1103</th><td><b>extern</b> <em>int</em> (*ifioctl)(<b>struct</b> socket *, u_long, <em>void</em> *, <b>struct</b> lwp *);</td></tr>
<tr><th id="1104">1104</th><td><em>int</em>	ifioctl_common(<b>struct</b> ifnet *, u_long, <em>void</em> *);</td></tr>
<tr><th id="1105">1105</th><td><em>int</em>	ifpromisc(<b>struct</b> ifnet *, <em>int</em>);</td></tr>
<tr><th id="1106">1106</th><td><em>int</em>	ifpromisc_locked(<b>struct</b> ifnet *, <em>int</em>);</td></tr>
<tr><th id="1107">1107</th><td><em>int</em>	if_addr_init(ifnet_t *, <b>struct</b> ifaddr *, bool);</td></tr>
<tr><th id="1108">1108</th><td><em>int</em>	if_do_dad(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1109">1109</th><td><em>int</em>	if_mcast_op(ifnet_t *, <em>const</em> <em>unsigned</em> <em>long</em>, <em>const</em> <b>struct</b> sockaddr *);</td></tr>
<tr><th id="1110">1110</th><td><em>int</em>	if_flags_set(<b>struct</b> ifnet *, <em>const</em> <em>short</em>);</td></tr>
<tr><th id="1111">1111</th><td><em>int</em>	if_clone_list(<em>int</em>, <em>char</em> *, <em>int</em> *);</td></tr>
<tr><th id="1112">1112</th><td></td></tr>
<tr><th id="1113">1113</th><td><b>struct</b>	ifnet *ifunit(<em>const</em> <em>char</em> *);</td></tr>
<tr><th id="1114">1114</th><td><b>struct</b>	ifnet *if_get(<em>const</em> <em>char</em> *, <b>struct</b> psref *);</td></tr>
<tr><th id="1115">1115</th><td>ifnet_t *if_byindex(u_int);</td></tr>
<tr><th id="1116">1116</th><td>ifnet_t *_if_byindex(u_int);</td></tr>
<tr><th id="1117">1117</th><td>ifnet_t *if_get_byindex(u_int, <b>struct</b> psref *);</td></tr>
<tr><th id="1118">1118</th><td>ifnet_t *if_get_bylla(<em>const</em> <em>void</em> *, <em>unsigned</em> <em>char</em>, <b>struct</b> psref *);</td></tr>
<tr><th id="1119">1119</th><td><em>void</em>	if_put(<em>const</em> <b>struct</b> ifnet *, <b>struct</b> psref *);</td></tr>
<tr><th id="1120">1120</th><td><em>void</em>	if_acquire(<b>struct</b> ifnet *, <b>struct</b> psref *);</td></tr>
<tr><th id="1121">1121</th><td><u>#define	if_release	if_put</u></td></tr>
<tr><th id="1122">1122</th><td></td></tr>
<tr><th id="1123">1123</th><td><em>int</em> if_tunnel_check_nesting(<b>struct</b> ifnet *, <b>struct</b> mbuf *, <em>int</em>);</td></tr>
<tr><th id="1124">1124</th><td></td></tr>
<tr><th id="1125">1125</th><td><em>static</em> <b>__inline</b> if_index_t</td></tr>
<tr><th id="1126">1126</th><td>if_get_index(<em>const</em> <b>struct</b> ifnet *ifp)</td></tr>
<tr><th id="1127">1127</th><td>{</td></tr>
<tr><th id="1128">1128</th><td></td></tr>
<tr><th id="1129">1129</th><td>	<b>return</b> ifp != NULL ? ifp-&gt;if_index : <var>0</var>;</td></tr>
<tr><th id="1130">1130</th><td>}</td></tr>
<tr><th id="1131">1131</th><td></td></tr>
<tr><th id="1132">1132</th><td>bool	if_held(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1133">1133</th><td></td></tr>
<tr><th id="1134">1134</th><td><em>void</em>	if_input(<b>struct</b> ifnet *, <b>struct</b> mbuf *);</td></tr>
<tr><th id="1135">1135</th><td></td></tr>
<tr><th id="1136">1136</th><td><b>struct</b> if_percpuq *</td></tr>
<tr><th id="1137">1137</th><td>	if_percpuq_create(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1138">1138</th><td><em>void</em>	if_percpuq_destroy(<b>struct</b> if_percpuq *);</td></tr>
<tr><th id="1139">1139</th><td><em>void</em></td></tr>
<tr><th id="1140">1140</th><td>	if_percpuq_enqueue(<b>struct</b> if_percpuq *, <b>struct</b> mbuf *);</td></tr>
<tr><th id="1141">1141</th><td></td></tr>
<tr><th id="1142">1142</th><td><em>void</em>	if_deferred_start_init(<b>struct</b> ifnet *, <em>void</em> (*)(<b>struct</b> ifnet *));</td></tr>
<tr><th id="1143">1143</th><td><em>void</em>	if_schedule_deferred_start(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1144">1144</th><td></td></tr>
<tr><th id="1145">1145</th><td><em>void</em> ifa_insert(<b>struct</b> ifnet *, <b>struct</b> ifaddr *);</td></tr>
<tr><th id="1146">1146</th><td><em>void</em> ifa_remove(<b>struct</b> ifnet *, <b>struct</b> ifaddr *);</td></tr>
<tr><th id="1147">1147</th><td></td></tr>
<tr><th id="1148">1148</th><td><em>void</em>	ifa_psref_init(<b>struct</b> ifaddr *);</td></tr>
<tr><th id="1149">1149</th><td><em>void</em>	ifa_acquire(<b>struct</b> ifaddr *, <b>struct</b> psref *);</td></tr>
<tr><th id="1150">1150</th><td><em>void</em>	ifa_release(<b>struct</b> ifaddr *, <b>struct</b> psref *);</td></tr>
<tr><th id="1151">1151</th><td>bool	ifa_held(<b>struct</b> ifaddr *);</td></tr>
<tr><th id="1152">1152</th><td>bool	ifa_is_destroying(<b>struct</b> ifaddr *);</td></tr>
<tr><th id="1153">1153</th><td></td></tr>
<tr><th id="1154">1154</th><td><em>void</em>	ifaref(<b>struct</b> ifaddr *);</td></tr>
<tr><th id="1155">1155</th><td><em>void</em>	ifafree(<b>struct</b> ifaddr *);</td></tr>
<tr><th id="1156">1156</th><td></td></tr>
<tr><th id="1157">1157</th><td><b>struct</b>	ifaddr *ifa_ifwithaddr(<em>const</em> <b>struct</b> sockaddr *);</td></tr>
<tr><th id="1158">1158</th><td><b>struct</b>	ifaddr *ifa_ifwithaddr_psref(<em>const</em> <b>struct</b> sockaddr *, <b>struct</b> psref *);</td></tr>
<tr><th id="1159">1159</th><td><b>struct</b>	ifaddr *ifa_ifwithaf(<em>int</em>);</td></tr>
<tr><th id="1160">1160</th><td><b>struct</b>	ifaddr *ifa_ifwithdstaddr(<em>const</em> <b>struct</b> sockaddr *);</td></tr>
<tr><th id="1161">1161</th><td><b>struct</b>	ifaddr *ifa_ifwithdstaddr_psref(<em>const</em> <b>struct</b> sockaddr *,</td></tr>
<tr><th id="1162">1162</th><td>	    <b>struct</b> psref *);</td></tr>
<tr><th id="1163">1163</th><td><b>struct</b>	ifaddr *ifa_ifwithnet(<em>const</em> <b>struct</b> sockaddr *);</td></tr>
<tr><th id="1164">1164</th><td><b>struct</b>	ifaddr *ifa_ifwithnet_psref(<em>const</em> <b>struct</b> sockaddr *, <b>struct</b> psref *);</td></tr>
<tr><th id="1165">1165</th><td><b>struct</b>	ifaddr *ifa_ifwithladdr(<em>const</em> <b>struct</b> sockaddr *);</td></tr>
<tr><th id="1166">1166</th><td><b>struct</b>	ifaddr *ifa_ifwithladdr_psref(<em>const</em> <b>struct</b> sockaddr *, <b>struct</b> psref *);</td></tr>
<tr><th id="1167">1167</th><td><b>struct</b>	ifaddr *ifaof_ifpforaddr(<em>const</em> <b>struct</b> sockaddr *, <b>struct</b> ifnet *);</td></tr>
<tr><th id="1168">1168</th><td><b>struct</b>	ifaddr *ifaof_ifpforaddr_psref(<em>const</em> <b>struct</b> sockaddr *, <b>struct</b> ifnet *,</td></tr>
<tr><th id="1169">1169</th><td>	    <b>struct</b> psref *);</td></tr>
<tr><th id="1170">1170</th><td><em>void</em>	link_rtrequest(<em>int</em>, <b>struct</b> rtentry *, <em>const</em> <b>struct</b> rt_addrinfo *);</td></tr>
<tr><th id="1171">1171</th><td><em>void</em>	p2p_rtrequest(<em>int</em>, <b>struct</b> rtentry *, <em>const</em> <b>struct</b> rt_addrinfo *);</td></tr>
<tr><th id="1172">1172</th><td></td></tr>
<tr><th id="1173">1173</th><td><em>void</em>	if_clone_attach(<b>struct</b> if_clone *);</td></tr>
<tr><th id="1174">1174</th><td><em>void</em>	if_clone_detach(<b>struct</b> if_clone *);</td></tr>
<tr><th id="1175">1175</th><td></td></tr>
<tr><th id="1176">1176</th><td><em>int</em>	if_transmit_lock(<b>struct</b> ifnet *, <b>struct</b> mbuf *);</td></tr>
<tr><th id="1177">1177</th><td></td></tr>
<tr><th id="1178">1178</th><td><em>int</em>	ifq_enqueue(<b>struct</b> ifnet *, <b>struct</b> mbuf *);</td></tr>
<tr><th id="1179">1179</th><td><em>int</em>	ifq_enqueue2(<b>struct</b> ifnet *, <b>struct</b> ifqueue *, <b>struct</b> mbuf *);</td></tr>
<tr><th id="1180">1180</th><td></td></tr>
<tr><th id="1181">1181</th><td><em>int</em>	loioctl(<b>struct</b> ifnet *, u_long, <em>void</em> *);</td></tr>
<tr><th id="1182">1182</th><td><em>void</em>	loopattach(<em>int</em>);</td></tr>
<tr><th id="1183">1183</th><td><em>void</em>	loopinit(<em>void</em>);</td></tr>
<tr><th id="1184">1184</th><td><em>int</em>	looutput(<b>struct</b> ifnet *,</td></tr>
<tr><th id="1185">1185</th><td>	   <b>struct</b> mbuf *, <em>const</em> <b>struct</b> sockaddr *, <em>const</em> <b>struct</b> rtentry *);</td></tr>
<tr><th id="1186">1186</th><td></td></tr>
<tr><th id="1187">1187</th><td><i>/*</i></td></tr>
<tr><th id="1188">1188</th><td><i> * These are exported because they're an easy way to tell if</i></td></tr>
<tr><th id="1189">1189</th><td><i> * an interface is going away without having to burn a flag.</i></td></tr>
<tr><th id="1190">1190</th><td><i> */</i></td></tr>
<tr><th id="1191">1191</th><td><em>int</em>	if_nulloutput(<b>struct</b> ifnet *, <b>struct</b> mbuf *,</td></tr>
<tr><th id="1192">1192</th><td>	    <em>const</em> <b>struct</b> sockaddr *, <em>const</em> <b>struct</b> rtentry *);</td></tr>
<tr><th id="1193">1193</th><td><em>void</em>	if_nullinput(<b>struct</b> ifnet *, <b>struct</b> mbuf *);</td></tr>
<tr><th id="1194">1194</th><td><em>void</em>	if_nullstart(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1195">1195</th><td><em>int</em>	if_nulltransmit(<b>struct</b> ifnet *, <b>struct</b> mbuf *);</td></tr>
<tr><th id="1196">1196</th><td><em>int</em>	if_nullioctl(<b>struct</b> ifnet *, u_long, <em>void</em> *);</td></tr>
<tr><th id="1197">1197</th><td><em>int</em>	if_nullinit(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1198">1198</th><td><em>void</em>	if_nullstop(<b>struct</b> ifnet *, <em>int</em>);</td></tr>
<tr><th id="1199">1199</th><td><em>void</em>	if_nullslowtimo(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1200">1200</th><td><u>#define	if_nullwatchdog	if_nullslowtimo</u></td></tr>
<tr><th id="1201">1201</th><td><em>void</em>	if_nulldrain(<b>struct</b> ifnet *);</td></tr>
<tr><th id="1202">1202</th><td><u>#<span data-ppcond="943">else</span></u></td></tr>
<tr><th id="1203">1203</th><td><b>struct</b> <dfn class="type def" id="if_nameindex" title='if_nameindex' data-ref="if_nameindex" data-ref-filename="if_nameindex">if_nameindex</dfn> {</td></tr>
<tr><th id="1204">1204</th><td>	<em>unsigned</em> <em>int</em>	<dfn class="decl field" id="if_nameindex::if_index" title='if_nameindex::if_index' data-ref="if_nameindex::if_index" data-ref-filename="if_nameindex..if_index">if_index</dfn>;	<i>/* 1, 2, ... */</i></td></tr>
<tr><th id="1205">1205</th><td>	<em>char</em>		*<dfn class="decl field" id="if_nameindex::if_name" title='if_nameindex::if_name' data-ref="if_nameindex::if_name" data-ref-filename="if_nameindex..if_name">if_name</dfn>;	<i>/* null terminated name: "le0", ... */</i></td></tr>
<tr><th id="1206">1206</th><td>};</td></tr>
<tr><th id="1207">1207</th><td></td></tr>
<tr><th id="1208">1208</th><td><u>#include <a href="../sys/cdefs.h.html">&lt;sys/cdefs.h&gt;</a></u></td></tr>
<tr><th id="1209">1209</th><td><a class="macro" href="../sys/cdefs.h.html#365" title="" data-ref="_M/__BEGIN_DECLS">__BEGIN_DECLS</a></td></tr>
<tr><th id="1210">1210</th><td><em>unsigned</em> <em>int</em> <dfn class="decl fn" id="if_nametoindex" title='if_nametoindex' data-ref="if_nametoindex" data-ref-filename="if_nametoindex">if_nametoindex</dfn>(<em>const</em> <em>char</em> *);</td></tr>
<tr><th id="1211">1211</th><td><em>char</em> *	<dfn class="decl fn" id="if_indextoname" title='if_indextoname' data-ref="if_indextoname" data-ref-filename="if_indextoname">if_indextoname</dfn>(<em>unsigned</em> <em>int</em>, <em>char</em> *);</td></tr>
<tr><th id="1212">1212</th><td><b>struct</b>	<a class="type" href="#if_nameindex" title='if_nameindex' data-ref="if_nameindex" data-ref-filename="if_nameindex">if_nameindex</a> * <dfn class="decl fn" id="if_nameindex" title='if_nameindex' data-ref="if_nameindex" data-ref-filename="if_nameindex">if_nameindex</dfn>(<em>void</em>);</td></tr>
<tr><th id="1213">1213</th><td><em>void</em>	<dfn class="decl fn" id="if_freenameindex" title='if_freenameindex' data-ref="if_freenameindex" data-ref-filename="if_freenameindex">if_freenameindex</dfn>(<b>struct</b> <a class="type" href="#if_nameindex" title='if_nameindex' data-ref="if_nameindex" data-ref-filename="if_nameindex">if_nameindex</a> *);</td></tr>
<tr><th id="1214">1214</th><td><a class="macro" href="../sys/cdefs.h.html#366" title="" data-ref="_M/__END_DECLS">__END_DECLS</a></td></tr>
<tr><th id="1215">1215</th><td><u>#<span data-ppcond="943">endif</span> /* _KERNEL */ /* XXX really ALTQ? */</u></td></tr>
<tr><th id="1216">1216</th><td></td></tr>
<tr><th id="1217">1217</th><td><u>#<span data-ppcond="1217">ifdef</span> <span class="macro" data-ref="_M/_KERNEL">_KERNEL</span></u></td></tr>
<tr><th id="1218">1218</th><td></td></tr>
<tr><th id="1219">1219</th><td><u>#define	IFADDR_FIRST(__ifp)		TAILQ_FIRST(&amp;(__ifp)-&gt;if_addrlist)</u></td></tr>
<tr><th id="1220">1220</th><td><u>#define	IFADDR_NEXT(__ifa)		TAILQ_NEXT((__ifa), ifa_list)</u></td></tr>
<tr><th id="1221">1221</th><td><u>#define	IFADDR_FOREACH(__ifa, __ifp)	TAILQ_FOREACH(__ifa, \</u></td></tr>
<tr><th id="1222">1222</th><td><u>					    &amp;(__ifp)-&gt;if_addrlist, ifa_list)</u></td></tr>
<tr><th id="1223">1223</th><td><u>#define	IFADDR_FOREACH_SAFE(__ifa, __ifp, __nifa) \</u></td></tr>
<tr><th id="1224">1224</th><td><u>					    TAILQ_FOREACH_SAFE(__ifa, \</u></td></tr>
<tr><th id="1225">1225</th><td><u>					    &amp;(__ifp)-&gt;if_addrlist, ifa_list, __nifa)</u></td></tr>
<tr><th id="1226">1226</th><td><u>#define	IFADDR_EMPTY(__ifp)		TAILQ_EMPTY(&amp;(__ifp)-&gt;if_addrlist)</u></td></tr>
<tr><th id="1227">1227</th><td></td></tr>
<tr><th id="1228">1228</th><td><u>#define IFADDR_ENTRY_INIT(__ifa)					\</u></td></tr>
<tr><th id="1229">1229</th><td><u>	PSLIST_ENTRY_INIT((__ifa), ifa_pslist_entry)</u></td></tr>
<tr><th id="1230">1230</th><td><u>#define IFADDR_ENTRY_DESTROY(__ifa)					\</u></td></tr>
<tr><th id="1231">1231</th><td><u>	PSLIST_ENTRY_DESTROY((__ifa), ifa_pslist_entry)</u></td></tr>
<tr><th id="1232">1232</th><td><u>#define IFADDR_READER_EMPTY(__ifp)					\</u></td></tr>
<tr><th id="1233">1233</th><td><u>	(PSLIST_READER_FIRST(&amp;(__ifp)-&gt;if_addr_pslist, struct ifaddr,	\</u></td></tr>
<tr><th id="1234">1234</th><td><u>	                     ifa_pslist_entry) == NULL)</u></td></tr>
<tr><th id="1235">1235</th><td><u>#define IFADDR_READER_FIRST(__ifp)					\</u></td></tr>
<tr><th id="1236">1236</th><td><u>	PSLIST_READER_FIRST(&amp;(__ifp)-&gt;if_addr_pslist, struct ifaddr,	\</u></td></tr>
<tr><th id="1237">1237</th><td><u>	                    ifa_pslist_entry)</u></td></tr>
<tr><th id="1238">1238</th><td><u>#define IFADDR_READER_NEXT(__ifa)					\</u></td></tr>
<tr><th id="1239">1239</th><td><u>	PSLIST_READER_NEXT((__ifa), struct ifaddr, ifa_pslist_entry)</u></td></tr>
<tr><th id="1240">1240</th><td><u>#define IFADDR_READER_FOREACH(__ifa, __ifp)				\</u></td></tr>
<tr><th id="1241">1241</th><td><u>	PSLIST_READER_FOREACH((__ifa), &amp;(__ifp)-&gt;if_addr_pslist, struct ifaddr,\</u></td></tr>
<tr><th id="1242">1242</th><td><u>	                      ifa_pslist_entry)</u></td></tr>
<tr><th id="1243">1243</th><td><u>#define IFADDR_WRITER_INSERT_HEAD(__ifp, __ifa)				\</u></td></tr>
<tr><th id="1244">1244</th><td><u>	PSLIST_WRITER_INSERT_HEAD(&amp;(__ifp)-&gt;if_addr_pslist, (__ifa),	\</u></td></tr>
<tr><th id="1245">1245</th><td><u>	                          ifa_pslist_entry)</u></td></tr>
<tr><th id="1246">1246</th><td><u>#define IFADDR_WRITER_REMOVE(__ifa)					\</u></td></tr>
<tr><th id="1247">1247</th><td><u>	PSLIST_WRITER_REMOVE((__ifa), ifa_pslist_entry)</u></td></tr>
<tr><th id="1248">1248</th><td><u>#define IFADDR_WRITER_FOREACH(__ifa, __ifp)				\</u></td></tr>
<tr><th id="1249">1249</th><td><u>	PSLIST_WRITER_FOREACH((__ifa), &amp;(__ifp)-&gt;if_addr_pslist, struct ifaddr,\</u></td></tr>
<tr><th id="1250">1250</th><td><u>	                      ifa_pslist_entry)</u></td></tr>
<tr><th id="1251">1251</th><td><u>#define IFADDR_WRITER_NEXT(__ifp)					\</u></td></tr>
<tr><th id="1252">1252</th><td><u>	PSLIST_WRITER_NEXT((__ifp), struct ifaddr, ifa_pslist_entry)</u></td></tr>
<tr><th id="1253">1253</th><td><u>#define IFADDR_WRITER_INSERT_AFTER(__ifp, __new)			\</u></td></tr>
<tr><th id="1254">1254</th><td><u>	PSLIST_WRITER_INSERT_AFTER((__ifp), (__new), ifa_pslist_entry)</u></td></tr>
<tr><th id="1255">1255</th><td><u>#define IFADDR_WRITER_EMPTY(__ifp)					\</u></td></tr>
<tr><th id="1256">1256</th><td><u>	(PSLIST_WRITER_FIRST(&amp;(__ifp)-&gt;if_addr_pslist, struct ifaddr,	\</u></td></tr>
<tr><th id="1257">1257</th><td><u>	                     ifa_pslist_entry) == NULL)</u></td></tr>
<tr><th id="1258">1258</th><td><u>#define IFADDR_WRITER_INSERT_TAIL(__ifp, __new)				\</u></td></tr>
<tr><th id="1259">1259</th><td><u>	do {								\</u></td></tr>
<tr><th id="1260">1260</th><td><u>		if (IFADDR_WRITER_EMPTY(__ifp)) {			\</u></td></tr>
<tr><th id="1261">1261</th><td><u>			IFADDR_WRITER_INSERT_HEAD((__ifp), (__new));	\</u></td></tr>
<tr><th id="1262">1262</th><td><u>		} else {						\</u></td></tr>
<tr><th id="1263">1263</th><td><u>			struct ifaddr *__ifa;				\</u></td></tr>
<tr><th id="1264">1264</th><td><u>			IFADDR_WRITER_FOREACH(__ifa, (__ifp)) {		\</u></td></tr>
<tr><th id="1265">1265</th><td><u>				if (IFADDR_WRITER_NEXT(__ifa) == NULL) {\</u></td></tr>
<tr><th id="1266">1266</th><td><u>					IFADDR_WRITER_INSERT_AFTER(__ifa,\</u></td></tr>
<tr><th id="1267">1267</th><td><u>					    (__new));			\</u></td></tr>
<tr><th id="1268">1268</th><td><u>					break;				\</u></td></tr>
<tr><th id="1269">1269</th><td><u>				}					\</u></td></tr>
<tr><th id="1270">1270</th><td><u>			}						\</u></td></tr>
<tr><th id="1271">1271</th><td><u>		}							\</u></td></tr>
<tr><th id="1272">1272</th><td><u>	} while (0)</u></td></tr>
<tr><th id="1273">1273</th><td></td></tr>
<tr><th id="1274">1274</th><td><u>#define	IFNET_GLOBAL_LOCK()			mutex_enter(&amp;ifnet_mtx)</u></td></tr>
<tr><th id="1275">1275</th><td><u>#define	IFNET_GLOBAL_UNLOCK()			mutex_exit(&amp;ifnet_mtx)</u></td></tr>
<tr><th id="1276">1276</th><td><u>#define	IFNET_GLOBAL_LOCKED()			mutex_owned(&amp;ifnet_mtx)</u></td></tr>
<tr><th id="1277">1277</th><td></td></tr>
<tr><th id="1278">1278</th><td><u>#define IFNET_READER_EMPTY() \</u></td></tr>
<tr><th id="1279">1279</th><td><u>	(PSLIST_READER_FIRST(&amp;ifnet_pslist, struct ifnet, if_pslist_entry) == NULL)</u></td></tr>
<tr><th id="1280">1280</th><td><u>#define IFNET_READER_FIRST() \</u></td></tr>
<tr><th id="1281">1281</th><td><u>	PSLIST_READER_FIRST(&amp;ifnet_pslist, struct ifnet, if_pslist_entry)</u></td></tr>
<tr><th id="1282">1282</th><td><u>#define IFNET_READER_NEXT(__ifp) \</u></td></tr>
<tr><th id="1283">1283</th><td><u>	PSLIST_READER_NEXT((__ifp), struct ifnet, if_pslist_entry)</u></td></tr>
<tr><th id="1284">1284</th><td><u>#define IFNET_READER_FOREACH(__ifp) \</u></td></tr>
<tr><th id="1285">1285</th><td><u>	PSLIST_READER_FOREACH((__ifp), &amp;ifnet_pslist, struct ifnet, \</u></td></tr>
<tr><th id="1286">1286</th><td><u>	                      if_pslist_entry)</u></td></tr>
<tr><th id="1287">1287</th><td><u>#define IFNET_WRITER_INSERT_HEAD(__ifp) \</u></td></tr>
<tr><th id="1288">1288</th><td><u>	PSLIST_WRITER_INSERT_HEAD(&amp;ifnet_pslist, (__ifp), if_pslist_entry)</u></td></tr>
<tr><th id="1289">1289</th><td><u>#define IFNET_WRITER_REMOVE(__ifp) \</u></td></tr>
<tr><th id="1290">1290</th><td><u>	PSLIST_WRITER_REMOVE((__ifp), if_pslist_entry)</u></td></tr>
<tr><th id="1291">1291</th><td><u>#define IFNET_WRITER_FOREACH(__ifp) \</u></td></tr>
<tr><th id="1292">1292</th><td><u>	PSLIST_WRITER_FOREACH((__ifp), &amp;ifnet_pslist, struct ifnet, \</u></td></tr>
<tr><th id="1293">1293</th><td><u>	                      if_pslist_entry)</u></td></tr>
<tr><th id="1294">1294</th><td><u>#define IFNET_WRITER_NEXT(__ifp) \</u></td></tr>
<tr><th id="1295">1295</th><td><u>	PSLIST_WRITER_NEXT((__ifp), struct ifnet, if_pslist_entry)</u></td></tr>
<tr><th id="1296">1296</th><td><u>#define IFNET_WRITER_INSERT_AFTER(__ifp, __new) \</u></td></tr>
<tr><th id="1297">1297</th><td><u>	PSLIST_WRITER_INSERT_AFTER((__ifp), (__new), if_pslist_entry)</u></td></tr>
<tr><th id="1298">1298</th><td><u>#define IFNET_WRITER_EMPTY() \</u></td></tr>
<tr><th id="1299">1299</th><td><u>	(PSLIST_WRITER_FIRST(&amp;ifnet_pslist, struct ifnet, if_pslist_entry) == NULL)</u></td></tr>
<tr><th id="1300">1300</th><td><u>#define IFNET_WRITER_INSERT_TAIL(__new)					\</u></td></tr>
<tr><th id="1301">1301</th><td><u>	do {								\</u></td></tr>
<tr><th id="1302">1302</th><td><u>		if (IFNET_WRITER_EMPTY()) {				\</u></td></tr>
<tr><th id="1303">1303</th><td><u>			IFNET_WRITER_INSERT_HEAD(__new);		\</u></td></tr>
<tr><th id="1304">1304</th><td><u>		} else {						\</u></td></tr>
<tr><th id="1305">1305</th><td><u>			struct ifnet *__ifp;				\</u></td></tr>
<tr><th id="1306">1306</th><td><u>			IFNET_WRITER_FOREACH(__ifp) {			\</u></td></tr>
<tr><th id="1307">1307</th><td><u>				if (IFNET_WRITER_NEXT(__ifp) == NULL) {	\</u></td></tr>
<tr><th id="1308">1308</th><td><u>					IFNET_WRITER_INSERT_AFTER(__ifp,\</u></td></tr>
<tr><th id="1309">1309</th><td><u>					    (__new));			\</u></td></tr>
<tr><th id="1310">1310</th><td><u>					break;				\</u></td></tr>
<tr><th id="1311">1311</th><td><u>				}					\</u></td></tr>
<tr><th id="1312">1312</th><td><u>			}						\</u></td></tr>
<tr><th id="1313">1313</th><td><u>		}							\</u></td></tr>
<tr><th id="1314">1314</th><td><u>	} while (0)</u></td></tr>
<tr><th id="1315">1315</th><td></td></tr>
<tr><th id="1316">1316</th><td><u>#define IFNET_LOCK(ifp)		mutex_enter((ifp)-&gt;if_ioctl_lock)</u></td></tr>
<tr><th id="1317">1317</th><td><u>#define IFNET_UNLOCK(ifp)	mutex_exit((ifp)-&gt;if_ioctl_lock)</u></td></tr>
<tr><th id="1318">1318</th><td><u>#define IFNET_LOCKED(ifp)	mutex_owned((ifp)-&gt;if_ioctl_lock)</u></td></tr>
<tr><th id="1319">1319</th><td></td></tr>
<tr><th id="1320">1320</th><td><u>#define IFNET_ASSERT_UNLOCKED(ifp)	\</u></td></tr>
<tr><th id="1321">1321</th><td><u>	KDASSERT(mutex_ownable((ifp)-&gt;if_ioctl_lock))</u></td></tr>
<tr><th id="1322">1322</th><td></td></tr>
<tr><th id="1323">1323</th><td><b>extern</b> <b>struct</b> pslist_head ifnet_pslist;</td></tr>
<tr><th id="1324">1324</th><td><b>extern</b> kmutex_t ifnet_mtx;</td></tr>
<tr><th id="1325">1325</th><td></td></tr>
<tr><th id="1326">1326</th><td><b>extern</b> <b>struct</b> ifnet *lo0ifp;</td></tr>
<tr><th id="1327">1327</th><td></td></tr>
<tr><th id="1328">1328</th><td><i>/*</i></td></tr>
<tr><th id="1329">1329</th><td><i> * ifq sysctl support</i></td></tr>
<tr><th id="1330">1330</th><td><i> */</i></td></tr>
<tr><th id="1331">1331</th><td><em>int</em>	sysctl_ifq(<em>int</em> *name, u_int namelen, <em>void</em> *oldp,</td></tr>
<tr><th id="1332">1332</th><td>		       size_t *oldlenp, <em>void</em> *newp, size_t newlen,</td></tr>
<tr><th id="1333">1333</th><td>		       <b>struct</b> ifqueue *ifq);</td></tr>
<tr><th id="1334">1334</th><td><i>/* symbolic names for terminal (per-protocol) CTL_IFQ_ nodes */</i></td></tr>
<tr><th id="1335">1335</th><td><u>#define IFQCTL_LEN	1</u></td></tr>
<tr><th id="1336">1336</th><td><u>#define IFQCTL_MAXLEN	2</u></td></tr>
<tr><th id="1337">1337</th><td><u>#define IFQCTL_PEAK	3</u></td></tr>
<tr><th id="1338">1338</th><td><u>#define IFQCTL_DROPS	4</u></td></tr>
<tr><th id="1339">1339</th><td></td></tr>
<tr><th id="1340">1340</th><td><i>/* </i></td></tr>
<tr><th id="1341">1341</th><td><i> * Hook for if_vlan - needed by if_agr</i></td></tr>
<tr><th id="1342">1342</th><td><i> */</i></td></tr>
<tr><th id="1343">1343</th><td>MODULE_HOOK(if_vlan_vlan_input_hook, <em>void</em>, (<b>struct</b> ifnet *, <b>struct</b> mbuf *));</td></tr>
<tr><th id="1344">1344</th><td></td></tr>
<tr><th id="1345">1345</th><td><u>#<span data-ppcond="1217">endif</span> /* _KERNEL */</u></td></tr>
<tr><th id="1346">1346</th><td></td></tr>
<tr><th id="1347">1347</th><td><u>#<span data-ppcond="63">endif</span> /* !_NET_IF_H_ */</u></td></tr>
<tr><th id="1348">1348</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../../../../crypto/external/bsd/heimdal/dist/lib/krb5/get_addrs.c.html'>netbsd/crypto/external/bsd/heimdal/dist/lib/krb5/get_addrs.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
