<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>gptmbr.S source code [netbsd/sys/arch/i386/stand/mbr/gptmbr.S] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/sys/arch/i386/stand/mbr/gptmbr.S'; var root_path = '../../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../..'>netbsd</a>/<a href='../../../..'>sys</a>/<a href='../../..'>arch</a>/<a href='../..'>i386</a>/<a href='..'>stand</a>/<a href='./'>mbr</a>/<a href='gptmbr.S.html'>gptmbr.S</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* -----------------------------------------------------------------------</i></td></tr>
<tr><th id="2">2</th><td><i> *</i></td></tr>
<tr><th id="3">3</th><td><i> *   Copyright 2007-2009 H. Peter Anvin - All Rights Reserved</i></td></tr>
<tr><th id="4">4</th><td><i> *   Copyright 2009-2010 Intel Corporation; author: H. Peter Anvin</i></td></tr>
<tr><th id="5">5</th><td><i> *</i></td></tr>
<tr><th id="6">6</th><td><i> *   Permission is hereby granted, free of charge, to any person</i></td></tr>
<tr><th id="7">7</th><td><i> *   obtaining a copy of this software and associated documentation</i></td></tr>
<tr><th id="8">8</th><td><i> *   files (the "Software"), to deal in the Software without</i></td></tr>
<tr><th id="9">9</th><td><i> *   restriction, including without limitation the rights to use,</i></td></tr>
<tr><th id="10">10</th><td><i> *   copy, modify, merge, publish, distribute, sublicense, and/or</i></td></tr>
<tr><th id="11">11</th><td><i> *   sell copies of the Software, and to permit persons to whom</i></td></tr>
<tr><th id="12">12</th><td><i> *   the Software is furnished to do so, subject to the following</i></td></tr>
<tr><th id="13">13</th><td><i> *   conditions:</i></td></tr>
<tr><th id="14">14</th><td><i> *</i></td></tr>
<tr><th id="15">15</th><td><i> *   The above copyright notice and this permission notice shall</i></td></tr>
<tr><th id="16">16</th><td><i> *   be included in all copies or substantial portions of the Software.</i></td></tr>
<tr><th id="17">17</th><td><i> *</i></td></tr>
<tr><th id="18">18</th><td><i> *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,</i></td></tr>
<tr><th id="19">19</th><td><i> *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES</i></td></tr>
<tr><th id="20">20</th><td><i> *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</i></td></tr>
<tr><th id="21">21</th><td><i> *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT</i></td></tr>
<tr><th id="22">22</th><td><i> *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,</i></td></tr>
<tr><th id="23">23</th><td><i> *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</i></td></tr>
<tr><th id="24">24</th><td><i> *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</i></td></tr>
<tr><th id="25">25</th><td><i> *   OTHER DEALINGS IN THE SOFTWARE.</i></td></tr>
<tr><th id="26">26</th><td><i> *</i></td></tr>
<tr><th id="27">27</th><td><i> * ----------------------------------------------------------------------- */</i></td></tr>
<tr><th id="28">28</th><td></td></tr>
<tr><th id="29">29</th><td><u>#include <a href="../../include/asm.h.html">&lt;machine/asm.h&gt;</a></u></td></tr>
<tr><th id="30">30</th><td><u>#include <a href="../../../../sys/bootblock.h.html">&lt;sys/bootblock.h&gt;</a></u></td></tr>
<tr><th id="31">31</th><td></td></tr>
<tr><th id="32">32</th><td><u>#<span data-ppcond="32">ifdef</span> <span class="macro" data-ref="_M/CTRL_80">CTRL_80</span></u></td></tr>
<tr><th id="33">33</th><td>	.macro ADJUST_DRIVE</td></tr>
<tr><th id="34">34</th><td>	testb	$<var>0x04</var>, BIOS_kbdflags</td></tr>
<tr><th id="35">35</th><td>	jz	<var>1f</var></td></tr>
<tr><th id="36">36</th><td>	movb	$<var>0x80</var>, %dl</td></tr>
<tr><th id="37">37</th><td><var>1</var>:</td></tr>
<tr><th id="38">38</th><td>	.endm</td></tr>
<tr><th id="39">39</th><td><u>#<span data-ppcond="32">elif</span> defined(<span class="macro" data-ref="_M/FORCE_80">FORCE_80</span>)</u></td></tr>
<tr><th id="40">40</th><td>	.macro ADJUST_DRIVE</td></tr>
<tr><th id="41">41</th><td>	movb	$<var>0x80</var>, %dl</td></tr>
<tr><th id="42">42</th><td>	.endm</td></tr>
<tr><th id="43">43</th><td><u>#<span data-ppcond="32">else</span></u></td></tr>
<tr><th id="44">44</th><td>	<span class='error' title="expected identifier or &apos;(&apos;">.</span>macro ADJUST_DRIVE</td></tr>
<tr><th id="45">45</th><td>	.endm</td></tr>
<tr><th id="46">46</th><td><u>#<span data-ppcond="32">endif</span></u></td></tr>
<tr><th id="47">47</th><td></td></tr>
<tr><th id="48">48</th><td>	.code16</td></tr>
<tr><th id="49">49</th><td>	.text</td></tr>
<tr><th id="50">50</th><td></td></tr>
<tr><th id="51">51</th><td>	.globl	bootsec</td></tr>
<tr><th id="52">52</th><td>stack		= <var>0x7c00</var></td></tr>
<tr><th id="53">53</th><td></td></tr>
<tr><th id="54">54</th><td><i>/* Partition table header here */</i></td></tr>
<tr><th id="55">55</th><td>phdr		= stack		<i>/* Above the stack, overwritten by bootsect */</i></td></tr>
<tr><th id="56">56</th><td><i>/* Partition table sector here */</i></td></tr>
<tr><th id="57">57</th><td><i>/* To handle &gt; 32K we need to play segment tricks... */</i></td></tr>
<tr><th id="58">58</th><td>psec		= _phdr + <var>512</var></td></tr>
<tr><th id="59">59</th><td></td></tr>
<tr><th id="60">60</th><td><i>/* Where we put DS:SI */</i></td></tr>
<tr><th id="61">61</th><td>dssi_out	= start + <var>0x1be</var></td></tr>
<tr><th id="62">62</th><td></td></tr>
<tr><th id="63">63</th><td>BIOS_kbdflags	= <var>0x417</var></td></tr>
<tr><th id="64">64</th><td>BIOS_page	= <var>0x462</var></td></tr>
<tr><th id="65">65</th><td></td></tr>
<tr><th id="66">66</th><td>	<i>/* gas/ld has issues with doing this as absolute addresses... */</i></td></tr>
<tr><th id="67">67</th><td>	.section <q>".bootsec"</q>, <q>"a"</q>, @nobits</td></tr>
<tr><th id="68">68</th><td>	.globl	bootsec</td></tr>
<tr><th id="69">69</th><td>bootsec:</td></tr>
<tr><th id="70">70</th><td>	.space	<var>512</var></td></tr>
<tr><th id="71">71</th><td></td></tr>
<tr><th id="72">72</th><td>	.text</td></tr>
<tr><th id="73">73</th><td>	.globl	start</td></tr>
<tr><th id="74">74</th><td>start:</td></tr>
<tr><th id="75">75</th><td>	cli</td></tr>
<tr><th id="76">76</th><td>	xorw	%ax, %ax</td></tr>
<tr><th id="77">77</th><td>	movw	%ax, %ds</td></tr>
<tr><th id="78">78</th><td>	movw	%ax, %ss</td></tr>
<tr><th id="79">79</th><td>	movw	$stack, %sp</td></tr>
<tr><th id="80">80</th><td>	movw	%sp, %si</td></tr>
<tr><th id="81">81</th><td>	pushw	%es		<i>/* 4(%bp) es:di -&gt; $PnP header */</i></td></tr>
<tr><th id="82">82</th><td>	pushw	%di		<i>/* 2(%bp) */</i></td></tr>
<tr><th id="83">83</th><td>	movw	%ax, %es</td></tr>
<tr><th id="84">84</th><td>	sti</td></tr>
<tr><th id="85">85</th><td>	cld</td></tr>
<tr><th id="86">86</th><td></td></tr>
<tr><th id="87">87</th><td>	<i>/* Copy down to 0:0x600 */</i></td></tr>
<tr><th id="88">88</th><td>	movw	$start, %di</td></tr>
<tr><th id="89">89</th><td>	movw	$(<var>512</var>/<var>2</var>), %cx</td></tr>
<tr><th id="90">90</th><td>	rep; <span class='error' title="unknown type name &apos;movsw&apos;">movsw</span></td></tr>
<tr><th id="91">91</th><td></td></tr>
<tr><th id="92">92</th><td>	<dfn class="tu decl def" id="ljmpw" title='ljmpw' data-type='int' data-ref="ljmpw" data-ref-filename="ljmpw">ljmpw</dfn><span class='error' title="expected &apos;;&apos; after top level declarator"></span>	$<var>0</var>, $next</td></tr>
<tr><th id="93">93</th><td>next:</td></tr>
<tr><th id="94">94</th><td></td></tr>
<tr><th id="95">95</th><td>	ADJUST_DRIVE</td></tr>
<tr><th id="96">96</th><td>	pushw	%dx		<i>/* 0(%bp) = %dl -&gt; drive number */</i></td></tr>
<tr><th id="97">97</th><td></td></tr>
<tr><th id="98">98</th><td>	<i>/* Check to see if we have EBIOS */</i></td></tr>
<tr><th id="99">99</th><td>	pushw	%dx		<i>/* drive number */</i></td></tr>
<tr><th id="100">100</th><td>	movb	$<var>0x41</var>, %ah	<i>/* %al == 0 already */</i></td></tr>
<tr><th id="101">101</th><td>	movw	$<var>0x55aa</var>, %bx</td></tr>
<tr><th id="102">102</th><td>	xorw	%cx, %cx</td></tr>
<tr><th id="103">103</th><td>	xorb	%dh, %dh</td></tr>
<tr><th id="104">104</th><td>	stc</td></tr>
<tr><th id="105">105</th><td>	<em>int</em>	$<var>0x13</var></td></tr>
<tr><th id="106">106</th><td>	jc	<var>1f</var></td></tr>
<tr><th id="107">107</th><td>	cmpw	$<var>0xaa55</var>, %bx</td></tr>
<tr><th id="108">108</th><td>	jne	<var>1f</var></td></tr>
<tr><th id="109">109</th><td>	shrw	%cx		<i>/* Bit 0 = fixed disk subset */</i></td></tr>
<tr><th id="110">110</th><td>	jnc	<var>1f</var></td></tr>
<tr><th id="111">111</th><td></td></tr>
<tr><th id="112">112</th><td>	<i>/* We have EBIOS; patch in the following code at</i></td></tr>
<tr><th id="113">113</th><td><i>	   read_sector_cbios: movb $0x42, %ah ;  jmp read_common */</i></td></tr>
<tr><th id="114">114</th><td>	movl	$<var>0xeb42b4</var>+((read_common-read_sector_cbios-<var>4</var>) &lt;&lt; <var>24</var>), \</td></tr>
<tr><th id="115">115</th><td>		(read_sector_cbios)</td></tr>
<tr><th id="116">116</th><td></td></tr>
<tr><th id="117">117</th><td><var>1</var>:</td></tr>
<tr><th id="118">118</th><td>	popw	%dx</td></tr>
<tr><th id="119">119</th><td></td></tr>
<tr><th id="120">120</th><td>	<i>/* Get (C)HS geometry */</i></td></tr>
<tr><th id="121">121</th><td>	movb	$<var>0x08</var>, %ah</td></tr>
<tr><th id="122">122</th><td>	<em>int</em>	$<var>0x13</var></td></tr>
<tr><th id="123">123</th><td>	andw	$<var>0x3f</var>, %cx	<i>/* Sector count */</i></td></tr>
<tr><th id="124">124</th><td>	movw	%sp, %bp	<i>/* %bp -&gt; frame pointer: LEAVE UNCHANGED */</i></td></tr>
<tr><th id="125">125</th><td>	pushw	%cx		<i>/* -2(%bp) Save sectors on the stack */</i></td></tr>
<tr><th id="126">126</th><td>	movzbw	%dh, %ax	<i>/* dh = max head */</i></td></tr>
<tr><th id="127">127</th><td>	incw	%ax		<i>/* From 0-based max to count */</i></td></tr>
<tr><th id="128">128</th><td>	mulw	%cx		<i>/* Heads*sectors -&gt; sectors per cylinder */</i></td></tr>
<tr><th id="129">129</th><td></td></tr>
<tr><th id="130">130</th><td>	<i>/* Save sectors/cylinder on the stack */</i></td></tr>
<tr><th id="131">131</th><td>	pushw	%dx		<i>/* -4(%bp) High word */</i></td></tr>
<tr><th id="132">132</th><td>	pushw	%ax		<i>/* -6(%bp) Low word */</i></td></tr>
<tr><th id="133">133</th><td></td></tr>
<tr><th id="134">134</th><td>	<i>/* Load partition table header */</i></td></tr>
<tr><th id="135">135</th><td>	xorl	%eax,%eax</td></tr>
<tr><th id="136">136</th><td>	cltd</td></tr>
<tr><th id="137">137</th><td>	incw	%ax		<i>/* %edx:%eax = 1 */</i></td></tr>
<tr><th id="138">138</th><td>	movw	$phdr, %bx</td></tr>
<tr><th id="139">139</th><td>	pushw	%bx		<i>/* -8(%bp) phdr == bootsect */</i></td></tr>
<tr><th id="140">140</th><td>	call	read_sector</td></tr>
<tr><th id="141">141</th><td></td></tr>
<tr><th id="142">142</th><td>	<i>/* Number of partition sectors */</i></td></tr>
<tr><th id="143">143</th><td>	<i>/* We assume the partition table is 32K or less, and that</i></td></tr>
<tr><th id="144">144</th><td><i>	   the sector size is 512. */</i></td></tr>
<tr><th id="145">145</th><td>	<i>/* Note: phdr == 6(%bp) */</i></td></tr>
<tr><th id="146">146</th><td>	movw	(<var>80</var>+<var>6</var>)(%bp),%cx		<i>/* NumberOfPartitionEntries */</i></td></tr>
<tr><th id="147">147</th><td>	movw	(<var>84</var>+<var>6</var>)(%bp),%ax		<i>/* SizeOfPartitionEntry */</i></td></tr>
<tr><th id="148">148</th><td>	pushw	%ax</td></tr>
<tr><th id="149">149</th><td>	pushw	%cx</td></tr>
<tr><th id="150">150</th><td>	mulw	%cx</td></tr>
<tr><th id="151">151</th><td>	shrw	$<var>9</var>,%ax</td></tr>
<tr><th id="152">152</th><td>	xchgw	%ax,%cx</td></tr>
<tr><th id="153">153</th><td>	incw	%cx</td></tr>
<tr><th id="154">154</th><td></td></tr>
<tr><th id="155">155</th><td>	<i>/* Starting LBA of partition array */</i></td></tr>
<tr><th id="156">156</th><td>	movl	(<var>72</var>+<var>6</var>)(%bp),%eax</td></tr>
<tr><th id="157">157</th><td>	movl	(<var>76</var>+<var>6</var>)(%bp),%edx</td></tr>
<tr><th id="158">158</th><td></td></tr>
<tr><th id="159">159</th><td>	pushw	%bx</td></tr>
<tr><th id="160">160</th><td>get_ptab:</td></tr>
<tr><th id="161">161</th><td>	call	read_sector</td></tr>
<tr><th id="162">162</th><td>	call	inc64</td></tr>
<tr><th id="163">163</th><td>	loop	get_ptab</td></tr>
<tr><th id="164">164</th><td></td></tr>
<tr><th id="165">165</th><td>	<i>/* Find the boot partition */</i></td></tr>
<tr><th id="166">166</th><td>	xorw	%si,%si			<i>/* Nothing found yet */</i></td></tr>
<tr><th id="167">167</th><td>	popw	%di			<i>/* Partition table in memory */</i></td></tr>
<tr><th id="168">168</th><td>	popw	%cx			<i>/* NumberOfPartitionEntries */</i></td></tr>
<tr><th id="169">169</th><td>	popw	%ax			<i>/* SizeOfPartitionEntry */</i></td></tr>
<tr><th id="170">170</th><td></td></tr>
<tr><th id="171">171</th><td>find_part:</td></tr>
<tr><th id="172">172</th><td>	<i>/* If the PartitionTypeGUID is all zero, it's an empty slot */</i></td></tr>
<tr><th id="173">173</th><td>	movl	  (%di),%edx</td></tr>
<tr><th id="174">174</th><td>	orl	 <var>4</var>(%di),%edx</td></tr>
<tr><th id="175">175</th><td>	orl	 <var>8</var>(%di),%edx</td></tr>
<tr><th id="176">176</th><td>	orl	<var>12</var>(%di),%edx</td></tr>
<tr><th id="177">177</th><td>	jz	not_this</td></tr>
<tr><th id="178">178</th><td>	testb	$<var>0x04</var>,<var>48</var>(%di)</td></tr>
<tr><th id="179">179</th><td>	jz	not_this</td></tr>
<tr><th id="180">180</th><td>	andw	%si,%si</td></tr>
<tr><th id="181">181</th><td>	jnz	found_multiple</td></tr>
<tr><th id="182">182</th><td>	movw	%di,%si</td></tr>
<tr><th id="183">183</th><td>not_this:</td></tr>
<tr><th id="184">184</th><td>	addw	%ax,%di</td></tr>
<tr><th id="185">185</th><td>	loop	find_part</td></tr>
<tr><th id="186">186</th><td></td></tr>
<tr><th id="187">187</th><td>	andw	%si,%si</td></tr>
<tr><th id="188">188</th><td>	jnz	found_part</td></tr>
<tr><th id="189">189</th><td></td></tr>
<tr><th id="190">190</th><td>missing_os:</td></tr>
<tr><th id="191">191</th><td>	call	error</td></tr>
<tr><th id="192">192</th><td>	.ascii	<q>"Missing OS\r\n"</q></td></tr>
<tr><th id="193">193</th><td></td></tr>
<tr><th id="194">194</th><td>found_multiple:</td></tr>
<tr><th id="195">195</th><td>	call	error</td></tr>
<tr><th id="196">196</th><td>	.ascii	<q>"Multiple active partitions\r\n"</q></td></tr>
<tr><th id="197">197</th><td></td></tr>
<tr><th id="198">198</th><td>found_part:</td></tr>
<tr><th id="199">199</th><td>	xchgw	%ax,%cx		<i>/* Set up %cx for rep movsb further down */</i></td></tr>
<tr><th id="200">200</th><td></td></tr>
<tr><th id="201">201</th><td>	movw	$dssi_out,%di</td></tr>
<tr><th id="202">202</th><td>	pushw	%di</td></tr>
<tr><th id="203">203</th><td></td></tr>
<tr><th id="204">204</th><td>	<i>/* 80 00 00 00 ee 00 00 00</i></td></tr>
<tr><th id="205">205</th><td><i>	   - bootable partition, type EFI (EE), no CHS information */</i></td></tr>
<tr><th id="206">206</th><td>	xorl	%eax,%eax</td></tr>
<tr><th id="207">207</th><td>	movb	$<var>0x80</var>,%al</td></tr>
<tr><th id="208">208</th><td>	stosl</td></tr>
<tr><th id="209">209</th><td>	movb	$<var>0xed</var>,%al</td></tr>
<tr><th id="210">210</th><td>	stosl</td></tr>
<tr><th id="211">211</th><td>	movl	<var>32</var>(%si),%eax</td></tr>
<tr><th id="212">212</th><td>	movl	<var>36</var>(%si),%edx</td></tr>
<tr><th id="213">213</th><td>	call	saturate_stosl		<i>/* Partition start */</i></td></tr>
<tr><th id="214">214</th><td></td></tr>
<tr><th id="215">215</th><td>	movl	<var>40</var>(%si),%eax</td></tr>
<tr><th id="216">216</th><td>	movl	<var>44</var>(%si),%edx</td></tr>
<tr><th id="217">217</th><td>	subl	<var>32</var>(%si),%eax</td></tr>
<tr><th id="218">218</th><td>	sbbl	<var>36</var>(%si),%edx</td></tr>
<tr><th id="219">219</th><td>	call	inc64</td></tr>
<tr><th id="220">220</th><td>	call	saturate_stosl		<i>/* Partition length */</i></td></tr>
<tr><th id="221">221</th><td></td></tr>
<tr><th id="222">222</th><td>	movzwl	%cx,%eax		<i>/* Length of GPT entry */</i></td></tr>
<tr><th id="223">223</th><td>	stosl</td></tr>
<tr><th id="224">224</th><td>	</td></tr>
<tr><th id="225">225</th><td>	rep; <span class='error' title="unknown type name &apos;movsb&apos;">movsb</span>			<i  data-doc="popw">/* GPT entry follows MBR entry */</i></td></tr>
<tr><th id="226">226</th><td>	<dfn class="tu decl def" id="popw" title='popw' data-type='int' data-ref="popw" data-ref-filename="popw">popw</dfn><span class='error' title="expected &apos;;&apos; after top level declarator"></span>	%si</td></tr>
<tr><th id="227">227</th><td></td></tr>
<tr><th id="228">228</th><td><i>/*</i></td></tr>
<tr><th id="229">229</th><td><i> * boot: invoke the actual bootstrap. %ds:%si points to the</i></td></tr>
<tr><th id="230">230</th><td><i> * partition information in memory.  The top word on the stack</i></td></tr>
<tr><th id="231">231</th><td><i> * is phdr == 0x7c00 == the address of the boot sector.</i></td></tr>
<tr><th id="232">232</th><td><i> */</i></td></tr>
<tr><th id="233">233</th><td>boot:</td></tr>
<tr><th id="234">234</th><td>	movl	(<var>32</var>+<var>20</var>)(%si),%eax</td></tr>
<tr><th id="235">235</th><td>	movl	(<var>36</var>+<var>20</var>)(%si),%edx</td></tr>
<tr><th id="236">236</th><td>	popw	%bx</td></tr>
<tr><th id="237">237</th><td>	call	read_sector</td></tr>
<tr><th id="238">238</th><td>	cmpw	$<var>0xaa55</var>, -<var>2</var>(%bx)</td></tr>
<tr><th id="239">239</th><td>	jne	missing_os	<i>/* Not a valid boot sector */</i></td></tr>
<tr><th id="240">240</th><td>	movw	%bp, %sp	<i>/* driveno == bootsec-6 */</i></td></tr>
<tr><th id="241">241</th><td>	popw	%dx		<i>/* dl -&gt; drive number */</i></td></tr>
<tr><th id="242">242</th><td>	popw	%di		<i>/* es:di -&gt; $PnP vector */</i></td></tr>
<tr><th id="243">243</th><td>	popw	%es</td></tr>
<tr><th id="244">244</th><td>	movl	$<var>0x54504721</var>,%eax <i>/* !GPT magic number */</i></td></tr>
<tr><th id="245">245</th><td>	cli</td></tr>
<tr><th id="246">246</th><td>	jmpw	*%sp		<i>/* %sp == bootsec */</i></td></tr>
<tr><th id="247">247</th><td></td></tr>
<tr><th id="248">248</th><td><i>/*</i></td></tr>
<tr><th id="249">249</th><td><i> * Store the value in %eax to %di iff %edx == 0, otherwise store -1.</i></td></tr>
<tr><th id="250">250</th><td><i> * Returns the value that was actually written in %eax.</i></td></tr>
<tr><th id="251">251</th><td><i> */</i></td></tr>
<tr><th id="252">252</th><td>saturate_stosl:</td></tr>
<tr><th id="253">253</th><td>	andl	%edx,%edx</td></tr>
<tr><th id="254">254</th><td>	jz <var>1f</var></td></tr>
<tr><th id="255">255</th><td>	orl	$-<var>1</var>,%eax</td></tr>
<tr><th id="256">256</th><td><var>1</var>:	stosl</td></tr>
<tr><th id="257">257</th><td>	ret</td></tr>
<tr><th id="258">258</th><td></td></tr>
<tr><th id="259">259</th><td><i>/*</i></td></tr>
<tr><th id="260">260</th><td><i> * Increment %edx:%eax</i></td></tr>
<tr><th id="261">261</th><td><i> */</i></td></tr>
<tr><th id="262">262</th><td>inc64:</td></tr>
<tr><th id="263">263</th><td>	addl	$<var>1</var>,%eax</td></tr>
<tr><th id="264">264</th><td>	adcl	$<var>0</var>,%edx</td></tr>
<tr><th id="265">265</th><td>	ret</td></tr>
<tr><th id="266">266</th><td></td></tr>
<tr><th id="267">267</th><td><i>/*</i></td></tr>
<tr><th id="268">268</th><td><i> * read_sector: read a single sector pointed to by %edx:%eax to</i></td></tr>
<tr><th id="269">269</th><td><i> * %es:%bx.  CF is set on error.  All registers saved.</i></td></tr>
<tr><th id="270">270</th><td><i> */</i></td></tr>
<tr><th id="271">271</th><td>read_sector:</td></tr>
<tr><th id="272">272</th><td>	pushal</td></tr>
<tr><th id="273">273</th><td>	pushl	%edx	<i>/* MSW of LBA */</i></td></tr>
<tr><th id="274">274</th><td>	pushl	%eax	<i>/* LSW of LBA */</i></td></tr>
<tr><th id="275">275</th><td>	pushw	%es	<i>/* Buffer segment */</i></td></tr>
<tr><th id="276">276</th><td>	pushw	%bx	<i>/* Buffer offset */</i></td></tr>
<tr><th id="277">277</th><td>	pushw	$<var>1</var>	<i>/* Sector count */</i></td></tr>
<tr><th id="278">278</th><td>	pushw	$<var>16</var>	<i>/* Size of packet */</i></td></tr>
<tr><th id="279">279</th><td>	movw	%sp, %si</td></tr>
<tr><th id="280">280</th><td></td></tr>
<tr><th id="281">281</th><td>	<i>/* This chunk is skipped if we have ebios */</i></td></tr>
<tr><th id="282">282</th><td>	<i>/* Do not clobber %es:%bx or %edx:%eax before this chunk! */</i></td></tr>
<tr><th id="283">283</th><td>read_sector_cbios:</td></tr>
<tr><th id="284">284</th><td>	divl	-<var>6</var>(%bp)	<i>/* secpercyl */</i></td></tr>
<tr><th id="285">285</th><td>	shlb	$<var>6</var>, %ah</td></tr>
<tr><th id="286">286</th><td>	movb	%ah, %cl</td></tr>
<tr><th id="287">287</th><td>	movb	%al, %ch</td></tr>
<tr><th id="288">288</th><td>	xchgw	%dx, %ax</td></tr>
<tr><th id="289">289</th><td>	divb	-<var>2</var>(%bp)	<i>/* sectors */</i></td></tr>
<tr><th id="290">290</th><td>	movb	%al, %dh</td></tr>
<tr><th id="291">291</th><td>	orb	%ah, %cl</td></tr>
<tr><th id="292">292</th><td>	incw	%cx	<i>/* Sectors are 1-based */</i></td></tr>
<tr><th id="293">293</th><td>	movw	$<var>0x0201</var>, %ax</td></tr>
<tr><th id="294">294</th><td></td></tr>
<tr><th id="295">295</th><td>read_common:</td></tr>
<tr><th id="296">296</th><td>	movb	(%bp), %dl <i>/* driveno */</i></td></tr>
<tr><th id="297">297</th><td>	<em>int</em>	$<var>0x13</var></td></tr>
<tr><th id="298">298</th><td>	leaw	<var>16</var>(%si), %sp	<i>/* Drop DAPA */</i></td></tr>
<tr><th id="299">299</th><td>	popal</td></tr>
<tr><th id="300">300</th><td>	jc	disk_error</td></tr>
<tr><th id="301">301</th><td>	addb	$<var>2</var>, %bh		<i>/* bx += 512: point to the next buffer */</i></td></tr>
<tr><th id="302">302</th><td>	ret</td></tr>
<tr><th id="303">303</th><td></td></tr>
<tr><th id="304">304</th><td>disk_error:</td></tr>
<tr><th id="305">305</th><td>	call	error</td></tr>
<tr><th id="306">306</th><td>	.ascii	<q>"Disk error on boot\r\n"</q></td></tr>
<tr><th id="307">307</th><td></td></tr>
<tr><th id="308">308</th><td><i>/*</i></td></tr>
<tr><th id="309">309</th><td><i> * Print error messages.  This is invoked with "call", with the</i></td></tr>
<tr><th id="310">310</th><td><i> * error message at the return address.</i></td></tr>
<tr><th id="311">311</th><td><i> */</i></td></tr>
<tr><th id="312">312</th><td>error:</td></tr>
<tr><th id="313">313</th><td>	popw	%si</td></tr>
<tr><th id="314">314</th><td><var>2</var>:</td></tr>
<tr><th id="315">315</th><td>	lodsb</td></tr>
<tr><th id="316">316</th><td>	movb	$<var>0x0e</var>, %ah</td></tr>
<tr><th id="317">317</th><td>	movb	(BIOS_page), %bh</td></tr>
<tr><th id="318">318</th><td>	movb	$<var>0x07</var>, %bl</td></tr>
<tr><th id="319">319</th><td>	<em>int</em>	$<var>0x10</var>		<i>/* May destroy %bp */</i></td></tr>
<tr><th id="320">320</th><td>	cmpb	$<var>10</var>, %al	<i>/* Newline? */</i></td></tr>
<tr><th id="321">321</th><td>	jne	<var>2b</var></td></tr>
<tr><th id="322">322</th><td></td></tr>
<tr><th id="323">323</th><td>	<em>int</em>	$<var>0x18</var>		<i>/* Boot failure */</i></td></tr>
<tr><th id="324">324</th><td>die:</td></tr>
<tr><th id="325">325</th><td>	hlt</td></tr>
<tr><th id="326">326</th><td>	jmp	die</td></tr>
<tr><th id="327">327</th><td></td></tr>
<tr><th id="328">328</th><td>mbr_space = end - .</td></tr>
<tr><th id="329">329</th><td>	. = <a class="macro" href="../../../../sys/bootblock.h.html#202" title="440" data-ref="_M/MBR_DSN_OFFSET">MBR_DSN_OFFSET</a></td></tr>
<tr><th id="330">330</th><td>end:</td></tr>
<tr><th id="331">331</th><td></td></tr>
</table><hr/><p id='footer'>
Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
