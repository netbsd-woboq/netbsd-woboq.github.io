<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>cpu_extended_state.h source code [netbsd/sys/arch/x86/include/cpu_extended_state.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="fp_addr,fpacc87,fpaccfx,fxsave,hi16_zmmreg,save87,savefpu,xmmreg,xsave_header,xsave_hi16_zmm,xsave_opmask,xsave_ymm,xsave_zmm_hi256,xstate,ymmreg,zmmreg "/>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/sys/arch/x86/include/cpu_extended_state.h'; var root_path = '../../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>netbsd</a>/<a href='../../..'>sys</a>/<a href='../..'>arch</a>/<a href='..'>x86</a>/<a href='./'>include</a>/<a href='cpu_extended_state.h.html'>cpu_extended_state.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*	$NetBSD: cpu_extended_state.h,v 1.17 2019/06/26 12:30:13 mgorny Exp $	*/</i></td></tr>
<tr><th id="2">2</th><td></td></tr>
<tr><th id="3">3</th><td><u>#<span data-ppcond="3">ifndef</span> <span class="macro" data-ref="_M/_X86_CPU_EXTENDED_STATE_H_">_X86_CPU_EXTENDED_STATE_H_</span></u></td></tr>
<tr><th id="4">4</th><td><u>#define <dfn class="macro" id="_M/_X86_CPU_EXTENDED_STATE_H_" data-ref="_M/_X86_CPU_EXTENDED_STATE_H_">_X86_CPU_EXTENDED_STATE_H_</dfn></u></td></tr>
<tr><th id="5">5</th><td></td></tr>
<tr><th id="6">6</th><td><u>#<span data-ppcond="6">ifdef</span> <span class="macro" data-ref="_M/__lint__">__lint__</span></u></td></tr>
<tr><th id="7">7</th><td><i>/* Lint has different packing rules and doesn't understand __aligned() */</i></td></tr>
<tr><th id="8">8</th><td><u>#define __CTASSERT_NOLINT(x) __CTASSERT(1)</u></td></tr>
<tr><th id="9">9</th><td><u>#<span data-ppcond="6">else</span></u></td></tr>
<tr><th id="10">10</th><td><u>#define <dfn class="macro" id="_M/__CTASSERT_NOLINT" data-ref="_M/__CTASSERT_NOLINT">__CTASSERT_NOLINT</dfn>(x) __CTASSERT(x)</u></td></tr>
<tr><th id="11">11</th><td><u>#<span data-ppcond="6">endif</span></u></td></tr>
<tr><th id="12">12</th><td></td></tr>
<tr><th id="13">13</th><td><i>/*</i></td></tr>
<tr><th id="14">14</th><td><i> * This file contains definitions of structures that match the memory layouts</i></td></tr>
<tr><th id="15">15</th><td><i> * used on x86 processors to save floating point registers and other extended</i></td></tr>
<tr><th id="16">16</th><td><i> * cpu states.</i></td></tr>
<tr><th id="17">17</th><td><i> *</i></td></tr>
<tr><th id="18">18</th><td><i> * This includes registers (etc) used by SSE/SSE2/SSE3/SSSE3/SSE4 and the later</i></td></tr>
<tr><th id="19">19</th><td><i> * AVX instructions.</i></td></tr>
<tr><th id="20">20</th><td><i> *</i></td></tr>
<tr><th id="21">21</th><td><i> * The definitions are such that any future 'extended state' should be handled,</i></td></tr>
<tr><th id="22">22</th><td><i> * provided the kernel doesn't need to know the actual contents.</i></td></tr>
<tr><th id="23">23</th><td><i> *</i></td></tr>
<tr><th id="24">24</th><td><i> * The actual structures the cpu accesses must be aligned to 16 bytes for FXSAVE</i></td></tr>
<tr><th id="25">25</th><td><i> * and 64 for XSAVE. The types aren't aligned because copies do not need extra</i></td></tr>
<tr><th id="26">26</th><td><i> * alignment.</i></td></tr>
<tr><th id="27">27</th><td><i> *</i></td></tr>
<tr><th id="28">28</th><td><i> * The slightly different layout saved by the i387 fsave is also defined.</i></td></tr>
<tr><th id="29">29</th><td><i> * This is only normally written by pre Pentium II type cpus that don't</i></td></tr>
<tr><th id="30">30</th><td><i> * support the fxsave instruction.</i></td></tr>
<tr><th id="31">31</th><td><i> *</i></td></tr>
<tr><th id="32">32</th><td><i> * Associated save instructions:</i></td></tr>
<tr><th id="33">33</th><td><i> * FNSAVE:   Saves x87 state in 108 bytes (original i387 layout). Then</i></td></tr>
<tr><th id="34">34</th><td><i> *           reinitializes the fpu.</i></td></tr>
<tr><th id="35">35</th><td><i> * FSAVE:    Encodes to FWAIT followed by FNSAVE.</i></td></tr>
<tr><th id="36">36</th><td><i> * FXSAVE:   Saves the x87 state and XMM (aka SSE) registers to the first</i></td></tr>
<tr><th id="37">37</th><td><i> *           448 (max) bytes of a 512 byte area. This layout does not match</i></td></tr>
<tr><th id="38">38</th><td><i> *           that written by FNSAVE.</i></td></tr>
<tr><th id="39">39</th><td><i> * XSAVE:    Uses the same layout for the x87 and XMM registers, followed by</i></td></tr>
<tr><th id="40">40</th><td><i> *           a 64byte header and separate save areas for additional extended</i></td></tr>
<tr><th id="41">41</th><td><i> *           cpu states. The x87 state is always saved, the others</i></td></tr>
<tr><th id="42">42</th><td><i> *           conditionally.</i></td></tr>
<tr><th id="43">43</th><td><i> * XSAVEOPT: Same as XSAVE but only writes the registers blocks that have</i></td></tr>
<tr><th id="44">44</th><td><i> *           been modified.</i></td></tr>
<tr><th id="45">45</th><td><i> */</i></td></tr>
<tr><th id="46">46</th><td></td></tr>
<tr><th id="47">47</th><td><i>/*</i></td></tr>
<tr><th id="48">48</th><td><i> * Layout for code/data pointers relating to FP exceptions. Marked 'packed'</i></td></tr>
<tr><th id="49">49</th><td><i> * because they aren't always 64bit aligned. Since the x86 cpu supports</i></td></tr>
<tr><th id="50">50</th><td><i> * misaligned accesses it isn't worth avoiding the 'packed' attribute.</i></td></tr>
<tr><th id="51">51</th><td><i> */</i></td></tr>
<tr><th id="52">52</th><td><b>union</b> <dfn class="type def" id="fp_addr" title='fp_addr' data-ref="fp_addr" data-ref-filename="fp_addr">fp_addr</dfn> {</td></tr>
<tr><th id="53">53</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="fp_addr::fa_64" title='fp_addr::fa_64' data-ref="fp_addr::fa_64" data-ref-filename="fp_addr..fa_64">fa_64</dfn>;	<i>/* Linear address for 64bit systems */</i></td></tr>
<tr><th id="54">54</th><td>	<b>struct</b> {</td></tr>
<tr><th id="55">55</th><td>		<a class="typedef" href="../../../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="fp_addr::(anonymous)::fa_off" title='fp_addr::(anonymous struct)::fa_off' data-ref="fp_addr::(anonymous)::fa_off" data-ref-filename="fp_addr..(anonymous)..fa_off">fa_off</dfn>;	<i>/* linear address for 32 bit */</i></td></tr>
<tr><th id="56">56</th><td>		<a class="typedef" href="../../../sys/stdint.h.html#uint16_t" title='uint16_t' data-type='__uint16_t' data-ref="uint16_t" data-ref-filename="uint16_t">uint16_t</a> <dfn class="decl field" id="fp_addr::(anonymous)::fa_seg" title='fp_addr::(anonymous struct)::fa_seg' data-ref="fp_addr::(anonymous)::fa_seg" data-ref-filename="fp_addr..(anonymous)..fa_seg">fa_seg</dfn>;	<i>/* code/data (etc) segment */</i></td></tr>
<tr><th id="57">57</th><td>		<a class="typedef" href="../../../sys/stdint.h.html#uint16_t" title='uint16_t' data-type='__uint16_t' data-ref="uint16_t" data-ref-filename="uint16_t">uint16_t</a> <dfn class="decl field" id="fp_addr::(anonymous)::fa_opcode" title='fp_addr::(anonymous struct)::fa_opcode' data-ref="fp_addr::(anonymous)::fa_opcode" data-ref-filename="fp_addr..(anonymous)..fa_opcode">fa_opcode</dfn>;	<i>/* last opcode (sometimes) */</i></td></tr>
<tr><th id="58">58</th><td>	} <dfn class="decl field" id="fp_addr::fa_32" title='fp_addr::fa_32' data-ref="fp_addr::fa_32" data-ref-filename="fp_addr..fa_32">fa_32</dfn>;</td></tr>
<tr><th id="59">59</th><td>} <a class="macro" href="../../../sys/cdefs.h.html#391" title="__attribute__((__packed__))" data-ref="_M/__packed">__packed</a> <a class="macro" href="../../../sys/cdefs.h.html#392" title="__attribute__((__aligned__(4)))" data-ref="_M/__aligned">__aligned</a>(<var>4</var>);</td></tr>
<tr><th id="60">60</th><td></td></tr>
<tr><th id="61">61</th><td><i>/* The x87 registers are 80 bits */</i></td></tr>
<tr><th id="62">62</th><td><b>struct</b> <dfn class="type def" id="fpacc87" title='fpacc87' data-ref="fpacc87" data-ref-filename="fpacc87">fpacc87</dfn> {</td></tr>
<tr><th id="63">63</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="fpacc87::f87_mantissa" title='fpacc87::f87_mantissa' data-ref="fpacc87::f87_mantissa" data-ref-filename="fpacc87..f87_mantissa">f87_mantissa</dfn>;	<i>/* mantissa */</i></td></tr>
<tr><th id="64">64</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint16_t" title='uint16_t' data-type='__uint16_t' data-ref="uint16_t" data-ref-filename="uint16_t">uint16_t</a> <dfn class="decl field" id="fpacc87::f87_exp_sign" title='fpacc87::f87_exp_sign' data-ref="fpacc87::f87_exp_sign" data-ref-filename="fpacc87..f87_exp_sign">f87_exp_sign</dfn>;	<i>/* exponent and sign */</i></td></tr>
<tr><th id="65">65</th><td>} <a class="macro" href="../../../sys/cdefs.h.html#391" title="__attribute__((__packed__))" data-ref="_M/__packed">__packed</a> <a class="macro" href="../../../sys/cdefs.h.html#392" title="__attribute__((__aligned__(2)))" data-ref="_M/__aligned">__aligned</a>(<var>2</var>);</td></tr>
<tr><th id="66">66</th><td></td></tr>
<tr><th id="67">67</th><td><i>/* The x87 registers padded out to 16 bytes for fxsave */</i></td></tr>
<tr><th id="68">68</th><td><b>struct</b> <dfn class="type def" id="fpaccfx" title='fpaccfx' data-ref="fpaccfx" data-ref-filename="fpaccfx">fpaccfx</dfn> {</td></tr>
<tr><th id="69">69</th><td>	<b>struct</b> <a class="type" href="#fpacc87" title='fpacc87' data-ref="fpacc87" data-ref-filename="fpacc87">fpacc87</a> <dfn class="decl field" id="fpaccfx::r" title='fpaccfx::r' data-ref="fpaccfx::r" data-ref-filename="fpaccfx..r">r</dfn> <a class="macro" href="../../../sys/cdefs.h.html#392" title="__attribute__((__aligned__(16)))" data-ref="_M/__aligned">__aligned</a>(<var>16</var>);</td></tr>
<tr><th id="70">70</th><td>};</td></tr>
<tr><th id="71">71</th><td></td></tr>
<tr><th id="72">72</th><td><i>/* The SSE/SSE2 registers are 128 bits */</i></td></tr>
<tr><th id="73">73</th><td><b>struct</b> <dfn class="type def" id="xmmreg" title='xmmreg' data-ref="xmmreg" data-ref-filename="xmmreg">xmmreg</dfn> {</td></tr>
<tr><th id="74">74</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="xmmreg::xmm_bytes" title='xmmreg::xmm_bytes' data-ref="xmmreg::xmm_bytes" data-ref-filename="xmmreg..xmm_bytes">xmm_bytes</dfn>[<var>16</var>];</td></tr>
<tr><th id="75">75</th><td>};</td></tr>
<tr><th id="76">76</th><td></td></tr>
<tr><th id="77">77</th><td><i>/* The AVX registers are 256 bits, but the low bits are the xmmregs */</i></td></tr>
<tr><th id="78">78</th><td><b>struct</b> <dfn class="type def" id="ymmreg" title='ymmreg' data-ref="ymmreg" data-ref-filename="ymmreg">ymmreg</dfn> {</td></tr>
<tr><th id="79">79</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="ymmreg::ymm_bytes" title='ymmreg::ymm_bytes' data-ref="ymmreg::ymm_bytes" data-ref-filename="ymmreg..ymm_bytes">ymm_bytes</dfn>[<var>16</var>];</td></tr>
<tr><th id="80">80</th><td>};</td></tr>
<tr><th id="81">81</th><td></td></tr>
<tr><th id="82">82</th><td><i>/* The AVX-512 registers are 512 bits but the low bits are in xmmregs</i></td></tr>
<tr><th id="83">83</th><td><i> * and ymmregs */</i></td></tr>
<tr><th id="84">84</th><td><b>struct</b> <dfn class="type def" id="zmmreg" title='zmmreg' data-ref="zmmreg" data-ref-filename="zmmreg">zmmreg</dfn> {</td></tr>
<tr><th id="85">85</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="zmmreg::zmm_bytes" title='zmmreg::zmm_bytes' data-ref="zmmreg::zmm_bytes" data-ref-filename="zmmreg..zmm_bytes">zmm_bytes</dfn>[<var>32</var>];</td></tr>
<tr><th id="86">86</th><td>};</td></tr>
<tr><th id="87">87</th><td></td></tr>
<tr><th id="88">88</th><td><i>/* 512-bit ZMM register. */</i></td></tr>
<tr><th id="89">89</th><td><b>struct</b> <dfn class="type def" id="hi16_zmmreg" title='hi16_zmmreg' data-ref="hi16_zmmreg" data-ref-filename="hi16_zmmreg">hi16_zmmreg</dfn> {</td></tr>
<tr><th id="90">90</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="hi16_zmmreg::zmm_bytes" title='hi16_zmmreg::zmm_bytes' data-ref="hi16_zmmreg::zmm_bytes" data-ref-filename="hi16_zmmreg..zmm_bytes">zmm_bytes</dfn>[<var>64</var>];</td></tr>
<tr><th id="91">91</th><td>};</td></tr>
<tr><th id="92">92</th><td></td></tr>
<tr><th id="93">93</th><td><i>/*</i></td></tr>
<tr><th id="94">94</th><td><i> * Floating point unit registers (FSAVE instruction).</i></td></tr>
<tr><th id="95">95</th><td><i> *</i></td></tr>
<tr><th id="96">96</th><td><i> * The s87_ac[] and fx_87_ac[] are relative to the stack top. The 'tag word'</i></td></tr>
<tr><th id="97">97</th><td><i> * contains 2 bits per register and refers to absolute register numbers.</i></td></tr>
<tr><th id="98">98</th><td><i> *</i></td></tr>
<tr><th id="99">99</th><td><i> * The cpu sets the tag values 0b01 (zero) and 0b10 (special) when a value</i></td></tr>
<tr><th id="100">100</th><td><i> * is loaded. The software need only set 0b00 (used) and 0xb11 (unused).</i></td></tr>
<tr><th id="101">101</th><td><i> * The fxsave 'Abridged tag word' in inverted.</i></td></tr>
<tr><th id="102">102</th><td><i> */</i></td></tr>
<tr><th id="103">103</th><td><b>struct</b> <dfn class="type def" id="save87" title='save87' data-ref="save87" data-ref-filename="save87">save87</dfn> {</td></tr>
<tr><th id="104">104</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint16_t" title='uint16_t' data-type='__uint16_t' data-ref="uint16_t" data-ref-filename="uint16_t">uint16_t</a> <dfn class="decl field" id="save87::s87_cw" title='save87::s87_cw' data-ref="save87::s87_cw" data-ref-filename="save87..s87_cw">s87_cw</dfn> <a class="macro" href="../../../sys/cdefs.h.html#392" title="__attribute__((__aligned__(4)))" data-ref="_M/__aligned">__aligned</a>(<var>4</var>);	<i>/* control word */</i></td></tr>
<tr><th id="105">105</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint16_t" title='uint16_t' data-type='__uint16_t' data-ref="uint16_t" data-ref-filename="uint16_t">uint16_t</a> <dfn class="decl field" id="save87::s87_sw" title='save87::s87_sw' data-ref="save87::s87_sw" data-ref-filename="save87..s87_sw">s87_sw</dfn> <a class="macro" href="../../../sys/cdefs.h.html#392" title="__attribute__((__aligned__(4)))" data-ref="_M/__aligned">__aligned</a>(<var>4</var>);	<i>/* status word  */</i></td></tr>
<tr><th id="106">106</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint16_t" title='uint16_t' data-type='__uint16_t' data-ref="uint16_t" data-ref-filename="uint16_t">uint16_t</a> <dfn class="decl field" id="save87::s87_tw" title='save87::s87_tw' data-ref="save87::s87_tw" data-ref-filename="save87..s87_tw">s87_tw</dfn> <a class="macro" href="../../../sys/cdefs.h.html#392" title="__attribute__((__aligned__(4)))" data-ref="_M/__aligned">__aligned</a>(<var>4</var>);	<i>/* tag word */</i></td></tr>
<tr><th id="107">107</th><td>	<b>union</b> <a class="type" href="#fp_addr" title='fp_addr' data-ref="fp_addr" data-ref-filename="fp_addr">fp_addr</a> <dfn class="decl field" id="save87::s87_ip" title='save87::s87_ip' data-ref="save87::s87_ip" data-ref-filename="save87..s87_ip">s87_ip</dfn>;		<i>/* floating point instruction pointer */</i></td></tr>
<tr><th id="108">108</th><td><u>#define <dfn class="macro" id="_M/s87_opcode" data-ref="_M/s87_opcode">s87_opcode</dfn> s87_ip.fa_32.fa_opcode	/* opcode last executed (11bits) */</u></td></tr>
<tr><th id="109">109</th><td>	<b>union</b> <a class="type" href="#fp_addr" title='fp_addr' data-ref="fp_addr" data-ref-filename="fp_addr">fp_addr</a> <dfn class="decl field" id="save87::s87_dp" title='save87::s87_dp' data-ref="save87::s87_dp" data-ref-filename="save87..s87_dp">s87_dp</dfn>;		<i>/* floating operand offset */</i></td></tr>
<tr><th id="110">110</th><td>	<b>struct</b> <a class="type" href="#fpacc87" title='fpacc87' data-ref="fpacc87" data-ref-filename="fpacc87">fpacc87</a> <dfn class="decl field" id="save87::s87_ac" title='save87::s87_ac' data-ref="save87::s87_ac" data-ref-filename="save87..s87_ac">s87_ac</dfn>[<var>8</var>];	<i>/* accumulator contents */</i></td></tr>
<tr><th id="111">111</th><td>};</td></tr>
<tr><th id="112">112</th><td><a class="macro" href="#10" title="typedef char __ctassert2[ (sizeof(struct save87) == 108) ? 1 : -1] __attribute__((__unused__))" data-ref="_M/__CTASSERT_NOLINT">__CTASSERT_NOLINT</a>(<b>sizeof</b>(<b>struct</b> <a class="type" href="#save87" title='save87' data-ref="save87" data-ref-filename="save87">save87</a>) == <var>108</var>);</td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td><i>/*</i></td></tr>
<tr><th id="115">115</th><td><i> * FPU/MMX/SSE/SSE2 context (FXSAVE instruction).</i></td></tr>
<tr><th id="116">116</th><td><i> */</i></td></tr>
<tr><th id="117">117</th><td><b>struct</b> <dfn class="type def" id="fxsave" title='fxsave' data-ref="fxsave" data-ref-filename="fxsave">fxsave</dfn> {</td></tr>
<tr><th id="118">118</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint16_t" title='uint16_t' data-type='__uint16_t' data-ref="uint16_t" data-ref-filename="uint16_t">uint16_t</a> <dfn class="decl field" id="fxsave::fx_cw" title='fxsave::fx_cw' data-ref="fxsave::fx_cw" data-ref-filename="fxsave..fx_cw">fx_cw</dfn>;		<i>/* FPU Control Word */</i></td></tr>
<tr><th id="119">119</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint16_t" title='uint16_t' data-type='__uint16_t' data-ref="uint16_t" data-ref-filename="uint16_t">uint16_t</a> <dfn class="decl field" id="fxsave::fx_sw" title='fxsave::fx_sw' data-ref="fxsave::fx_sw" data-ref-filename="fxsave..fx_sw">fx_sw</dfn>;		<i>/* FPU Status Word */</i></td></tr>
<tr><th id="120">120</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="fxsave::fx_tw" title='fxsave::fx_tw' data-ref="fxsave::fx_tw" data-ref-filename="fxsave..fx_tw">fx_tw</dfn>;		<i>/* FPU Tag Word (abridged) */</i></td></tr>
<tr><th id="121">121</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="fxsave::fx_zero" title='fxsave::fx_zero' data-ref="fxsave::fx_zero" data-ref-filename="fxsave..fx_zero">fx_zero</dfn>;	<i>/* zero */</i></td></tr>
<tr><th id="122">122</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint16_t" title='uint16_t' data-type='__uint16_t' data-ref="uint16_t" data-ref-filename="uint16_t">uint16_t</a> <dfn class="decl field" id="fxsave::fx_opcode" title='fxsave::fx_opcode' data-ref="fxsave::fx_opcode" data-ref-filename="fxsave..fx_opcode">fx_opcode</dfn>;	<i>/* FPU Opcode */</i></td></tr>
<tr><th id="123">123</th><td>	<b>union</b> <a class="type" href="#fp_addr" title='fp_addr' data-ref="fp_addr" data-ref-filename="fp_addr">fp_addr</a> <dfn class="decl field" id="fxsave::fx_ip" title='fxsave::fx_ip' data-ref="fxsave::fx_ip" data-ref-filename="fxsave..fx_ip">fx_ip</dfn>;	<i>/* FPU Instruction Pointer */</i></td></tr>
<tr><th id="124">124</th><td>	<b>union</b> <a class="type" href="#fp_addr" title='fp_addr' data-ref="fp_addr" data-ref-filename="fp_addr">fp_addr</a> <dfn class="decl field" id="fxsave::fx_dp" title='fxsave::fx_dp' data-ref="fxsave::fx_dp" data-ref-filename="fxsave..fx_dp">fx_dp</dfn>;	<i>/* FPU Data pointer */</i></td></tr>
<tr><th id="125">125</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="fxsave::fx_mxcsr" title='fxsave::fx_mxcsr' data-ref="fxsave::fx_mxcsr" data-ref-filename="fxsave..fx_mxcsr">fx_mxcsr</dfn>;	<i>/* MXCSR Register State */</i></td></tr>
<tr><th id="126">126</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a> <dfn class="decl field" id="fxsave::fx_mxcsr_mask" title='fxsave::fx_mxcsr_mask' data-ref="fxsave::fx_mxcsr_mask" data-ref-filename="fxsave..fx_mxcsr_mask">fx_mxcsr_mask</dfn>;</td></tr>
<tr><th id="127">127</th><td>	<b>struct</b> <a class="type" href="#fpaccfx" title='fpaccfx' data-ref="fpaccfx" data-ref-filename="fpaccfx">fpaccfx</a> <dfn class="decl field" id="fxsave::fx_87_ac" title='fxsave::fx_87_ac' data-ref="fxsave::fx_87_ac" data-ref-filename="fxsave..fx_87_ac">fx_87_ac</dfn>[<var>8</var>];	<i>/* 8 x87 registers */</i></td></tr>
<tr><th id="128">128</th><td>	<b>struct</b> <a class="type" href="#xmmreg" title='xmmreg' data-ref="xmmreg" data-ref-filename="xmmreg">xmmreg</a> <dfn class="decl field" id="fxsave::fx_xmm" title='fxsave::fx_xmm' data-ref="fxsave::fx_xmm" data-ref-filename="fxsave..fx_xmm">fx_xmm</dfn>[<var>16</var>];	<i>/* XMM regs (8 in 32bit modes) */</i></td></tr>
<tr><th id="129">129</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="fxsave::fx_rsvd" title='fxsave::fx_rsvd' data-ref="fxsave::fx_rsvd" data-ref-filename="fxsave..fx_rsvd">fx_rsvd</dfn>[<var>96</var>];</td></tr>
<tr><th id="130">130</th><td>} <a class="macro" href="../../../sys/cdefs.h.html#392" title="__attribute__((__aligned__(16)))" data-ref="_M/__aligned">__aligned</a>(<var>16</var>);</td></tr>
<tr><th id="131">131</th><td><a class="macro" href="#10" title="typedef char __ctassert4[ (sizeof(struct fxsave) == 512) ? 1 : -1] __attribute__((__unused__))" data-ref="_M/__CTASSERT_NOLINT">__CTASSERT_NOLINT</a>(<b>sizeof</b>(<b>struct</b> <a class="type" href="#fxsave" title='fxsave' data-ref="fxsave" data-ref-filename="fxsave">fxsave</a>) == <var>512</var>);</td></tr>
<tr><th id="132">132</th><td></td></tr>
<tr><th id="133">133</th><td><i>/*</i></td></tr>
<tr><th id="134">134</th><td><i> * For XSAVE, a 64byte header follows the fxsave data.</i></td></tr>
<tr><th id="135">135</th><td><i> */</i></td></tr>
<tr><th id="136">136</th><td><b>struct</b> <dfn class="type def" id="xsave_header" title='xsave_header' data-ref="xsave_header" data-ref-filename="xsave_header">xsave_header</dfn> {</td></tr>
<tr><th id="137">137</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="xsave_header::xsh_fxsave" title='xsave_header::xsh_fxsave' data-ref="xsave_header::xsh_fxsave" data-ref-filename="xsave_header..xsh_fxsave">xsh_fxsave</dfn>[<var>512</var>];	<i>/* struct fxsave */</i></td></tr>
<tr><th id="138">138</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="xsave_header::xsh_xstate_bv" title='xsave_header::xsh_xstate_bv' data-ref="xsave_header::xsh_xstate_bv" data-ref-filename="xsave_header..xsh_xstate_bv">xsh_xstate_bv</dfn>;		<i>/* bitmap of saved sub structures */</i></td></tr>
<tr><th id="139">139</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="xsave_header::xsh_xcomp_bv" title='xsave_header::xsh_xcomp_bv' data-ref="xsave_header::xsh_xcomp_bv" data-ref-filename="xsave_header..xsh_xcomp_bv">xsh_xcomp_bv</dfn>;		<i>/* bitmap of compact sub structures */</i></td></tr>
<tr><th id="140">140</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="xsave_header::xsh_rsrvd" title='xsave_header::xsh_rsrvd' data-ref="xsave_header::xsh_rsrvd" data-ref-filename="xsave_header..xsh_rsrvd">xsh_rsrvd</dfn>[<var>8</var>];		<i>/* must be zero */</i></td></tr>
<tr><th id="141">141</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint8_t" title='uint8_t' data-type='__uint8_t' data-ref="uint8_t" data-ref-filename="uint8_t">uint8_t</a> <dfn class="decl field" id="xsave_header::xsh_reserved" title='xsave_header::xsh_reserved' data-ref="xsave_header::xsh_reserved" data-ref-filename="xsave_header..xsh_reserved">xsh_reserved</dfn>[<var>40</var>];	<i>/* best if zero */</i></td></tr>
<tr><th id="142">142</th><td>};</td></tr>
<tr><th id="143">143</th><td><a class="macro" href="../../../sys/cdefs.h.html#151" title="typedef char __ctassert6[ (sizeof(struct xsave_header) == 512 + 64) ? 1 : -1] __attribute__((__unused__))" data-ref="_M/__CTASSERT">__CTASSERT</a>(<b>sizeof</b>(<b>struct</b> <a class="type" href="#xsave_header" title='xsave_header' data-ref="xsave_header" data-ref-filename="xsave_header">xsave_header</a>) == <var>512</var> + <var>64</var>);</td></tr>
<tr><th id="144">144</th><td></td></tr>
<tr><th id="145">145</th><td><i>/*</i></td></tr>
<tr><th id="146">146</th><td><i> * The ymm save area actually follows the xsave_header.</i></td></tr>
<tr><th id="147">147</th><td><i> */</i></td></tr>
<tr><th id="148">148</th><td><b>struct</b> <dfn class="type def" id="xsave_ymm" title='xsave_ymm' data-ref="xsave_ymm" data-ref-filename="xsave_ymm">xsave_ymm</dfn> {</td></tr>
<tr><th id="149">149</th><td>	<b>struct</b> <a class="type" href="#ymmreg" title='ymmreg' data-ref="ymmreg" data-ref-filename="ymmreg">ymmreg</a> <dfn class="decl field" id="xsave_ymm::xs_ymm" title='xsave_ymm::xs_ymm' data-ref="xsave_ymm::xs_ymm" data-ref-filename="xsave_ymm..xs_ymm">xs_ymm</dfn>[<var>16</var>];	<i>/* High bits of YMM registers */</i></td></tr>
<tr><th id="150">150</th><td>};</td></tr>
<tr><th id="151">151</th><td><a class="macro" href="../../../sys/cdefs.h.html#151" title="typedef char __ctassert8[ (sizeof(struct xsave_ymm) == 256) ? 1 : -1] __attribute__((__unused__))" data-ref="_M/__CTASSERT">__CTASSERT</a>(<b>sizeof</b>(<b>struct</b> <a class="type" href="#xsave_ymm" title='xsave_ymm' data-ref="xsave_ymm" data-ref-filename="xsave_ymm">xsave_ymm</a>) == <var>256</var>);</td></tr>
<tr><th id="152">152</th><td></td></tr>
<tr><th id="153">153</th><td><i>/*</i></td></tr>
<tr><th id="154">154</th><td><i> * AVX-512: opmask state.</i></td></tr>
<tr><th id="155">155</th><td><i> */</i></td></tr>
<tr><th id="156">156</th><td><b>struct</b> <dfn class="type def" id="xsave_opmask" title='xsave_opmask' data-ref="xsave_opmask" data-ref-filename="xsave_opmask">xsave_opmask</dfn> {</td></tr>
<tr><th id="157">157</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="xsave_opmask::xs_k" title='xsave_opmask::xs_k' data-ref="xsave_opmask::xs_k" data-ref-filename="xsave_opmask..xs_k">xs_k</dfn>[<var>8</var>];			<i>/* k0..k7 registers. */</i></td></tr>
<tr><th id="158">158</th><td>};</td></tr>
<tr><th id="159">159</th><td><a class="macro" href="../../../sys/cdefs.h.html#151" title="typedef char __ctassert10[ (sizeof(struct xsave_opmask) == 64) ? 1 : -1] __attribute__((__unused__))" data-ref="_M/__CTASSERT">__CTASSERT</a>(<b>sizeof</b>(<b>struct</b> <a class="type" href="#xsave_opmask" title='xsave_opmask' data-ref="xsave_opmask" data-ref-filename="xsave_opmask">xsave_opmask</a>) == <var>64</var>);</td></tr>
<tr><th id="160">160</th><td></td></tr>
<tr><th id="161">161</th><td><i>/*</i></td></tr>
<tr><th id="162">162</th><td><i> * AVX-512: ZMM_Hi256 state.</i></td></tr>
<tr><th id="163">163</th><td><i> */</i></td></tr>
<tr><th id="164">164</th><td><b>struct</b> <dfn class="type def" id="xsave_zmm_hi256" title='xsave_zmm_hi256' data-ref="xsave_zmm_hi256" data-ref-filename="xsave_zmm_hi256">xsave_zmm_hi256</dfn> {</td></tr>
<tr><th id="165">165</th><td>	<b>struct</b> <a class="type" href="#zmmreg" title='zmmreg' data-ref="zmmreg" data-ref-filename="zmmreg">zmmreg</a> <dfn class="decl field" id="xsave_zmm_hi256::xs_zmm" title='xsave_zmm_hi256::xs_zmm' data-ref="xsave_zmm_hi256::xs_zmm" data-ref-filename="xsave_zmm_hi256..xs_zmm">xs_zmm</dfn>[<var>16</var>];	<i>/* High bits of zmm0..zmm15 registers. */</i></td></tr>
<tr><th id="166">166</th><td>};</td></tr>
<tr><th id="167">167</th><td><a class="macro" href="../../../sys/cdefs.h.html#151" title="typedef char __ctassert12[ (sizeof(struct xsave_zmm_hi256) == 512) ? 1 : -1] __attribute__((__unused__))" data-ref="_M/__CTASSERT">__CTASSERT</a>(<b>sizeof</b>(<b>struct</b> <a class="type" href="#xsave_zmm_hi256" title='xsave_zmm_hi256' data-ref="xsave_zmm_hi256" data-ref-filename="xsave_zmm_hi256">xsave_zmm_hi256</a>) == <var>512</var>);</td></tr>
<tr><th id="168">168</th><td></td></tr>
<tr><th id="169">169</th><td><i>/*</i></td></tr>
<tr><th id="170">170</th><td><i> * AVX-512: Hi16_ZMM state.</i></td></tr>
<tr><th id="171">171</th><td><i> */</i></td></tr>
<tr><th id="172">172</th><td><b>struct</b> <dfn class="type def" id="xsave_hi16_zmm" title='xsave_hi16_zmm' data-ref="xsave_hi16_zmm" data-ref-filename="xsave_hi16_zmm">xsave_hi16_zmm</dfn> {</td></tr>
<tr><th id="173">173</th><td>	<b>struct</b> <a class="type" href="#hi16_zmmreg" title='hi16_zmmreg' data-ref="hi16_zmmreg" data-ref-filename="hi16_zmmreg">hi16_zmmreg</a> <dfn class="decl field" id="xsave_hi16_zmm::xs_hi16_zmm" title='xsave_hi16_zmm::xs_hi16_zmm' data-ref="xsave_hi16_zmm::xs_hi16_zmm" data-ref-filename="xsave_hi16_zmm..xs_hi16_zmm">xs_hi16_zmm</dfn>[<var>16</var>];	<i>/* zmm16..zmm31 registers. */</i></td></tr>
<tr><th id="174">174</th><td>};</td></tr>
<tr><th id="175">175</th><td><a class="macro" href="../../../sys/cdefs.h.html#151" title="typedef char __ctassert14[ (sizeof(struct xsave_hi16_zmm) == 1024) ? 1 : -1] __attribute__((__unused__))" data-ref="_M/__CTASSERT">__CTASSERT</a>(<b>sizeof</b>(<b>struct</b> <a class="type" href="#xsave_hi16_zmm" title='xsave_hi16_zmm' data-ref="xsave_hi16_zmm" data-ref-filename="xsave_hi16_zmm">xsave_hi16_zmm</a>) == <var>1024</var>);</td></tr>
<tr><th id="176">176</th><td></td></tr>
<tr><th id="177">177</th><td><i>/*</i></td></tr>
<tr><th id="178">178</th><td><i> * Structure used to hold all interesting data from XSAVE, in predictable form.</i></td></tr>
<tr><th id="179">179</th><td><i> * Note that this structure can have new members added to the end.</i></td></tr>
<tr><th id="180">180</th><td><i> */</i></td></tr>
<tr><th id="181">181</th><td><b>struct</b> <dfn class="type def" id="xstate" title='xstate' data-ref="xstate" data-ref-filename="xstate">xstate</dfn> {</td></tr>
<tr><th id="182">182</th><td>	<i>/*</i></td></tr>
<tr><th id="183">183</th><td><i>	 * The two following fields are bitmaps of XSAVE components.  They can be</i></td></tr>
<tr><th id="184">184</th><td><i>	 * matched against XCR0_* constants from &lt;machine/specialreg.h&gt;).</i></td></tr>
<tr><th id="185">185</th><td><i>	 */</i></td></tr>
<tr><th id="186">186</th><td>	<i>/*</i></td></tr>
<tr><th id="187">187</th><td><i>	 * XSAVE/XRSTOR RFBM parameter.</i></td></tr>
<tr><th id="188">188</th><td><i>	 *</i></td></tr>
<tr><th id="189">189</th><td><i>	 * PT_GETXSTATE: 1 indicates that the respective XSAVE component is</i></td></tr>
<tr><th id="190">190</th><td><i>	 * supported and has been enabled for saving.  0 indicates that it is not</i></td></tr>
<tr><th id="191">191</th><td><i>	 * supported by the platform or kernel.</i></td></tr>
<tr><th id="192">192</th><td><i>	 *</i></td></tr>
<tr><th id="193">193</th><td><i>	 * PT_SETXSTATE: 1 indicates that the respective XSAVE component should</i></td></tr>
<tr><th id="194">194</th><td><i>	 * be updated to the value of respective field (or reset if xs_xsave_bv</i></td></tr>
<tr><th id="195">195</th><td><i>	 * bit is 0).  0 indicates that it should be left intact.  It is an error</i></td></tr>
<tr><th id="196">196</th><td><i>	 * to enable bits that are not supported by the platform or kernel.</i></td></tr>
<tr><th id="197">197</th><td><i>	 */</i></td></tr>
<tr><th id="198">198</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="xstate::xs_rfbm" title='xstate::xs_rfbm' data-ref="xstate::xs_rfbm" data-ref-filename="xstate..xs_rfbm">xs_rfbm</dfn>;</td></tr>
<tr><th id="199">199</th><td>	<i>/*</i></td></tr>
<tr><th id="200">200</th><td><i>	 * XSAVE/XRSTOR xstate header.</i></td></tr>
<tr><th id="201">201</th><td><i>	 *</i></td></tr>
<tr><th id="202">202</th><td><i>	 * PT_GETXSTATE: 1 indicates that the respective XSAVE component has been</i></td></tr>
<tr><th id="203">203</th><td><i>	 * saved.  0 indicates that it had been in its CPU-defined initial value</i></td></tr>
<tr><th id="204">204</th><td><i>	 * at the time of saving (i.e. was not used by the program).</i></td></tr>
<tr><th id="205">205</th><td><i>	 *</i></td></tr>
<tr><th id="206">206</th><td><i>	 * PT_SETXSTATE: 1 indicates that the respective XSAVE component (if present</i></td></tr>
<tr><th id="207">207</th><td><i>	 * in xs_rfbm) should be set to the values in respective field.  0 indicates</i></td></tr>
<tr><th id="208">208</th><td><i>	 * that it should be reset to CPU-defined initial value.</i></td></tr>
<tr><th id="209">209</th><td><i>	 */</i></td></tr>
<tr><th id="210">210</th><td>	<a class="typedef" href="../../../sys/stdint.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a> <dfn class="decl field" id="xstate::xs_xstate_bv" title='xstate::xs_xstate_bv' data-ref="xstate::xs_xstate_bv" data-ref-filename="xstate..xs_xstate_bv">xs_xstate_bv</dfn>;</td></tr>
<tr><th id="211">211</th><td></td></tr>
<tr><th id="212">212</th><td>	<i>/* legacy FXSAVE area (used for x87 &amp; SSE state) */</i></td></tr>
<tr><th id="213">213</th><td>	<b>struct</b> <a class="type" href="#fxsave" title='fxsave' data-ref="fxsave" data-ref-filename="fxsave">fxsave</a> <dfn class="decl field" id="xstate::xs_fxsave" title='xstate::xs_fxsave' data-ref="xstate::xs_fxsave" data-ref-filename="xstate..xs_fxsave">xs_fxsave</dfn>;</td></tr>
<tr><th id="214">214</th><td>	<i>/* AVX state: high bits of ymm0..ymm15 registers */</i></td></tr>
<tr><th id="215">215</th><td>	<b>struct</b> <a class="type" href="#xsave_ymm" title='xsave_ymm' data-ref="xsave_ymm" data-ref-filename="xsave_ymm">xsave_ymm</a> <dfn class="decl field" id="xstate::xs_ymm_hi128" title='xstate::xs_ymm_hi128' data-ref="xstate::xs_ymm_hi128" data-ref-filename="xstate..xs_ymm_hi128">xs_ymm_hi128</dfn>;</td></tr>
<tr><th id="216">216</th><td>	<i>/* AVX-512: opmask */</i></td></tr>
<tr><th id="217">217</th><td>	<b>struct</b> <a class="type" href="#xsave_opmask" title='xsave_opmask' data-ref="xsave_opmask" data-ref-filename="xsave_opmask">xsave_opmask</a> <dfn class="decl field" id="xstate::xs_opmask" title='xstate::xs_opmask' data-ref="xstate::xs_opmask" data-ref-filename="xstate..xs_opmask">xs_opmask</dfn>;</td></tr>
<tr><th id="218">218</th><td>	<i>/* AVX-512: high bits of zmm0..zmm15 registers */</i></td></tr>
<tr><th id="219">219</th><td>	<b>struct</b> <a class="type" href="#xsave_zmm_hi256" title='xsave_zmm_hi256' data-ref="xsave_zmm_hi256" data-ref-filename="xsave_zmm_hi256">xsave_zmm_hi256</a> <dfn class="decl field" id="xstate::xs_zmm_hi256" title='xstate::xs_zmm_hi256' data-ref="xstate::xs_zmm_hi256" data-ref-filename="xstate..xs_zmm_hi256">xs_zmm_hi256</dfn>;</td></tr>
<tr><th id="220">220</th><td>	<i>/* AVX-512: whole zmm16..zmm31 registers */</i></td></tr>
<tr><th id="221">221</th><td>	<b>struct</b> <a class="type" href="#xsave_hi16_zmm" title='xsave_hi16_zmm' data-ref="xsave_hi16_zmm" data-ref-filename="xsave_hi16_zmm">xsave_hi16_zmm</a> <dfn class="decl field" id="xstate::xs_hi16_zmm" title='xstate::xs_hi16_zmm' data-ref="xstate::xs_hi16_zmm" data-ref-filename="xstate..xs_hi16_zmm">xs_hi16_zmm</dfn>;</td></tr>
<tr><th id="222">222</th><td>};</td></tr>
<tr><th id="223">223</th><td></td></tr>
<tr><th id="224">224</th><td><i>/*</i></td></tr>
<tr><th id="225">225</th><td><i> * The following union is placed at the end of the pcb.</i></td></tr>
<tr><th id="226">226</th><td><i> * It is defined this way to separate the definitions and to</i></td></tr>
<tr><th id="227">227</th><td><i> * minimise the number of union/struct selectors.</i></td></tr>
<tr><th id="228">228</th><td><i> * NB: Some userspace stuff (eg firefox) uses it to parse ucontext.</i></td></tr>
<tr><th id="229">229</th><td><i> */</i></td></tr>
<tr><th id="230">230</th><td><b>union</b> <dfn class="type def" id="savefpu" title='savefpu' data-ref="savefpu" data-ref-filename="savefpu">savefpu</dfn> {</td></tr>
<tr><th id="231">231</th><td>	<b>struct</b> <a class="type" href="#save87" title='save87' data-ref="save87" data-ref-filename="save87">save87</a> <dfn class="decl field" id="savefpu::sv_87" title='savefpu::sv_87' data-ref="savefpu::sv_87" data-ref-filename="savefpu..sv_87">sv_87</dfn>;</td></tr>
<tr><th id="232">232</th><td>	<b>struct</b> <a class="type" href="#fxsave" title='fxsave' data-ref="fxsave" data-ref-filename="fxsave">fxsave</a> <dfn class="decl field" id="savefpu::sv_xmm" title='savefpu::sv_xmm' data-ref="savefpu::sv_xmm" data-ref-filename="savefpu..sv_xmm">sv_xmm</dfn>;</td></tr>
<tr><th id="233">233</th><td><u>#<span data-ppcond="233">ifdef</span> <a class="macro" href="../../../rump/include/opt/opt_rumpkernel.h.html#7" data-ref="_M/_KERNEL">_KERNEL</a></u></td></tr>
<tr><th id="234">234</th><td>	<b>struct</b> <a class="type" href="#xsave_header" title='xsave_header' data-ref="xsave_header" data-ref-filename="xsave_header">xsave_header</a> <dfn class="decl field" id="savefpu::sv_xsave_hdr" title='savefpu::sv_xsave_hdr' data-ref="savefpu::sv_xsave_hdr" data-ref-filename="savefpu..sv_xsave_hdr">sv_xsave_hdr</dfn>;</td></tr>
<tr><th id="235">235</th><td><u>#<span data-ppcond="233">endif</span></u></td></tr>
<tr><th id="236">236</th><td>};</td></tr>
<tr><th id="237">237</th><td></td></tr>
<tr><th id="238">238</th><td><i>/*</i></td></tr>
<tr><th id="239">239</th><td><i> * 80387 control and status word bits</i></td></tr>
<tr><th id="240">240</th><td><i> *</i></td></tr>
<tr><th id="241">241</th><td><i> * The only reference I can find to bits 0x40 and 0x80 in the control word</i></td></tr>
<tr><th id="242">242</th><td><i> * is for the Weitek 1167/3167.</i></td></tr>
<tr><th id="243">243</th><td><i> * I (dsl) can't find why the default word has 0x40 set.</i></td></tr>
<tr><th id="244">244</th><td><i> *</i></td></tr>
<tr><th id="245">245</th><td><i> * A stack error is signalled as an INVOP that also sets STACK_FAULT</i></td></tr>
<tr><th id="246">246</th><td><i> * (other INVOP do not clear STACK_FAULT).</i></td></tr>
<tr><th id="247">247</th><td><i> */</i></td></tr>
<tr><th id="248">248</th><td><i>/* Interrupt masks (set masks interrupt) and status bits */</i></td></tr>
<tr><th id="249">249</th><td><u>#define <dfn class="macro" id="_M/EN_SW_INVOP" data-ref="_M/EN_SW_INVOP">EN_SW_INVOP</dfn>		0x0001  /* Invalid operation */</u></td></tr>
<tr><th id="250">250</th><td><u>#define <dfn class="macro" id="_M/EN_SW_DENORM" data-ref="_M/EN_SW_DENORM">EN_SW_DENORM</dfn>		0x0002  /* Denormalized operand */</u></td></tr>
<tr><th id="251">251</th><td><u>#define <dfn class="macro" id="_M/EN_SW_ZERODIV" data-ref="_M/EN_SW_ZERODIV">EN_SW_ZERODIV</dfn>		0x0004  /* Divide by zero */</u></td></tr>
<tr><th id="252">252</th><td><u>#define <dfn class="macro" id="_M/EN_SW_OVERFLOW" data-ref="_M/EN_SW_OVERFLOW">EN_SW_OVERFLOW</dfn>		0x0008  /* Overflow */</u></td></tr>
<tr><th id="253">253</th><td><u>#define <dfn class="macro" id="_M/EN_SW_UNDERFLOW" data-ref="_M/EN_SW_UNDERFLOW">EN_SW_UNDERFLOW</dfn>		0x0010  /* Underflow */</u></td></tr>
<tr><th id="254">254</th><td><u>#define <dfn class="macro" id="_M/EN_SW_PRECLOSS" data-ref="_M/EN_SW_PRECLOSS">EN_SW_PRECLOSS</dfn>		0x0020  /* Loss of precision */</u></td></tr>
<tr><th id="255">255</th><td><i>/* Status word bits (reserved in control word) */</i></td></tr>
<tr><th id="256">256</th><td><u>#define <dfn class="macro" id="_M/EN_SW_STACK_FAULT" data-ref="_M/EN_SW_STACK_FAULT">EN_SW_STACK_FAULT</dfn>	0x0040	/* Stack under/overflow */</u></td></tr>
<tr><th id="257">257</th><td><u>#define <dfn class="macro" id="_M/EN_SW_ERROR_SUMMARY" data-ref="_M/EN_SW_ERROR_SUMMARY">EN_SW_ERROR_SUMMARY</dfn>	0x0080	/* Unmasked error has occurred */</u></td></tr>
<tr><th id="258">258</th><td><i>/* Control bits (badly named) */</i></td></tr>
<tr><th id="259">259</th><td><u>#define <dfn class="macro" id="_M/EN_SW_CTL_PREC" data-ref="_M/EN_SW_CTL_PREC">EN_SW_CTL_PREC</dfn>		0x0300	/* Precision control */</u></td></tr>
<tr><th id="260">260</th><td><u>#define <dfn class="macro" id="_M/EN_SW_PREC_24" data-ref="_M/EN_SW_PREC_24">EN_SW_PREC_24</dfn>		0x0000	/* Single precision */</u></td></tr>
<tr><th id="261">261</th><td><u>#define <dfn class="macro" id="_M/EN_SW_PREC_53" data-ref="_M/EN_SW_PREC_53">EN_SW_PREC_53</dfn>		0x0200	/* Double precision */</u></td></tr>
<tr><th id="262">262</th><td><u>#define <dfn class="macro" id="_M/EN_SW_PREC_64" data-ref="_M/EN_SW_PREC_64">EN_SW_PREC_64</dfn>		0x0300	/* Extended precision */</u></td></tr>
<tr><th id="263">263</th><td><u>#define <dfn class="macro" id="_M/EN_SW_CTL_ROUND" data-ref="_M/EN_SW_CTL_ROUND">EN_SW_CTL_ROUND</dfn>		0x0c00	/* Rounding control */</u></td></tr>
<tr><th id="264">264</th><td><u>#define <dfn class="macro" id="_M/EN_SW_ROUND_EVEN" data-ref="_M/EN_SW_ROUND_EVEN">EN_SW_ROUND_EVEN</dfn>	0x0000	/* Round to nearest even */</u></td></tr>
<tr><th id="265">265</th><td><u>#define <dfn class="macro" id="_M/EN_SW_ROUND_DOWN" data-ref="_M/EN_SW_ROUND_DOWN">EN_SW_ROUND_DOWN</dfn>	0x0400	/* Round towards minus infinity */</u></td></tr>
<tr><th id="266">266</th><td><u>#define <dfn class="macro" id="_M/EN_SW_ROUND_UP" data-ref="_M/EN_SW_ROUND_UP">EN_SW_ROUND_UP</dfn>		0x0800	/* Round towards plus infinity */</u></td></tr>
<tr><th id="267">267</th><td><u>#define <dfn class="macro" id="_M/EN_SW_ROUND_ZERO" data-ref="_M/EN_SW_ROUND_ZERO">EN_SW_ROUND_ZERO</dfn>	0x0c00	/* Round towards zero (truncates) */</u></td></tr>
<tr><th id="268">268</th><td><u>#define <dfn class="macro" id="_M/EN_SW_CTL_INF" data-ref="_M/EN_SW_CTL_INF">EN_SW_CTL_INF</dfn>		0x1000	/* Infinity control, not used  */</u></td></tr>
<tr><th id="269">269</th><td></td></tr>
<tr><th id="270">270</th><td><i>/*</i></td></tr>
<tr><th id="271">271</th><td><i> * The standard 0x87 control word from finit is 0x37F, giving:</i></td></tr>
<tr><th id="272">272</th><td><i> *	round to nearest</i></td></tr>
<tr><th id="273">273</th><td><i> *	64-bit precision</i></td></tr>
<tr><th id="274">274</th><td><i> *	all exceptions masked.</i></td></tr>
<tr><th id="275">275</th><td><i> *</i></td></tr>
<tr><th id="276">276</th><td><i> * NetBSD used to select:</i></td></tr>
<tr><th id="277">277</th><td><i> *	round to nearest</i></td></tr>
<tr><th id="278">278</th><td><i> *	53-bit precision</i></td></tr>
<tr><th id="279">279</th><td><i> *	all exceptions masked.</i></td></tr>
<tr><th id="280">280</th><td><i> * Stating: 64-bit precision often gives bad results with high level</i></td></tr>
<tr><th id="281">281</th><td><i> * languages because it makes the results of calculations depend on whether</i></td></tr>
<tr><th id="282">282</th><td><i> * intermediate values are stored in memory or in FPU registers.</i></td></tr>
<tr><th id="283">283</th><td><i> * Also some 'pathological divisions' give an error in the LSB because</i></td></tr>
<tr><th id="284">284</th><td><i> * the value is first rounded up when the 64bit mantissa is generated,</i></td></tr>
<tr><th id="285">285</th><td><i> * and then again when it is truncated to 53 bits.</i></td></tr>
<tr><th id="286">286</th><td><i> *</i></td></tr>
<tr><th id="287">287</th><td><i> * However the C language explicitly allows the extra precision.</i></td></tr>
<tr><th id="288">288</th><td><i> */</i></td></tr>
<tr><th id="289">289</th><td><u>#define	<dfn class="macro" id="_M/__INITIAL_NPXCW__" data-ref="_M/__INITIAL_NPXCW__">__INITIAL_NPXCW__</dfn>	0x037f</u></td></tr>
<tr><th id="290">290</th><td><i>/* Modern NetBSD uses the default control word.. */</i></td></tr>
<tr><th id="291">291</th><td><u>#define	<dfn class="macro" id="_M/__NetBSD_NPXCW__" data-ref="_M/__NetBSD_NPXCW__">__NetBSD_NPXCW__</dfn>	__INITIAL_NPXCW__</u></td></tr>
<tr><th id="292">292</th><td><i>/* NetBSD before 6.99.26 forced IEEE double precision. */</i></td></tr>
<tr><th id="293">293</th><td><u>#define	<dfn class="macro" id="_M/__NetBSD_COMPAT_NPXCW__" data-ref="_M/__NetBSD_COMPAT_NPXCW__">__NetBSD_COMPAT_NPXCW__</dfn>	0x127f</u></td></tr>
<tr><th id="294">294</th><td><i>/* FreeBSD leaves some exceptions unmasked as well. */</i></td></tr>
<tr><th id="295">295</th><td><u>#define	<dfn class="macro" id="_M/__FreeBSD_NPXCW__" data-ref="_M/__FreeBSD_NPXCW__">__FreeBSD_NPXCW__</dfn>	0x1272</u></td></tr>
<tr><th id="296">296</th><td><i>/* Linux just uses the default control word. */</i></td></tr>
<tr><th id="297">297</th><td><u>#define	<dfn class="macro" id="_M/__Linux_NPXCW__" data-ref="_M/__Linux_NPXCW__">__Linux_NPXCW__</dfn>		__INITIAL_NPXCW__</u></td></tr>
<tr><th id="298">298</th><td></td></tr>
<tr><th id="299">299</th><td><i>/*</i></td></tr>
<tr><th id="300">300</th><td><i> * The default MXCSR value at reset is 0x1f80, IA-32 Instruction</i></td></tr>
<tr><th id="301">301</th><td><i> * Set Reference, pg. 3-369.</i></td></tr>
<tr><th id="302">302</th><td><i> *</i></td></tr>
<tr><th id="303">303</th><td><i> * The low 6 bits of the mxcsr are the fp status bits (same order as x87).</i></td></tr>
<tr><th id="304">304</th><td><i> * Bit 6 is 'denormals are zero' (speeds up calculations).</i></td></tr>
<tr><th id="305">305</th><td><i> * Bits 7-16 are the interrupt mask bits (same order, 1 to mask).</i></td></tr>
<tr><th id="306">306</th><td><i> * Bits 13 and 14 are rounding control.</i></td></tr>
<tr><th id="307">307</th><td><i> * Bit 15 is 'flush to zero' - affects underflow.</i></td></tr>
<tr><th id="308">308</th><td><i> * Bits 16-31 must be zero.</i></td></tr>
<tr><th id="309">309</th><td><i> */</i></td></tr>
<tr><th id="310">310</th><td><u>#define	<dfn class="macro" id="_M/__INITIAL_MXCSR__" data-ref="_M/__INITIAL_MXCSR__">__INITIAL_MXCSR__</dfn>	0x1f80</u></td></tr>
<tr><th id="311">311</th><td><u>#define	<dfn class="macro" id="_M/__INITIAL_MXCSR_MASK__" data-ref="_M/__INITIAL_MXCSR_MASK__">__INITIAL_MXCSR_MASK__</dfn>	0xffbf</u></td></tr>
<tr><th id="312">312</th><td></td></tr>
<tr><th id="313">313</th><td><u>#<span data-ppcond="3">endif</span> /* _X86_CPU_EXTENDED_STATE_H_ */</u></td></tr>
<tr><th id="314">314</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../../../common/lib/libutil/proc_compare.c.html'>netbsd/common/lib/libutil/proc_compare.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
