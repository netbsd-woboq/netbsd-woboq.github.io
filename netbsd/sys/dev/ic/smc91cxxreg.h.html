<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>smc91cxxreg.h source code [netbsd/sys/dev/ic/smc91cxxreg.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/sys/dev/ic/smc91cxxreg.h'; var root_path = '../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../..'>netbsd</a>/<a href='../..'>sys</a>/<a href='..'>dev</a>/<a href='./'>ic</a>/<a href='smc91cxxreg.h.html'>smc91cxxreg.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*	$NetBSD: smc91cxxreg.h,v 1.5 2003/04/29 08:47:30 scw Exp $	*/</i></td></tr>
<tr><th id="2">2</th><td></td></tr>
<tr><th id="3">3</th><td><i>/*</i></td></tr>
<tr><th id="4">4</th><td><i> * Copyright (c) 1996 Gardner Buchanan &lt;gbuchanan@shl.com&gt;</i></td></tr>
<tr><th id="5">5</th><td><i> * All rights reserved.</i></td></tr>
<tr><th id="6">6</th><td><i> *</i></td></tr>
<tr><th id="7">7</th><td><i> * Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="8">8</th><td><i> * modification, are permitted provided that the following conditions</i></td></tr>
<tr><th id="9">9</th><td><i> * are met:</i></td></tr>
<tr><th id="10">10</th><td><i> * 1. Redistributions of source code must retain the above copyright</i></td></tr>
<tr><th id="11">11</th><td><i> *    notice, this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="12">12</th><td><i> * 2. Redistributions in binary form must reproduce the above copyright</i></td></tr>
<tr><th id="13">13</th><td><i> *    notice, this list of conditions and the following disclaimer in the</i></td></tr>
<tr><th id="14">14</th><td><i> *    documentation and/or other materials provided with the distribution.</i></td></tr>
<tr><th id="15">15</th><td><i> * 3. All advertising materials mentioning features or use of this software</i></td></tr>
<tr><th id="16">16</th><td><i> *    must display the following acknowledgement:</i></td></tr>
<tr><th id="17">17</th><td><i> *      This product includes software developed by Gardner Buchanan.</i></td></tr>
<tr><th id="18">18</th><td><i> * 4. The name of Gardner Buchanan may not be used to endorse or promote</i></td></tr>
<tr><th id="19">19</th><td><i> *    products derived from this software without specific prior written</i></td></tr>
<tr><th id="20">20</th><td><i> *    permission.</i></td></tr>
<tr><th id="21">21</th><td><i> *</i></td></tr>
<tr><th id="22">22</th><td><i> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR</i></td></tr>
<tr><th id="23">23</th><td><i> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</i></td></tr>
<tr><th id="24">24</th><td><i> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</i></td></tr>
<tr><th id="25">25</th><td><i> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</i></td></tr>
<tr><th id="26">26</th><td><i> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</i></td></tr>
<tr><th id="27">27</th><td><i> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</i></td></tr>
<tr><th id="28">28</th><td><i> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</i></td></tr>
<tr><th id="29">29</th><td><i> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</i></td></tr>
<tr><th id="30">30</th><td><i> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</i></td></tr>
<tr><th id="31">31</th><td><i> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</i></td></tr>
<tr><th id="32">32</th><td><i> *</i></td></tr>
<tr><th id="33">33</th><td><i> *   from FreeBSD Id: if_snreg.h,v 1.4 1996/03/18 15:47:30 gardner Exp</i></td></tr>
<tr><th id="34">34</th><td><i> */</i></td></tr>
<tr><th id="35">35</th><td></td></tr>
<tr><th id="36">36</th><td><i>/*</i></td></tr>
<tr><th id="37">37</th><td><i> * This file contains register information and access macros for</i></td></tr>
<tr><th id="38">38</th><td><i> * the SMC91xxx chipset.</i></td></tr>
<tr><th id="39">39</th><td><i> *</i></td></tr>
<tr><th id="40">40</th><td><i> * Information contained in this file was obtained from the SMC91C92</i></td></tr>
<tr><th id="41">41</th><td><i> * and SMC91C94 manuals from SMC.  You will need one of these in order</i></td></tr>
<tr><th id="42">42</th><td><i> * to make any meaningful changes to this driver.  Information about</i></td></tr>
<tr><th id="43">43</th><td><i> * obtaining one can be found at <a href="http://www.smc.com">http://www.smc.com</a> in the components</i></td></tr>
<tr><th id="44">44</th><td><i> * division.</i></td></tr>
<tr><th id="45">45</th><td><i> *</i></td></tr>
<tr><th id="46">46</th><td><i> * This FreeBSD driver is derived in part from the smc9194 Linux driver</i></td></tr>
<tr><th id="47">47</th><td><i> * by Erik Stahlman.</i></td></tr>
<tr><th id="48">48</th><td><i> */</i></td></tr>
<tr><th id="49">49</th><td></td></tr>
<tr><th id="50">50</th><td></td></tr>
<tr><th id="51">51</th><td><i>/*</i></td></tr>
<tr><th id="52">52</th><td><i> * Wait time for memory to be free.  This probably shouldn't be</i></td></tr>
<tr><th id="53">53</th><td><i> * tuned that much, as waiting for this means nothing else happens</i></td></tr>
<tr><th id="54">54</th><td><i> * in the system</i></td></tr>
<tr><th id="55">55</th><td><i> */</i></td></tr>
<tr><th id="56">56</th><td><u>#define	<dfn class="macro" id="_M/MEMORY_WAIT_TIME" data-ref="_M/MEMORY_WAIT_TIME">MEMORY_WAIT_TIME</dfn>	1000</u></td></tr>
<tr><th id="57">57</th><td></td></tr>
<tr><th id="58">58</th><td></td></tr>
<tr><th id="59">59</th><td><i>/* The SMC91xxx uses 16 I/O ports */</i></td></tr>
<tr><th id="60">60</th><td><u>#define	<dfn class="macro" id="_M/SMC_IOSIZE" data-ref="_M/SMC_IOSIZE">SMC_IOSIZE</dfn>		16</u></td></tr>
<tr><th id="61">61</th><td></td></tr>
<tr><th id="62">62</th><td></td></tr>
<tr><th id="63">63</th><td><i>/*</i></td></tr>
<tr><th id="64">64</th><td><i> * A description of the SMC registers is probably in order here,</i></td></tr>
<tr><th id="65">65</th><td><i> * although for details, the SMC datasheet is invaluable.</i></td></tr>
<tr><th id="66">66</th><td><i> * The data sheet I (GB) am using is "SMC91C92 Single Chip Ethernet</i></td></tr>
<tr><th id="67">67</th><td><i> * Controller With RAM", Rev. 12/0/94.  Constant definitions I give</i></td></tr>
<tr><th id="68">68</th><td><i> * here are loosely based on the mnemonic names given to them in the</i></td></tr>
<tr><th id="69">69</th><td><i> * data sheet, but there are many exceptions.</i></td></tr>
<tr><th id="70">70</th><td><i> *</i></td></tr>
<tr><th id="71">71</th><td><i> * Basically, the chip has 4 banks of registers (0 to 3), which</i></td></tr>
<tr><th id="72">72</th><td><i> * are accessed by writing a number into the BANK_SELECT register</i></td></tr>
<tr><th id="73">73</th><td><i> * (I also use a SMC_SELECT_BANK macro for this).  Registers are</i></td></tr>
<tr><th id="74">74</th><td><i> * either Byte or Word sized.  My constant definitions end in _B</i></td></tr>
<tr><th id="75">75</th><td><i> * or _W as appropriate.</i></td></tr>
<tr><th id="76">76</th><td><i> *</i></td></tr>
<tr><th id="77">77</th><td><i> * The banks are arranged so that for most purposes, bank 2 is all</i></td></tr>
<tr><th id="78">78</th><td><i> * that is needed for normal run time tasks.</i></td></tr>
<tr><th id="79">79</th><td><i> */</i></td></tr>
<tr><th id="80">80</th><td></td></tr>
<tr><th id="81">81</th><td></td></tr>
<tr><th id="82">82</th><td><i>/*</i></td></tr>
<tr><th id="83">83</th><td><i> * Bank Select Register.  This also doubles as</i></td></tr>
<tr><th id="84">84</th><td><i> * a chip identification register.  This register</i></td></tr>
<tr><th id="85">85</th><td><i> * is mapped at the same position in all banks.</i></td></tr>
<tr><th id="86">86</th><td><i> */</i></td></tr>
<tr><th id="87">87</th><td><u>#define	<dfn class="macro" id="_M/BANK_SELECT_REG_W" data-ref="_M/BANK_SELECT_REG_W">BANK_SELECT_REG_W</dfn>	0x0e</u></td></tr>
<tr><th id="88">88</th><td><u>#define	<dfn class="macro" id="_M/BSR_DETECT_MASK" data-ref="_M/BSR_DETECT_MASK">BSR_DETECT_MASK</dfn>		0xff00</u></td></tr>
<tr><th id="89">89</th><td><u>#define	<dfn class="macro" id="_M/BSR_DETECT_VALUE" data-ref="_M/BSR_DETECT_VALUE">BSR_DETECT_VALUE</dfn>	0x3300</u></td></tr>
<tr><th id="90">90</th><td></td></tr>
<tr><th id="91">91</th><td></td></tr>
<tr><th id="92">92</th><td><i>/*</i></td></tr>
<tr><th id="93">93</th><td><i> * BANK 0</i></td></tr>
<tr><th id="94">94</th><td><i> */</i></td></tr>
<tr><th id="95">95</th><td></td></tr>
<tr><th id="96">96</th><td><i>/*</i></td></tr>
<tr><th id="97">97</th><td><i> * Transmit Control Register controls some aspects of the transmit</i></td></tr>
<tr><th id="98">98</th><td><i> * behavior of the Ethernet Protocol Handler.</i></td></tr>
<tr><th id="99">99</th><td><i> */</i></td></tr>
<tr><th id="100">100</th><td><u>#define	<dfn class="macro" id="_M/TXMIT_CONTROL_REG_W" data-ref="_M/TXMIT_CONTROL_REG_W">TXMIT_CONTROL_REG_W</dfn>	0x00</u></td></tr>
<tr><th id="101">101</th><td></td></tr>
<tr><th id="102">102</th><td><u>#define	<dfn class="macro" id="_M/TCR_ENABLE" data-ref="_M/TCR_ENABLE">TCR_ENABLE</dfn>	0x0001	/* if this is 1, we can transmit */</u></td></tr>
<tr><th id="103">103</th><td><u>#define	<dfn class="macro" id="_M/TCR_LOOP" data-ref="_M/TCR_LOOP">TCR_LOOP</dfn>	0x0002	/* Enable internal analogue loopback */</u></td></tr>
<tr><th id="104">104</th><td><u>#define	<dfn class="macro" id="_M/TCR_FORCOL" data-ref="_M/TCR_FORCOL">TCR_FORCOL</dfn>	0x0004	/* Force Collision on next TX */</u></td></tr>
<tr><th id="105">105</th><td><u>#define	<dfn class="macro" id="_M/TCR_PAD_ENABLE" data-ref="_M/TCR_PAD_ENABLE">TCR_PAD_ENABLE</dfn>	0x0080	/* Pad short packets to 64 bytes */</u></td></tr>
<tr><th id="106">106</th><td><u>#define	<dfn class="macro" id="_M/TCR_NOCRC" data-ref="_M/TCR_NOCRC">TCR_NOCRC</dfn>	0x0100	/* Do not append CRC */</u></td></tr>
<tr><th id="107">107</th><td><u>#define	<dfn class="macro" id="_M/TCR_MON_CSN" data-ref="_M/TCR_MON_CSN">TCR_MON_CSN</dfn>	0x0400	/* monitors the carrier status */</u></td></tr>
<tr><th id="108">108</th><td><u>#define	<dfn class="macro" id="_M/TCR_FDUPLX" data-ref="_M/TCR_FDUPLX">TCR_FDUPLX</dfn>	0x0800	/* receive packets sent out */</u></td></tr>
<tr><th id="109">109</th><td><u>#define	<dfn class="macro" id="_M/TCR_STP_SQET" data-ref="_M/TCR_STP_SQET">TCR_STP_SQET</dfn>	0x1000	/* stop transmitting if Signal quality error */</u></td></tr>
<tr><th id="110">110</th><td><u>#define	<dfn class="macro" id="_M/TCR_EPH_LOOP" data-ref="_M/TCR_EPH_LOOP">TCR_EPH_LOOP</dfn>	0x2000	/* Enable internal digital loopback */</u></td></tr>
<tr><th id="111">111</th><td><u>#define	<dfn class="macro" id="_M/TCR_SWFDUP" data-ref="_M/TCR_SWFDUP">TCR_SWFDUP</dfn>	0x8000	/* FEAST: Switched full-duplex (only w/ MII) */</u></td></tr>
<tr><th id="112">112</th><td></td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td><i>/*</i></td></tr>
<tr><th id="115">115</th><td><i> * Status of the last transmitted frame and instantaneous status of</i></td></tr>
<tr><th id="116">116</th><td><i> * the Ethernet Protocol Handler jumbled together.  In auto-release</i></td></tr>
<tr><th id="117">117</th><td><i> * mode this information is simply discarded after each TX.  This info</i></td></tr>
<tr><th id="118">118</th><td><i> * is copied to the status word of in-memory packets after transmit</i></td></tr>
<tr><th id="119">119</th><td><i> * where relevent statuses can be checked.</i></td></tr>
<tr><th id="120">120</th><td><i> */</i></td></tr>
<tr><th id="121">121</th><td><u>#define	<dfn class="macro" id="_M/EPH_STATUS_REG_W" data-ref="_M/EPH_STATUS_REG_W">EPH_STATUS_REG_W</dfn> 0x02</u></td></tr>
<tr><th id="122">122</th><td></td></tr>
<tr><th id="123">123</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_TX_SUC" data-ref="_M/EPHSR_TX_SUC">EPHSR_TX_SUC</dfn>	0x0001	/* Transmit was successful */</u></td></tr>
<tr><th id="124">124</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_SNGLCOL" data-ref="_M/EPHSR_SNGLCOL">EPHSR_SNGLCOL</dfn>	0x0002	/* Single collision occurred */</u></td></tr>
<tr><th id="125">125</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_MULCOL" data-ref="_M/EPHSR_MULCOL">EPHSR_MULCOL</dfn>	0x0004	/* Multiple Collisions occurred */</u></td></tr>
<tr><th id="126">126</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_LTX_MULT" data-ref="_M/EPHSR_LTX_MULT">EPHSR_LTX_MULT</dfn>	0x0008	/* Transmit was a multicast */</u></td></tr>
<tr><th id="127">127</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_16COL" data-ref="_M/EPHSR_16COL">EPHSR_16COL</dfn>	0x0010	/* 16 Collisions occurred, TX disabled */</u></td></tr>
<tr><th id="128">128</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_SQET" data-ref="_M/EPHSR_SQET">EPHSR_SQET</dfn>	0x0020	/* SQE Test failed, TX disabled */</u></td></tr>
<tr><th id="129">129</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_LTX_BRD" data-ref="_M/EPHSR_LTX_BRD">EPHSR_LTX_BRD</dfn>	0x0040	/* Transmit was a broadcast */</u></td></tr>
<tr><th id="130">130</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_DEFR" data-ref="_M/EPHSR_DEFR">EPHSR_DEFR</dfn>	0x0080	/* TX deferred due to carrier det. */</u></td></tr>
<tr><th id="131">131</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_LATCOL" data-ref="_M/EPHSR_LATCOL">EPHSR_LATCOL</dfn>	0x0200	/* Late collision detected, TX disabled */</u></td></tr>
<tr><th id="132">132</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_LOST_CAR" data-ref="_M/EPHSR_LOST_CAR">EPHSR_LOST_CAR</dfn>	0x0400	/* Lost carrier sense, TX disabled */</u></td></tr>
<tr><th id="133">133</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_EXC_DEF" data-ref="_M/EPHSR_EXC_DEF">EPHSR_EXC_DEF</dfn>	0x0800	/* Excessive deferrals in TX &gt;2 MAXETHER</u></td></tr>
<tr><th id="134">134</th><td><u>				 * times */</u></td></tr>
<tr><th id="135">135</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_CTR_ROL" data-ref="_M/EPHSR_CTR_ROL">EPHSR_CTR_ROL</dfn>	0x1000	/* Some ECR Counter(s) rolled over */</u></td></tr>
<tr><th id="136">136</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_RX_OVRN" data-ref="_M/EPHSR_RX_OVRN">EPHSR_RX_OVRN</dfn>	0x2000	/* Receiver overrun, packets dropped */</u></td></tr>
<tr><th id="137">137</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_LINK_OK" data-ref="_M/EPHSR_LINK_OK">EPHSR_LINK_OK</dfn>	0x4000	/* Link integrity is OK */</u></td></tr>
<tr><th id="138">138</th><td><u>#define	<dfn class="macro" id="_M/EPHSR_TXUNRN" data-ref="_M/EPHSR_TXUNRN">EPHSR_TXUNRN</dfn>	0x8000	/* Transmit underrun */</u></td></tr>
<tr><th id="139">139</th><td></td></tr>
<tr><th id="140">140</th><td></td></tr>
<tr><th id="141">141</th><td><i>/*</i></td></tr>
<tr><th id="142">142</th><td><i> * Receiver Control Register controls some aspects of the receive</i></td></tr>
<tr><th id="143">143</th><td><i> * behavior of the Ethernet Protocol Handler.</i></td></tr>
<tr><th id="144">144</th><td><i> */</i></td></tr>
<tr><th id="145">145</th><td><u>#define	<dfn class="macro" id="_M/RECV_CONTROL_REG_W" data-ref="_M/RECV_CONTROL_REG_W">RECV_CONTROL_REG_W</dfn> 0x04</u></td></tr>
<tr><th id="146">146</th><td></td></tr>
<tr><th id="147">147</th><td><u>#define	<dfn class="macro" id="_M/RCR_RX_ABORT" data-ref="_M/RCR_RX_ABORT">RCR_RX_ABORT</dfn>	0x0001	/* Received huge packet */</u></td></tr>
<tr><th id="148">148</th><td><u>#define	<dfn class="macro" id="_M/RCR_PROMISC" data-ref="_M/RCR_PROMISC">RCR_PROMISC</dfn>	0x0002	/* enable promiscuous mode */</u></td></tr>
<tr><th id="149">149</th><td><u>#define	<dfn class="macro" id="_M/RCR_ALMUL" data-ref="_M/RCR_ALMUL">RCR_ALMUL</dfn>	0x0004	/* receive all multicast packets */</u></td></tr>
<tr><th id="150">150</th><td><u>#define	<dfn class="macro" id="_M/RCR_ENABLE" data-ref="_M/RCR_ENABLE">RCR_ENABLE</dfn>	0x0100	/* IFF this is set, we can receive packets */</u></td></tr>
<tr><th id="151">151</th><td><u>#define	<dfn class="macro" id="_M/RCR_STRIP_CRC" data-ref="_M/RCR_STRIP_CRC">RCR_STRIP_CRC</dfn>	0x0200	/* strips CRC */</u></td></tr>
<tr><th id="152">152</th><td><u>#define	<dfn class="macro" id="_M/RCR_GAIN_BITS" data-ref="_M/RCR_GAIN_BITS">RCR_GAIN_BITS</dfn>	0x0c00	/* PLL Gain control (for testing) */</u></td></tr>
<tr><th id="153">153</th><td><u>#define	<dfn class="macro" id="_M/RCR_FILT_CAR" data-ref="_M/RCR_FILT_CAR">RCR_FILT_CAR</dfn>	0x4000	/* Enable 12 bit carrier filter */</u></td></tr>
<tr><th id="154">154</th><td><u>#define	<dfn class="macro" id="_M/RCR_SOFTRESET" data-ref="_M/RCR_SOFTRESET">RCR_SOFTRESET</dfn>	0x8000	/* Resets the EPH logic */</u></td></tr>
<tr><th id="155">155</th><td></td></tr>
<tr><th id="156">156</th><td></td></tr>
<tr><th id="157">157</th><td><i>/*</i></td></tr>
<tr><th id="158">158</th><td><i> * TX Statistics counters</i></td></tr>
<tr><th id="159">159</th><td><i> */</i></td></tr>
<tr><th id="160">160</th><td><u>#define	<dfn class="macro" id="_M/COUNTER_REG_W" data-ref="_M/COUNTER_REG_W">COUNTER_REG_W</dfn>	0x06</u></td></tr>
<tr><th id="161">161</th><td></td></tr>
<tr><th id="162">162</th><td><u>#define	<dfn class="macro" id="_M/ECR_COLN_MASK" data-ref="_M/ECR_COLN_MASK">ECR_COLN_MASK</dfn>	0x000f	/* Vanilla collisions */</u></td></tr>
<tr><th id="163">163</th><td><u>#define	<dfn class="macro" id="_M/ECR_MCOLN_MASK" data-ref="_M/ECR_MCOLN_MASK">ECR_MCOLN_MASK</dfn>	0x00f0	/* Multiple collisions */</u></td></tr>
<tr><th id="164">164</th><td><u>#define	<dfn class="macro" id="_M/ECR_DTX_MASK" data-ref="_M/ECR_DTX_MASK">ECR_DTX_MASK</dfn>	0x0f00	/* Deferred transmits */</u></td></tr>
<tr><th id="165">165</th><td><u>#define	<dfn class="macro" id="_M/ECR_EXDTX_MASK" data-ref="_M/ECR_EXDTX_MASK">ECR_EXDTX_MASK</dfn>	0xf000	/* Excessively deferred transmits */</u></td></tr>
<tr><th id="166">166</th><td></td></tr>
<tr><th id="167">167</th><td></td></tr>
<tr><th id="168">168</th><td><i>/*</i></td></tr>
<tr><th id="169">169</th><td><i> * Memory Information</i></td></tr>
<tr><th id="170">170</th><td><i> */</i></td></tr>
<tr><th id="171">171</th><td><u>#define	<dfn class="macro" id="_M/MEM_INFO_REG_W" data-ref="_M/MEM_INFO_REG_W">MEM_INFO_REG_W</dfn>	0x08</u></td></tr>
<tr><th id="172">172</th><td></td></tr>
<tr><th id="173">173</th><td><u>#define	<dfn class="macro" id="_M/MIR_FREE_MASK" data-ref="_M/MIR_FREE_MASK">MIR_FREE_MASK</dfn>	0xff00	/* Free memory pages available */</u></td></tr>
<tr><th id="174">174</th><td><u>#define	<dfn class="macro" id="_M/MIR_TOTAL_MASK" data-ref="_M/MIR_TOTAL_MASK">MIR_TOTAL_MASK</dfn>	0x00ff	/* Total memory pages available */</u></td></tr>
<tr><th id="175">175</th><td><u>#define	 <dfn class="macro" id="_M/MIR_MULT_91C111" data-ref="_M/MIR_MULT_91C111">MIR_MULT_91C111</dfn>  1</u></td></tr>
<tr><th id="176">176</th><td><u>#define  <dfn class="macro" id="_M/MIR_SCALE_91C9x" data-ref="_M/MIR_SCALE_91C9x">MIR_SCALE_91C9x</dfn>  256</u></td></tr>
<tr><th id="177">177</th><td><u>#define  <dfn class="macro" id="_M/MIR_SCALE_91C111" data-ref="_M/MIR_SCALE_91C111">MIR_SCALE_91C111</dfn> 2048</u></td></tr>
<tr><th id="178">178</th><td></td></tr>
<tr><th id="179">179</th><td></td></tr>
<tr><th id="180">180</th><td><i>/*</i></td></tr>
<tr><th id="181">181</th><td><i> * Memory Configuration</i></td></tr>
<tr><th id="182">182</th><td><i> */</i></td></tr>
<tr><th id="183">183</th><td><u>#define	<dfn class="macro" id="_M/MEM_CFG_REG_W" data-ref="_M/MEM_CFG_REG_W">MEM_CFG_REG_W</dfn>		0x0a</u></td></tr>
<tr><th id="184">184</th><td></td></tr>
<tr><th id="185">185</th><td><u>#define	<dfn class="macro" id="_M/MCR_MEM_MULT" data-ref="_M/MCR_MEM_MULT">MCR_MEM_MULT</dfn>(x)	(((x)&gt;&gt;9)&amp;7)	/* Memory size multiplier */</u></td></tr>
<tr><th id="186">186</th><td><u>#define	<dfn class="macro" id="_M/MCR_TXRSV_MASK" data-ref="_M/MCR_TXRSV_MASK">MCR_TXRSV_MASK</dfn>	0x001f	/* Count of pages reserved for transmit */</u></td></tr>
<tr><th id="187">187</th><td></td></tr>
<tr><th id="188">188</th><td><i>/*</i></td></tr>
<tr><th id="189">189</th><td><i> * Receive/PHY Control Register (SM91C111 only)</i></td></tr>
<tr><th id="190">190</th><td><i> */</i></td></tr>
<tr><th id="191">191</th><td><u>#define	<dfn class="macro" id="_M/RX_PHY_CONTROL_REG_W" data-ref="_M/RX_PHY_CONTROL_REG_W">RX_PHY_CONTROL_REG_W</dfn>	0x0a	/* 91C111 only */</u></td></tr>
<tr><th id="192">192</th><td></td></tr>
<tr><th id="193">193</th><td><u>#define	<dfn class="macro" id="_M/RPC_LSB_SHIFT" data-ref="_M/RPC_LSB_SHIFT">RPC_LSB_SHIFT</dfn>		2	/* Shift for LED-B select bits */</u></td></tr>
<tr><th id="194">194</th><td><u>#define	<dfn class="macro" id="_M/RPC_LSA_SHIFT" data-ref="_M/RPC_LSA_SHIFT">RPC_LSA_SHIFT</dfn>		5	/* Shift for LED-A select bits */</u></td></tr>
<tr><th id="195">195</th><td><u>#define	<dfn class="macro" id="_M/RPC_LS_MASK" data-ref="_M/RPC_LS_MASK">RPC_LS_MASK</dfn>		0x7	/* LED Select mask */</u></td></tr>
<tr><th id="196">196</th><td><u>#define	<dfn class="macro" id="_M/RPC_LS_LINK_DETECT" data-ref="_M/RPC_LS_LINK_DETECT">RPC_LS_LINK_DETECT</dfn>	0x0	/* 10/100 link detected */</u></td></tr>
<tr><th id="197">197</th><td><u>#define	<dfn class="macro" id="_M/RPC_LS_LINK_10MBPS" data-ref="_M/RPC_LS_LINK_10MBPS">RPC_LS_LINK_10MBPS</dfn>	0x2	/* 10 MBPS link detected */</u></td></tr>
<tr><th id="198">198</th><td><u>#define	<dfn class="macro" id="_M/RPC_LS_FULL_DUPLEX" data-ref="_M/RPC_LS_FULL_DUPLEX">RPC_LS_FULL_DUPLEX</dfn>	0x3	/* Full duplex operation */</u></td></tr>
<tr><th id="199">199</th><td><u>#define	<dfn class="macro" id="_M/RPC_LS_TXRX" data-ref="_M/RPC_LS_TXRX">RPC_LS_TXRX</dfn>		0x4	/* Tx/Rx packet */</u></td></tr>
<tr><th id="200">200</th><td><u>#define	<dfn class="macro" id="_M/RPC_LS_LINK_100MBPS" data-ref="_M/RPC_LS_LINK_100MBPS">RPC_LS_LINK_100MBPS</dfn>	0x5	/* 100 MBPS link detected */</u></td></tr>
<tr><th id="201">201</th><td><u>#define	<dfn class="macro" id="_M/RPC_LS_RX" data-ref="_M/RPC_LS_RX">RPC_LS_RX</dfn>		0x6	/* Rx packet */</u></td></tr>
<tr><th id="202">202</th><td><u>#define	<dfn class="macro" id="_M/RPC_LS_TX" data-ref="_M/RPC_LS_TX">RPC_LS_TX</dfn>		0x7	/* Tx packet */</u></td></tr>
<tr><th id="203">203</th><td><u>#define	<dfn class="macro" id="_M/RPC_ANEG" data-ref="_M/RPC_ANEG">RPC_ANEG</dfn>		0x0800	/* Autonegotiate enable */</u></td></tr>
<tr><th id="204">204</th><td><u>#define	<dfn class="macro" id="_M/RPC_DPLX" data-ref="_M/RPC_DPLX">RPC_DPLX</dfn>		0x1000	/* Duplex select (set = Full) */</u></td></tr>
<tr><th id="205">205</th><td><u>#define	<dfn class="macro" id="_M/RPC_SPEED" data-ref="_M/RPC_SPEED">RPC_SPEED</dfn>		0x2000	/* Speed (set = 100mbps) */</u></td></tr>
<tr><th id="206">206</th><td></td></tr>
<tr><th id="207">207</th><td></td></tr>
<tr><th id="208">208</th><td><i>/*</i></td></tr>
<tr><th id="209">209</th><td><i> * Bank 0, Register 0x0c is unused in the SMC91C92</i></td></tr>
<tr><th id="210">210</th><td><i> */</i></td></tr>
<tr><th id="211">211</th><td></td></tr>
<tr><th id="212">212</th><td></td></tr>
<tr><th id="213">213</th><td><i>/*</i></td></tr>
<tr><th id="214">214</th><td><i> * BANK 1</i></td></tr>
<tr><th id="215">215</th><td><i> */</i></td></tr>
<tr><th id="216">216</th><td></td></tr>
<tr><th id="217">217</th><td><i>/*</i></td></tr>
<tr><th id="218">218</th><td><i> * Adapter configuration</i></td></tr>
<tr><th id="219">219</th><td><i> */</i></td></tr>
<tr><th id="220">220</th><td><u>#define	<dfn class="macro" id="_M/CONFIG_REG_W" data-ref="_M/CONFIG_REG_W">CONFIG_REG_W</dfn>	0x00</u></td></tr>
<tr><th id="221">221</th><td></td></tr>
<tr><th id="222">222</th><td><u>#define	<dfn class="macro" id="_M/CR_INT_SEL0" data-ref="_M/CR_INT_SEL0">CR_INT_SEL0</dfn>	0x0002	/* Interrupt selector */</u></td></tr>
<tr><th id="223">223</th><td><u>#define	<dfn class="macro" id="_M/CR_INT_SEL1" data-ref="_M/CR_INT_SEL1">CR_INT_SEL1</dfn>	0x0004	/* Interrupt selector */</u></td></tr>
<tr><th id="224">224</th><td><u>#define	<dfn class="macro" id="_M/CR_DIS_LINK" data-ref="_M/CR_DIS_LINK">CR_DIS_LINK</dfn>	0x0040	/* Disable 10BaseT Link Test */</u></td></tr>
<tr><th id="225">225</th><td><u>#define	<dfn class="macro" id="_M/CR_16BIT" data-ref="_M/CR_16BIT">CR_16BIT</dfn>	0x0080	/* Bus width */</u></td></tr>
<tr><th id="226">226</th><td><u>#define	<dfn class="macro" id="_M/CR_AUI_SELECT" data-ref="_M/CR_AUI_SELECT">CR_AUI_SELECT</dfn>	0x0100	/* Use external (AUI) Transceiver */</u></td></tr>
<tr><th id="227">227</th><td><u>#define	<dfn class="macro" id="_M/CR_SET_SQLCH" data-ref="_M/CR_SET_SQLCH">CR_SET_SQLCH</dfn>	0x0200	/* Squelch level */</u></td></tr>
<tr><th id="228">228</th><td><u>#define	<dfn class="macro" id="_M/CR_FULL_STEP" data-ref="_M/CR_FULL_STEP">CR_FULL_STEP</dfn>	0x0400	/* AUI signalling mode */</u></td></tr>
<tr><th id="229">229</th><td><u>#define	<dfn class="macro" id="_M/CR_NOW_WAIT_ST" data-ref="_M/CR_NOW_WAIT_ST">CR_NOW_WAIT_ST</dfn>	0x1000	/* Disable bus wait states */</u></td></tr>
<tr><th id="230">230</th><td><u>#define	<dfn class="macro" id="_M/CR_MII_SELECT" data-ref="_M/CR_MII_SELECT">CR_MII_SELECT</dfn> 	0x8000	/* FEAST: MII port selected */</u></td></tr>
<tr><th id="231">231</th><td></td></tr>
<tr><th id="232">232</th><td></td></tr>
<tr><th id="233">233</th><td><i>/*</i></td></tr>
<tr><th id="234">234</th><td><i> * The contents of this port are used by the adapter</i></td></tr>
<tr><th id="235">235</th><td><i> * to decode its I/O address.  We use it as a varification</i></td></tr>
<tr><th id="236">236</th><td><i> * that the adapter is detected properly when probing.</i></td></tr>
<tr><th id="237">237</th><td><i> */</i></td></tr>
<tr><th id="238">238</th><td><u>#define	<dfn class="macro" id="_M/BASE_ADDR_REG_W" data-ref="_M/BASE_ADDR_REG_W">BASE_ADDR_REG_W</dfn>	0x02	/* The selected I/O Base addr. */</u></td></tr>
<tr><th id="239">239</th><td></td></tr>
<tr><th id="240">240</th><td></td></tr>
<tr><th id="241">241</th><td><i>/*</i></td></tr>
<tr><th id="242">242</th><td><i> * These registers hold the Ethernet MAC address.</i></td></tr>
<tr><th id="243">243</th><td><i> */</i></td></tr>
<tr><th id="244">244</th><td><u>#define	<dfn class="macro" id="_M/IAR_ADDR0_REG_W" data-ref="_M/IAR_ADDR0_REG_W">IAR_ADDR0_REG_W</dfn>	0x04	/* My Ethernet address */</u></td></tr>
<tr><th id="245">245</th><td><u>#define	<dfn class="macro" id="_M/IAR_ADDR1_REG_W" data-ref="_M/IAR_ADDR1_REG_W">IAR_ADDR1_REG_W</dfn>	0x06	/* My Ethernet address */</u></td></tr>
<tr><th id="246">246</th><td><u>#define	<dfn class="macro" id="_M/IAR_ADDR2_REG_W" data-ref="_M/IAR_ADDR2_REG_W">IAR_ADDR2_REG_W</dfn>	0x08	/* My Ethernet address */</u></td></tr>
<tr><th id="247">247</th><td></td></tr>
<tr><th id="248">248</th><td></td></tr>
<tr><th id="249">249</th><td><i>/*</i></td></tr>
<tr><th id="250">250</th><td><i> * General purpose register used for talking to the EEPROM.</i></td></tr>
<tr><th id="251">251</th><td><i> */</i></td></tr>
<tr><th id="252">252</th><td><u>#define	<dfn class="macro" id="_M/GENERAL_REG_W" data-ref="_M/GENERAL_REG_W">GENERAL_REG_W</dfn>	0x0a</u></td></tr>
<tr><th id="253">253</th><td></td></tr>
<tr><th id="254">254</th><td></td></tr>
<tr><th id="255">255</th><td><i>/*</i></td></tr>
<tr><th id="256">256</th><td><i> * Control register used for talking to the EEPROM and</i></td></tr>
<tr><th id="257">257</th><td><i> * setting some EPH functions.</i></td></tr>
<tr><th id="258">258</th><td><i> */</i></td></tr>
<tr><th id="259">259</th><td><u>#define	<dfn class="macro" id="_M/CONTROL_REG_W" data-ref="_M/CONTROL_REG_W">CONTROL_REG_W</dfn>	0x0c</u></td></tr>
<tr><th id="260">260</th><td></td></tr>
<tr><th id="261">261</th><td><u>#define	<dfn class="macro" id="_M/CTR_STORE" data-ref="_M/CTR_STORE">CTR_STORE</dfn>	 0x0001	/* Store something to EEPROM */</u></td></tr>
<tr><th id="262">262</th><td><u>#define	<dfn class="macro" id="_M/CTR_RELOAD" data-ref="_M/CTR_RELOAD">CTR_RELOAD</dfn>	 0x0002	/* Read EEPROM into registers */</u></td></tr>
<tr><th id="263">263</th><td><u>#define	<dfn class="macro" id="_M/CTR_EEPROM_SEL" data-ref="_M/CTR_EEPROM_SEL">CTR_EEPROM_SEL</dfn>	 0x0004	/* Select registers for Reload/Store */</u></td></tr>
<tr><th id="264">264</th><td><u>#define	<dfn class="macro" id="_M/CTR_TE_ENABLE" data-ref="_M/CTR_TE_ENABLE">CTR_TE_ENABLE</dfn>	 0x0020	/* Enable TX Error detection via EPH_INT */</u></td></tr>
<tr><th id="265">265</th><td><u>#define	<dfn class="macro" id="_M/CTR_CR_ENABLE" data-ref="_M/CTR_CR_ENABLE">CTR_CR_ENABLE</dfn>	 0x0040	/* Enable Counter Rollover via EPH_INT */</u></td></tr>
<tr><th id="266">266</th><td><u>#define	<dfn class="macro" id="_M/CTR_LE_ENABLE" data-ref="_M/CTR_LE_ENABLE">CTR_LE_ENABLE</dfn>	 0x0080	/* Enable Link Error detection via EPH_INT */</u></td></tr>
<tr><th id="267">267</th><td><u>#define	<dfn class="macro" id="_M/CTR_AUTO_RELEASE" data-ref="_M/CTR_AUTO_RELEASE">CTR_AUTO_RELEASE</dfn> 0x0800	/* Enable auto release mode for TX */</u></td></tr>
<tr><th id="268">268</th><td><u>#define	<dfn class="macro" id="_M/CTR_POWERDOWN" data-ref="_M/CTR_POWERDOWN">CTR_POWERDOWN</dfn>	 0x2000	/* Enter powerdown mode */</u></td></tr>
<tr><th id="269">269</th><td><u>#define	<dfn class="macro" id="_M/CTR_RCV_BAD" data-ref="_M/CTR_RCV_BAD">CTR_RCV_BAD</dfn>	 0x4000	/* Enable receipt of frames with bad CRC */</u></td></tr>
<tr><th id="270">270</th><td></td></tr>
<tr><th id="271">271</th><td></td></tr>
<tr><th id="272">272</th><td><i>/*</i></td></tr>
<tr><th id="273">273</th><td><i> * BANK 2</i></td></tr>
<tr><th id="274">274</th><td><i> */</i></td></tr>
<tr><th id="275">275</th><td></td></tr>
<tr><th id="276">276</th><td></td></tr>
<tr><th id="277">277</th><td><i>/*</i></td></tr>
<tr><th id="278">278</th><td><i> * Memory Management Unit Control Register</i></td></tr>
<tr><th id="279">279</th><td><i> * Controls allocation of memory to receive and</i></td></tr>
<tr><th id="280">280</th><td><i> * transmit functions.</i></td></tr>
<tr><th id="281">281</th><td><i> */</i></td></tr>
<tr><th id="282">282</th><td><u>#define	<dfn class="macro" id="_M/MMU_CMD_REG_W" data-ref="_M/MMU_CMD_REG_W">MMU_CMD_REG_W</dfn>	0x00</u></td></tr>
<tr><th id="283">283</th><td></td></tr>
<tr><th id="284">284</th><td><u>#define	<dfn class="macro" id="_M/MMUCR_BUSY" data-ref="_M/MMUCR_BUSY">MMUCR_BUSY</dfn>	0x0001	/* MMU busy performing a release */</u></td></tr>
<tr><th id="285">285</th><td></td></tr>
<tr><th id="286">286</th><td><i>/*</i></td></tr>
<tr><th id="287">287</th><td><i> * MMU Commands:</i></td></tr>
<tr><th id="288">288</th><td><i> */</i></td></tr>
<tr><th id="289">289</th><td><u>#define	<dfn class="macro" id="_M/MMUCR_NOP" data-ref="_M/MMUCR_NOP">MMUCR_NOP</dfn>	0x0000	/* Do nothing */</u></td></tr>
<tr><th id="290">290</th><td><u>#define	<dfn class="macro" id="_M/MMUCR_ALLOC" data-ref="_M/MMUCR_ALLOC">MMUCR_ALLOC</dfn>	0x0020	/* Or with number of 256 byte packets - 1 */</u></td></tr>
<tr><th id="291">291</th><td><u>#define	<dfn class="macro" id="_M/MMUCR_RESET" data-ref="_M/MMUCR_RESET">MMUCR_RESET</dfn>	0x0040	/* Reset MMU State */</u></td></tr>
<tr><th id="292">292</th><td><u>#define	<dfn class="macro" id="_M/MMUCR_REMOVE" data-ref="_M/MMUCR_REMOVE">MMUCR_REMOVE</dfn>	0x0060	/* Dequeue (but not free) current RX packet */</u></td></tr>
<tr><th id="293">293</th><td><u>#define	<dfn class="macro" id="_M/MMUCR_RELEASE" data-ref="_M/MMUCR_RELEASE">MMUCR_RELEASE</dfn>	0x0080	/* Dequeue and free the current RX packet */</u></td></tr>
<tr><th id="294">294</th><td><u>#define	<dfn class="macro" id="_M/MMUCR_FREEPKT" data-ref="_M/MMUCR_FREEPKT">MMUCR_FREEPKT</dfn>	0x00a0	/* Release packet in PNR register */</u></td></tr>
<tr><th id="295">295</th><td><u>#define	<dfn class="macro" id="_M/MMUCR_ENQUEUE" data-ref="_M/MMUCR_ENQUEUE">MMUCR_ENQUEUE</dfn>	0x00c0	/* Enqueue the packet for transmit */</u></td></tr>
<tr><th id="296">296</th><td><u>#define	<dfn class="macro" id="_M/MMUCR_RESETTX" data-ref="_M/MMUCR_RESETTX">MMUCR_RESETTX</dfn>	0x00e0	/* Reset transmit queues */</u></td></tr>
<tr><th id="297">297</th><td></td></tr>
<tr><th id="298">298</th><td><i>/*</i></td></tr>
<tr><th id="299">299</th><td><i> * Packet Number at TX Area</i></td></tr>
<tr><th id="300">300</th><td><i> */</i></td></tr>
<tr><th id="301">301</th><td><u>#define	<dfn class="macro" id="_M/PACKET_NUM_REG_B" data-ref="_M/PACKET_NUM_REG_B">PACKET_NUM_REG_B</dfn> 0x02</u></td></tr>
<tr><th id="302">302</th><td></td></tr>
<tr><th id="303">303</th><td><i>/*</i></td></tr>
<tr><th id="304">304</th><td><i> * Packet number resulting from MMUCR_ALLOC</i></td></tr>
<tr><th id="305">305</th><td><i> */</i></td></tr>
<tr><th id="306">306</th><td><u>#define	<dfn class="macro" id="_M/ALLOC_RESULT_REG_B" data-ref="_M/ALLOC_RESULT_REG_B">ALLOC_RESULT_REG_B</dfn> 0x03</u></td></tr>
<tr><th id="307">307</th><td><u>#define	<dfn class="macro" id="_M/ARR_FAILED" data-ref="_M/ARR_FAILED">ARR_FAILED</dfn>	0x80</u></td></tr>
<tr><th id="308">308</th><td></td></tr>
<tr><th id="309">309</th><td><i>/*</i></td></tr>
<tr><th id="310">310</th><td><i> * Transmit and receive queue heads</i></td></tr>
<tr><th id="311">311</th><td><i> */</i></td></tr>
<tr><th id="312">312</th><td><u>#define	<dfn class="macro" id="_M/FIFO_PORTS_REG_W" data-ref="_M/FIFO_PORTS_REG_W">FIFO_PORTS_REG_W</dfn> 0x04</u></td></tr>
<tr><th id="313">313</th><td><u>#define	<dfn class="macro" id="_M/FIFO_REMPTY" data-ref="_M/FIFO_REMPTY">FIFO_REMPTY</dfn>	0x8000</u></td></tr>
<tr><th id="314">314</th><td><u>#define	<dfn class="macro" id="_M/FIFO_TEMPTY" data-ref="_M/FIFO_TEMPTY">FIFO_TEMPTY</dfn>	0x0080</u></td></tr>
<tr><th id="315">315</th><td><u>#define	<dfn class="macro" id="_M/FIFO_RX_MASK" data-ref="_M/FIFO_RX_MASK">FIFO_RX_MASK</dfn>	0x7f00</u></td></tr>
<tr><th id="316">316</th><td><u>#define	<dfn class="macro" id="_M/FIFO_TX_MASK" data-ref="_M/FIFO_TX_MASK">FIFO_TX_MASK</dfn>	0x007f</u></td></tr>
<tr><th id="317">317</th><td></td></tr>
<tr><th id="318">318</th><td></td></tr>
<tr><th id="319">319</th><td><i>/*</i></td></tr>
<tr><th id="320">320</th><td><i> * The address within the packet for reading/writing.  The</i></td></tr>
<tr><th id="321">321</th><td><i> * PTR_RCV bit is tricky.  When PTR_RCV==1, the packet number</i></td></tr>
<tr><th id="322">322</th><td><i> * to be read is found in the FIFO_PORTS_REG_W, FIFO_RX_MASK.</i></td></tr>
<tr><th id="323">323</th><td><i> * When PTR_RCV==0, the packet number to be written is found</i></td></tr>
<tr><th id="324">324</th><td><i> * in the PACKET_NUM_REG_B.</i></td></tr>
<tr><th id="325">325</th><td><i> */</i></td></tr>
<tr><th id="326">326</th><td><u>#define	<dfn class="macro" id="_M/POINTER_REG_W" data-ref="_M/POINTER_REG_W">POINTER_REG_W</dfn>	0x06</u></td></tr>
<tr><th id="327">327</th><td></td></tr>
<tr><th id="328">328</th><td><u>#define	<dfn class="macro" id="_M/PTR_READ" data-ref="_M/PTR_READ">PTR_READ</dfn>	0x2000	/* Intended access mode */</u></td></tr>
<tr><th id="329">329</th><td><u>#define	<dfn class="macro" id="_M/PTR_AUTOINC" data-ref="_M/PTR_AUTOINC">PTR_AUTOINC</dfn>	0x4000	/* Do auto inc after read/write */</u></td></tr>
<tr><th id="330">330</th><td><u>#define	<dfn class="macro" id="_M/PTR_RCV" data-ref="_M/PTR_RCV">PTR_RCV</dfn>		0x8000	/* FIFO_RX is packet, otherwise PNR is packet */</u></td></tr>
<tr><th id="331">331</th><td></td></tr>
<tr><th id="332">332</th><td><i>/*</i></td></tr>
<tr><th id="333">333</th><td><i> * Data I/O register to be used in conjunction with</i></td></tr>
<tr><th id="334">334</th><td><i> * The pointer register to read and write data from the</i></td></tr>
<tr><th id="335">335</th><td><i> * card.  The same register can be used for byte and word</i></td></tr>
<tr><th id="336">336</th><td><i> * ops.</i></td></tr>
<tr><th id="337">337</th><td><i> */</i></td></tr>
<tr><th id="338">338</th><td><u>#define	<dfn class="macro" id="_M/DATA_REG_W" data-ref="_M/DATA_REG_W">DATA_REG_W</dfn>	0x08</u></td></tr>
<tr><th id="339">339</th><td><u>#define	<dfn class="macro" id="_M/DATA_REG_B" data-ref="_M/DATA_REG_B">DATA_REG_B</dfn>	0x08</u></td></tr>
<tr><th id="340">340</th><td><u>#define	<dfn class="macro" id="_M/DATA_1_REG_B" data-ref="_M/DATA_1_REG_B">DATA_1_REG_B</dfn>	0x08</u></td></tr>
<tr><th id="341">341</th><td><u>#define	<dfn class="macro" id="_M/DATA_2_REG_B" data-ref="_M/DATA_2_REG_B">DATA_2_REG_B</dfn>	0x0a</u></td></tr>
<tr><th id="342">342</th><td></td></tr>
<tr><th id="343">343</th><td></td></tr>
<tr><th id="344">344</th><td><i>/*</i></td></tr>
<tr><th id="345">345</th><td><i> * Sense interrupt status (READ)</i></td></tr>
<tr><th id="346">346</th><td><i> */</i></td></tr>
<tr><th id="347">347</th><td><u>#define	<dfn class="macro" id="_M/INTR_STAT_REG_B" data-ref="_M/INTR_STAT_REG_B">INTR_STAT_REG_B</dfn>	0x0c</u></td></tr>
<tr><th id="348">348</th><td></td></tr>
<tr><th id="349">349</th><td></td></tr>
<tr><th id="350">350</th><td><i>/*</i></td></tr>
<tr><th id="351">351</th><td><i> * Acknowledge interrupt sources (WRITE)</i></td></tr>
<tr><th id="352">352</th><td><i> */</i></td></tr>
<tr><th id="353">353</th><td><u>#define	<dfn class="macro" id="_M/INTR_ACK_REG_B" data-ref="_M/INTR_ACK_REG_B">INTR_ACK_REG_B</dfn>	0x0c</u></td></tr>
<tr><th id="354">354</th><td></td></tr>
<tr><th id="355">355</th><td></td></tr>
<tr><th id="356">356</th><td><i>/*</i></td></tr>
<tr><th id="357">357</th><td><i> * Interrupt mask.  Bit set indicates interrupt allowed.</i></td></tr>
<tr><th id="358">358</th><td><i> */</i></td></tr>
<tr><th id="359">359</th><td><u>#define	<dfn class="macro" id="_M/INTR_MASK_REG_B" data-ref="_M/INTR_MASK_REG_B">INTR_MASK_REG_B</dfn>	0x0d</u></td></tr>
<tr><th id="360">360</th><td></td></tr>
<tr><th id="361">361</th><td><i>/*</i></td></tr>
<tr><th id="362">362</th><td><i> * Interrupts</i></td></tr>
<tr><th id="363">363</th><td><i> */</i></td></tr>
<tr><th id="364">364</th><td><u>#define	<dfn class="macro" id="_M/IM_RCV_INT" data-ref="_M/IM_RCV_INT">IM_RCV_INT</dfn>	0x01	/* A packet has been received */</u></td></tr>
<tr><th id="365">365</th><td><u>#define	<dfn class="macro" id="_M/IM_TX_INT" data-ref="_M/IM_TX_INT">IM_TX_INT</dfn>	0x02	/* Packet TX complete */</u></td></tr>
<tr><th id="366">366</th><td><u>#define	<dfn class="macro" id="_M/IM_TX_EMPTY_INT" data-ref="_M/IM_TX_EMPTY_INT">IM_TX_EMPTY_INT</dfn>	0x04	/* No packets left to TX  */</u></td></tr>
<tr><th id="367">367</th><td><u>#define	<dfn class="macro" id="_M/IM_ALLOC_INT" data-ref="_M/IM_ALLOC_INT">IM_ALLOC_INT</dfn>	0x08	/* Memory allocation completed */</u></td></tr>
<tr><th id="368">368</th><td><u>#define	<dfn class="macro" id="_M/IM_RX_OVRN_INT" data-ref="_M/IM_RX_OVRN_INT">IM_RX_OVRN_INT</dfn>	0x10	/* Receiver was overrun */</u></td></tr>
<tr><th id="369">369</th><td><u>#define	<dfn class="macro" id="_M/IM_EPH_INT" data-ref="_M/IM_EPH_INT">IM_EPH_INT</dfn>	0x20	/* Misc. EPH conditions (see CONTROL_REG_W) */</u></td></tr>
<tr><th id="370">370</th><td><u>#define	<dfn class="macro" id="_M/IM_ERCV_INT" data-ref="_M/IM_ERCV_INT">IM_ERCV_INT</dfn>	0x40	/* not on SMC9192 */</u></td></tr>
<tr><th id="371">371</th><td><u>#define	<dfn class="macro" id="_M/IM_MD_INT" data-ref="_M/IM_MD_INT">IM_MD_INT</dfn>	0x80	/* SMC91C111 Internal PHY status change */</u></td></tr>
<tr><th id="372">372</th><td></td></tr>
<tr><th id="373">373</th><td></td></tr>
<tr><th id="374">374</th><td><i>/*</i></td></tr>
<tr><th id="375">375</th><td><i> * BANK 3</i></td></tr>
<tr><th id="376">376</th><td><i> */</i></td></tr>
<tr><th id="377">377</th><td></td></tr>
<tr><th id="378">378</th><td></td></tr>
<tr><th id="379">379</th><td><i>/*</i></td></tr>
<tr><th id="380">380</th><td><i> * Multicast subscriptions.</i></td></tr>
<tr><th id="381">381</th><td><i> * The multicast handling in the SMC90Cxx is quite complicated.  A table</i></td></tr>
<tr><th id="382">382</th><td><i> * of multicast address subscriptions is provided and a clever way of</i></td></tr>
<tr><th id="383">383</th><td><i> * speeding the search of that table by hashing is implemented in the</i></td></tr>
<tr><th id="384">384</th><td><i> * hardware.  I have ignored this and simply subscribed to all multicasts</i></td></tr>
<tr><th id="385">385</th><td><i> * and let the kernel deal with the results.</i></td></tr>
<tr><th id="386">386</th><td><i> */</i></td></tr>
<tr><th id="387">387</th><td><u>#define	<dfn class="macro" id="_M/MULTICAST1_REG_W" data-ref="_M/MULTICAST1_REG_W">MULTICAST1_REG_W</dfn> 0x00</u></td></tr>
<tr><th id="388">388</th><td><u>#define	<dfn class="macro" id="_M/MULTICAST2_REG_W" data-ref="_M/MULTICAST2_REG_W">MULTICAST2_REG_W</dfn> 0x02</u></td></tr>
<tr><th id="389">389</th><td><u>#define	<dfn class="macro" id="_M/MULTICAST3_REG_W" data-ref="_M/MULTICAST3_REG_W">MULTICAST3_REG_W</dfn> 0x04</u></td></tr>
<tr><th id="390">390</th><td><u>#define	<dfn class="macro" id="_M/MULTICAST4_REG_W" data-ref="_M/MULTICAST4_REG_W">MULTICAST4_REG_W</dfn> 0x06</u></td></tr>
<tr><th id="391">391</th><td></td></tr>
<tr><th id="392">392</th><td><i>/*</i></td></tr>
<tr><th id="393">393</th><td><i> * These registers do not exist on SMC9192, or at least</i></td></tr>
<tr><th id="394">394</th><td><i> * are not documented in the SMC91C92 data sheet.</i></td></tr>
<tr><th id="395">395</th><td><i> *</i></td></tr>
<tr><th id="396">396</th><td><i> * The REVISION_REG_W register does however seem to work.</i></td></tr>
<tr><th id="397">397</th><td><i> *</i></td></tr>
<tr><th id="398">398</th><td><i> * On the FEAST, the low nibble controls the MII interface.</i></td></tr>
<tr><th id="399">399</th><td><i> */</i></td></tr>
<tr><th id="400">400</th><td><u>#define	<dfn class="macro" id="_M/MGMT_REG_W" data-ref="_M/MGMT_REG_W">MGMT_REG_W</dfn>	0x08</u></td></tr>
<tr><th id="401">401</th><td></td></tr>
<tr><th id="402">402</th><td><u>#define	<dfn class="macro" id="_M/MR_MDOE" data-ref="_M/MR_MDOE">MR_MDOE</dfn>		0x08</u></td></tr>
<tr><th id="403">403</th><td><u>#define	<dfn class="macro" id="_M/MR_MCLK" data-ref="_M/MR_MCLK">MR_MCLK</dfn>		0x04</u></td></tr>
<tr><th id="404">404</th><td><u>#define	<dfn class="macro" id="_M/MR_MDI" data-ref="_M/MR_MDI">MR_MDI</dfn>		0x02</u></td></tr>
<tr><th id="405">405</th><td><u>#define	<dfn class="macro" id="_M/MR_MDO" data-ref="_M/MR_MDO">MR_MDO</dfn>		0x01</u></td></tr>
<tr><th id="406">406</th><td></td></tr>
<tr><th id="407">407</th><td><u>#define	<dfn class="macro" id="_M/REVISION_REG_W" data-ref="_M/REVISION_REG_W">REVISION_REG_W</dfn>	0x0a	/* (hi: chip id low: rev #) */</u></td></tr>
<tr><th id="408">408</th><td><u>#define	<dfn class="macro" id="_M/RR_REV" data-ref="_M/RR_REV">RR_REV</dfn>(x)	((x) &amp; 0x0f)</u></td></tr>
<tr><th id="409">409</th><td><u>#define	<dfn class="macro" id="_M/RR_ID" data-ref="_M/RR_ID">RR_ID</dfn>(x)	(((x) &gt;&gt; 4) &amp; 0x0f)</u></td></tr>
<tr><th id="410">410</th><td></td></tr>
<tr><th id="411">411</th><td><u>#define	<dfn class="macro" id="_M/ERCV_REG_W" data-ref="_M/ERCV_REG_W">ERCV_REG_W</dfn>	0x0c</u></td></tr>
<tr><th id="412">412</th><td></td></tr>
<tr><th id="413">413</th><td><i>/*</i></td></tr>
<tr><th id="414">414</th><td><i> * These are constants expected to be found in the</i></td></tr>
<tr><th id="415">415</th><td><i> * chip id register.</i></td></tr>
<tr><th id="416">416</th><td><i> */</i></td></tr>
<tr><th id="417">417</th><td><u>#define	<dfn class="macro" id="_M/CHIP_9190" data-ref="_M/CHIP_9190">CHIP_9190</dfn>	3</u></td></tr>
<tr><th id="418">418</th><td><u>#define	<dfn class="macro" id="_M/CHIP_9194" data-ref="_M/CHIP_9194">CHIP_9194</dfn>	4</u></td></tr>
<tr><th id="419">419</th><td><u>#define	<dfn class="macro" id="_M/CHIP_9195" data-ref="_M/CHIP_9195">CHIP_9195</dfn>	5</u></td></tr>
<tr><th id="420">420</th><td><u>#define	<dfn class="macro" id="_M/CHIP_91100" data-ref="_M/CHIP_91100">CHIP_91100</dfn>	7</u></td></tr>
<tr><th id="421">421</th><td><u>#define	<dfn class="macro" id="_M/CHIP_91100FD" data-ref="_M/CHIP_91100FD">CHIP_91100FD</dfn>	8</u></td></tr>
<tr><th id="422">422</th><td><u>#define	<dfn class="macro" id="_M/CHIP_91C111" data-ref="_M/CHIP_91C111">CHIP_91C111</dfn>	9</u></td></tr>
<tr><th id="423">423</th><td></td></tr>
<tr><th id="424">424</th><td></td></tr>
<tr><th id="425">425</th><td><i>/*</i></td></tr>
<tr><th id="426">426</th><td><i> * When packets are stuffed into the card or sucked out of the card</i></td></tr>
<tr><th id="427">427</th><td><i> * they are set up more or less as follows:</i></td></tr>
<tr><th id="428">428</th><td><i> *</i></td></tr>
<tr><th id="429">429</th><td><i> * Addr msbyte   lsbyte</i></td></tr>
<tr><th id="430">430</th><td><i> * 00   SSSSSSSS SSSSSSSS - STATUS-WORD 16 bit TX or RX status</i></td></tr>
<tr><th id="431">431</th><td><i> * 02   RRRRR             - RESERVED (unused)</i></td></tr>
<tr><th id="432">432</th><td><i> * 02        CCC CCCCCCCC - BYTE COUNT (RX: always even, TX: bit 0 ignored)</i></td></tr>
<tr><th id="433">433</th><td><i> * 04   DDDDDDDD DDDDDDDD - DESTINATION ADDRESS</i></td></tr>
<tr><th id="434">434</th><td><i> * 06   DDDDDDDD DDDDDDDD        (48 bit Ethernet MAC Address)</i></td></tr>
<tr><th id="435">435</th><td><i> * 08   DDDDDDDD DDDDDDDD</i></td></tr>
<tr><th id="436">436</th><td><i> * 0A   SSSSSSSS SSSSSSSS - SOURCE ADDRESS</i></td></tr>
<tr><th id="437">437</th><td><i> * 0C   SSSSSSSS SSSSSSSS        (48 bit Ethernet MAC Address)</i></td></tr>
<tr><th id="438">438</th><td><i> * 0E   SSSSSSSS SSSSSSSS</i></td></tr>
<tr><th id="439">439</th><td><i> * 10   PPPPPPPP PPPPPPPP</i></td></tr>
<tr><th id="440">440</th><td><i> * ..   PPPPPPPP PPPPPPPP</i></td></tr>
<tr><th id="441">441</th><td><i> * C-2  CCCCCCCC          - CONTROL BYTE</i></td></tr>
<tr><th id="442">442</th><td><i> * C-2           PPPPPPPP - Last data byte (If odd length)</i></td></tr>
<tr><th id="443">443</th><td><i> *</i></td></tr>
<tr><th id="444">444</th><td><i> * The STATUS_WORD is derived from the EPH_STATUS_REG_W register</i></td></tr>
<tr><th id="445">445</th><td><i> * during transmit and is composed of another set of bits described</i></td></tr>
<tr><th id="446">446</th><td><i> * below during receive.</i></td></tr>
<tr><th id="447">447</th><td><i> */</i></td></tr>
<tr><th id="448">448</th><td></td></tr>
<tr><th id="449">449</th><td></td></tr>
<tr><th id="450">450</th><td><i>/*</i></td></tr>
<tr><th id="451">451</th><td><i> * Receive status bits.  These values are found in the status word</i></td></tr>
<tr><th id="452">452</th><td><i> * field of a received packet.  For receive packets I use the RS_ODDFRAME</i></td></tr>
<tr><th id="453">453</th><td><i> * to detect whether a frame has an extra byte on it.  The CTLB_ODD</i></td></tr>
<tr><th id="454">454</th><td><i> * bit of the control byte tells the same thing.</i></td></tr>
<tr><th id="455">455</th><td><i> */</i></td></tr>
<tr><th id="456">456</th><td><u>#define	<dfn class="macro" id="_M/RS_MULTICAST" data-ref="_M/RS_MULTICAST">RS_MULTICAST</dfn>	0x0001	/* Packet is multicast */</u></td></tr>
<tr><th id="457">457</th><td><u>#define	<dfn class="macro" id="_M/RS_HASH_MASK" data-ref="_M/RS_HASH_MASK">RS_HASH_MASK</dfn>	0x007e	/* Mask of multicast hash value */</u></td></tr>
<tr><th id="458">458</th><td><u>#define	<dfn class="macro" id="_M/RS_TOOSHORT" data-ref="_M/RS_TOOSHORT">RS_TOOSHORT</dfn>	0x0400	/* Frame was a runt, &lt;64 bytes */</u></td></tr>
<tr><th id="459">459</th><td><u>#define	<dfn class="macro" id="_M/RS_TOOLONG" data-ref="_M/RS_TOOLONG">RS_TOOLONG</dfn>	0x0800	/* Frame was giant, &gt;1518 */</u></td></tr>
<tr><th id="460">460</th><td><u>#define	<dfn class="macro" id="_M/RS_ODDFRAME" data-ref="_M/RS_ODDFRAME">RS_ODDFRAME</dfn>	0x1000	/* Frame is odd lengthed */</u></td></tr>
<tr><th id="461">461</th><td><u>#define	<dfn class="macro" id="_M/RS_BADCRC" data-ref="_M/RS_BADCRC">RS_BADCRC</dfn>	0x2000	/* Frame had CRC error */</u></td></tr>
<tr><th id="462">462</th><td><u>#define	<dfn class="macro" id="_M/RS_ALGNERR" data-ref="_M/RS_ALGNERR">RS_ALGNERR</dfn>	0x8000	/* Frame had alignment error */</u></td></tr>
<tr><th id="463">463</th><td><u>#define	<dfn class="macro" id="_M/RS_ERRORS" data-ref="_M/RS_ERRORS">RS_ERRORS</dfn>	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)</u></td></tr>
<tr><th id="464">464</th><td></td></tr>
<tr><th id="465">465</th><td><u>#define	<dfn class="macro" id="_M/RLEN_MASK" data-ref="_M/RLEN_MASK">RLEN_MASK</dfn>	0x07ff	/* Significant length bits in RX length */</u></td></tr>
<tr><th id="466">466</th><td></td></tr>
<tr><th id="467">467</th><td><i>/*</i></td></tr>
<tr><th id="468">468</th><td><i> * The control byte has the following significant bits.</i></td></tr>
<tr><th id="469">469</th><td><i> * For transmit, the CTLB_ODD bit specifies whether an extra byte</i></td></tr>
<tr><th id="470">470</th><td><i> * is present in the frame.  Bit 0 of the byte count field is</i></td></tr>
<tr><th id="471">471</th><td><i> * ignored.  I just pad every frame to even length and forget about</i></td></tr>
<tr><th id="472">472</th><td><i> * it.</i></td></tr>
<tr><th id="473">473</th><td><i> */</i></td></tr>
<tr><th id="474">474</th><td><u>#define	<dfn class="macro" id="_M/CTLB_CRC" data-ref="_M/CTLB_CRC">CTLB_CRC</dfn>	0x10	/* Add CRC for this packet (TX only) */</u></td></tr>
<tr><th id="475">475</th><td><u>#define	<dfn class="macro" id="_M/CTLB_ODD" data-ref="_M/CTLB_ODD">CTLB_ODD</dfn>	0x20	/* The packet length is ODD */</u></td></tr>
<tr><th id="476">476</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='smc91cxx.c.html'>netbsd/sys/dev/ic/smc91cxx.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
