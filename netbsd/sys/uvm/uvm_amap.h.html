<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>uvm_amap.h source code [netbsd/sys/uvm/uvm_amap.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="vm_amap "/>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/sys/uvm/uvm_amap.h'; var root_path = '../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../..'>netbsd</a>/<a href='..'>sys</a>/<a href='./'>uvm</a>/<a href='uvm_amap.h.html'>uvm_amap.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*	$NetBSD: uvm_amap.h,v 1.37 2011/06/12 03:36:02 rmind Exp $	*/</i></td></tr>
<tr><th id="2">2</th><td></td></tr>
<tr><th id="3">3</th><td><i>/*</i></td></tr>
<tr><th id="4">4</th><td><i> * Copyright (c) 1997 Charles D. Cranor and Washington University.</i></td></tr>
<tr><th id="5">5</th><td><i> * All rights reserved.</i></td></tr>
<tr><th id="6">6</th><td><i> *</i></td></tr>
<tr><th id="7">7</th><td><i> * Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="8">8</th><td><i> * modification, are permitted provided that the following conditions</i></td></tr>
<tr><th id="9">9</th><td><i> * are met:</i></td></tr>
<tr><th id="10">10</th><td><i> * 1. Redistributions of source code must retain the above copyright</i></td></tr>
<tr><th id="11">11</th><td><i> *    notice, this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="12">12</th><td><i> * 2. Redistributions in binary form must reproduce the above copyright</i></td></tr>
<tr><th id="13">13</th><td><i> *    notice, this list of conditions and the following disclaimer in the</i></td></tr>
<tr><th id="14">14</th><td><i> *    documentation and/or other materials provided with the distribution.</i></td></tr>
<tr><th id="15">15</th><td><i> *</i></td></tr>
<tr><th id="16">16</th><td><i> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR</i></td></tr>
<tr><th id="17">17</th><td><i> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</i></td></tr>
<tr><th id="18">18</th><td><i> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</i></td></tr>
<tr><th id="19">19</th><td><i> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</i></td></tr>
<tr><th id="20">20</th><td><i> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</i></td></tr>
<tr><th id="21">21</th><td><i> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</i></td></tr>
<tr><th id="22">22</th><td><i> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</i></td></tr>
<tr><th id="23">23</th><td><i> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</i></td></tr>
<tr><th id="24">24</th><td><i> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</i></td></tr>
<tr><th id="25">25</th><td><i> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</i></td></tr>
<tr><th id="26">26</th><td><i> */</i></td></tr>
<tr><th id="27">27</th><td></td></tr>
<tr><th id="28">28</th><td><u>#<span data-ppcond="28">ifndef</span> <span class="macro" data-ref="_M/_UVM_UVM_AMAP_H_">_UVM_UVM_AMAP_H_</span></u></td></tr>
<tr><th id="29">29</th><td><u>#define <dfn class="macro" id="_M/_UVM_UVM_AMAP_H_" data-ref="_M/_UVM_UVM_AMAP_H_">_UVM_UVM_AMAP_H_</dfn></u></td></tr>
<tr><th id="30">30</th><td></td></tr>
<tr><th id="31">31</th><td><i>/*</i></td></tr>
<tr><th id="32">32</th><td><i> * uvm_amap.h: general amap interface and amap implementation-specific info</i></td></tr>
<tr><th id="33">33</th><td><i> */</i></td></tr>
<tr><th id="34">34</th><td></td></tr>
<tr><th id="35">35</th><td><i>/*</i></td></tr>
<tr><th id="36">36</th><td><i> * an amap structure contains pointers to a set of anons that are</i></td></tr>
<tr><th id="37">37</th><td><i> * mapped together in virtual memory (an anon is a single page of</i></td></tr>
<tr><th id="38">38</th><td><i> * anonymous virtual memory -- see uvm_anon.h).  in uvm we hide the</i></td></tr>
<tr><th id="39">39</th><td><i> * details of the implementation of amaps behind a general amap</i></td></tr>
<tr><th id="40">40</th><td><i> * interface.  this allows us to change the amap implementation</i></td></tr>
<tr><th id="41">41</th><td><i> * without having to touch the rest of the code.  this file is divided</i></td></tr>
<tr><th id="42">42</th><td><i> * into two parts: the definition of the uvm amap interface and the</i></td></tr>
<tr><th id="43">43</th><td><i> * amap implementation-specific definitions.</i></td></tr>
<tr><th id="44">44</th><td><i> */</i></td></tr>
<tr><th id="45">45</th><td></td></tr>
<tr><th id="46">46</th><td><u>#<span data-ppcond="46">ifdef</span> <span class="macro" data-ref="_M/_KERNEL">_KERNEL</span></u></td></tr>
<tr><th id="47">47</th><td></td></tr>
<tr><th id="48">48</th><td><i>/*</i></td></tr>
<tr><th id="49">49</th><td><i> * part 1: amap interface</i></td></tr>
<tr><th id="50">50</th><td><i> */</i></td></tr>
<tr><th id="51">51</th><td></td></tr>
<tr><th id="52">52</th><td><em>void</em>	uvm_amap_init(<em>void</em>);</td></tr>
<tr><th id="53">53</th><td></td></tr>
<tr><th id="54">54</th><td><i>/*</i></td></tr>
<tr><th id="55">55</th><td><i> * forward definition of vm_amap structure.  only amap</i></td></tr>
<tr><th id="56">56</th><td><i> * implementation-specific code should directly access the fields of</i></td></tr>
<tr><th id="57">57</th><td><i> * this structure.</i></td></tr>
<tr><th id="58">58</th><td><i> */</i></td></tr>
<tr><th id="59">59</th><td></td></tr>
<tr><th id="60">60</th><td><b>struct</b> vm_amap;</td></tr>
<tr><th id="61">61</th><td></td></tr>
<tr><th id="62">62</th><td></td></tr>
<tr><th id="63">63</th><td><i>/*</i></td></tr>
<tr><th id="64">64</th><td><i> * prototypes for the amap interface</i></td></tr>
<tr><th id="65">65</th><td><i> */</i></td></tr>
<tr><th id="66">66</th><td></td></tr>
<tr><th id="67">67</th><td><em>void</em>		amap_add 	<i>/* add an anon to an amap */</i></td></tr>
<tr><th id="68">68</th><td>			(<b>struct</b> vm_aref *, vaddr_t,</td></tr>
<tr><th id="69">69</th><td>			 <b>struct</b> vm_anon *, bool);</td></tr>
<tr><th id="70">70</th><td><b>struct</b> vm_amap	*amap_alloc	<i>/* allocate a new amap */</i></td></tr>
<tr><th id="71">71</th><td>			(vaddr_t, vaddr_t, <em>int</em>);</td></tr>
<tr><th id="72">72</th><td><em>void</em>		amap_copy	<i>/* clear amap needs-copy flag */</i></td></tr>
<tr><th id="73">73</th><td>			(<b>struct</b> vm_map *, <b>struct</b> vm_map_entry *, <em>int</em>,</td></tr>
<tr><th id="74">74</th><td>			 vaddr_t, vaddr_t);</td></tr>
<tr><th id="75">75</th><td><em>void</em>		amap_cow_now	<i>/* resolve all COW faults now */</i></td></tr>
<tr><th id="76">76</th><td>			(<b>struct</b> vm_map *, <b>struct</b> vm_map_entry *);</td></tr>
<tr><th id="77">77</th><td><em>int</em>		amap_extend	<i>/* make amap larger */</i></td></tr>
<tr><th id="78">78</th><td>			(<b>struct</b> vm_map_entry *, vsize_t, <em>int</em>);</td></tr>
<tr><th id="79">79</th><td><em>int</em>		amap_flags	<i>/* get amap's flags */</i></td></tr>
<tr><th id="80">80</th><td>			(<b>struct</b> vm_amap *);</td></tr>
<tr><th id="81">81</th><td><em>void</em>		amap_free	<i>/* free amap */</i></td></tr>
<tr><th id="82">82</th><td>			(<b>struct</b> vm_amap *);</td></tr>
<tr><th id="83">83</th><td><em>void</em>		amap_lock	<i>/* lock amap */</i></td></tr>
<tr><th id="84">84</th><td>			(<b>struct</b> vm_amap *);</td></tr>
<tr><th id="85">85</th><td><b>struct</b> vm_anon	*amap_lookup	<i>/* lookup an anon @ offset in amap */</i></td></tr>
<tr><th id="86">86</th><td>			(<b>struct</b> vm_aref *, vaddr_t);</td></tr>
<tr><th id="87">87</th><td><em>void</em>		amap_lookups	<i>/* lookup multiple anons */</i></td></tr>
<tr><th id="88">88</th><td>			(<b>struct</b> vm_aref *, vaddr_t,</td></tr>
<tr><th id="89">89</th><td>			 <b>struct</b> vm_anon **, <em>int</em>);</td></tr>
<tr><th id="90">90</th><td><em>void</em>		amap_ref	<i>/* add a reference to an amap */</i></td></tr>
<tr><th id="91">91</th><td>			(<b>struct</b> vm_amap *, vaddr_t, vsize_t, <em>int</em>);</td></tr>
<tr><th id="92">92</th><td><em>int</em>		amap_refs	<i>/* get number of references of amap */</i></td></tr>
<tr><th id="93">93</th><td>			(<b>struct</b> vm_amap *);</td></tr>
<tr><th id="94">94</th><td><em>void</em>		amap_share_protect <i>/* protect pages in a shared amap */</i></td></tr>
<tr><th id="95">95</th><td>			(<b>struct</b> vm_map_entry *, vm_prot_t);</td></tr>
<tr><th id="96">96</th><td><em>void</em>		amap_splitref	<i>/* split reference to amap into two */</i></td></tr>
<tr><th id="97">97</th><td>			(<b>struct</b> vm_aref *, <b>struct</b> vm_aref *, vaddr_t);</td></tr>
<tr><th id="98">98</th><td><em>void</em>		amap_unadd	<i>/* remove an anon from an amap */</i></td></tr>
<tr><th id="99">99</th><td>			(<b>struct</b> vm_aref *, vaddr_t);</td></tr>
<tr><th id="100">100</th><td><em>void</em>		amap_unlock	<i>/* unlock amap */</i></td></tr>
<tr><th id="101">101</th><td>			(<b>struct</b> vm_amap *);</td></tr>
<tr><th id="102">102</th><td><em>void</em>		amap_unref	<i>/* drop reference to an amap */</i></td></tr>
<tr><th id="103">103</th><td>			(<b>struct</b> vm_amap *, vaddr_t, vsize_t, bool);</td></tr>
<tr><th id="104">104</th><td><em>void</em>		amap_wipeout	<i>/* remove all anons from amap */</i></td></tr>
<tr><th id="105">105</th><td>			(<b>struct</b> vm_amap *);</td></tr>
<tr><th id="106">106</th><td>bool		amap_swap_off</td></tr>
<tr><th id="107">107</th><td>			(<em>int</em>, <em>int</em>);</td></tr>
<tr><th id="108">108</th><td></td></tr>
<tr><th id="109">109</th><td><i>/*</i></td></tr>
<tr><th id="110">110</th><td><i> * amap flag values</i></td></tr>
<tr><th id="111">111</th><td><i> */</i></td></tr>
<tr><th id="112">112</th><td></td></tr>
<tr><th id="113">113</th><td><u>#define AMAP_SHARED	0x1	/* amap is shared */</u></td></tr>
<tr><th id="114">114</th><td><u>#define AMAP_REFALL	0x2	/* amap_ref: reference entire amap */</u></td></tr>
<tr><th id="115">115</th><td><u>#define AMAP_SWAPOFF	0x4	/* amap_swap_off() is in progress */</u></td></tr>
<tr><th id="116">116</th><td></td></tr>
<tr><th id="117">117</th><td><i>/*</i></td></tr>
<tr><th id="118">118</th><td><i> * amap_copy flags</i></td></tr>
<tr><th id="119">119</th><td><i> */</i></td></tr>
<tr><th id="120">120</th><td></td></tr>
<tr><th id="121">121</th><td><u>#define	AMAP_COPY_NOWAIT	0x02	/* not allowed to sleep */</u></td></tr>
<tr><th id="122">122</th><td><u>#define	AMAP_COPY_NOCHUNK	0x04	/* not allowed to chunk */</u></td></tr>
<tr><th id="123">123</th><td><u>#define	AMAP_COPY_NOMERGE	0x08	/* not allowed to merge */</u></td></tr>
<tr><th id="124">124</th><td></td></tr>
<tr><th id="125">125</th><td><i>/*</i></td></tr>
<tr><th id="126">126</th><td><i> * amap_extend flags</i></td></tr>
<tr><th id="127">127</th><td><i> */</i></td></tr>
<tr><th id="128">128</th><td><u>#define AMAP_EXTEND_BACKWARDS	0x00	/* add "size" to start of map */</u></td></tr>
<tr><th id="129">129</th><td><u>#define AMAP_EXTEND_FORWARDS	0x01	/* add "size" to end of map */</u></td></tr>
<tr><th id="130">130</th><td><u>#define AMAP_EXTEND_NOWAIT	0x02	/* not allowed to sleep */</u></td></tr>
<tr><th id="131">131</th><td></td></tr>
<tr><th id="132">132</th><td><u>#<span data-ppcond="46">endif</span> /* _KERNEL */</u></td></tr>
<tr><th id="133">133</th><td></td></tr>
<tr><th id="134">134</th><td><i>/**********************************************************************/</i></td></tr>
<tr><th id="135">135</th><td></td></tr>
<tr><th id="136">136</th><td><i>/*</i></td></tr>
<tr><th id="137">137</th><td><i> * part 2: amap implementation-specific info</i></td></tr>
<tr><th id="138">138</th><td><i> */</i></td></tr>
<tr><th id="139">139</th><td></td></tr>
<tr><th id="140">140</th><td><i>/*</i></td></tr>
<tr><th id="141">141</th><td><i> * we currently provide an array-based amap implementation.  in this</i></td></tr>
<tr><th id="142">142</th><td><i> * implementation we provide the option of tracking split references</i></td></tr>
<tr><th id="143">143</th><td><i> * so that we don't lose track of references during partial unmaps</i></td></tr>
<tr><th id="144">144</th><td><i> * ... this is enabled with the "UVM_AMAP_PPREF" define.</i></td></tr>
<tr><th id="145">145</th><td><i> */</i></td></tr>
<tr><th id="146">146</th><td></td></tr>
<tr><th id="147">147</th><td><u>#define <dfn class="macro" id="_M/UVM_AMAP_PPREF" data-ref="_M/UVM_AMAP_PPREF">UVM_AMAP_PPREF</dfn>		/* track partial references */</u></td></tr>
<tr><th id="148">148</th><td></td></tr>
<tr><th id="149">149</th><td><i>/*</i></td></tr>
<tr><th id="150">150</th><td><i> * here is the definition of the vm_amap structure for this implementation.</i></td></tr>
<tr><th id="151">151</th><td><i> */</i></td></tr>
<tr><th id="152">152</th><td></td></tr>
<tr><th id="153">153</th><td><b>struct</b> <dfn class="type def" id="vm_amap" title='vm_amap' data-ref="vm_amap" data-ref-filename="vm_amap">vm_amap</dfn> {</td></tr>
<tr><th id="154">154</th><td>	<a class="typedef" href="../sys/mutex.h.html#kmutex_t" title='kmutex_t' data-type='struct kmutex' data-ref="kmutex_t" data-ref-filename="kmutex_t">kmutex_t</a> *<dfn class="decl field" id="vm_amap::am_lock" title='vm_amap::am_lock' data-ref="vm_amap::am_lock" data-ref-filename="vm_amap..am_lock">am_lock</dfn>;	<i>/* lock [locks all vm_amap fields] */</i></td></tr>
<tr><th id="155">155</th><td>	<em>int</em> <dfn class="decl field" id="vm_amap::am_ref" title='vm_amap::am_ref' data-ref="vm_amap::am_ref" data-ref-filename="vm_amap..am_ref">am_ref</dfn>;		<i>/* reference count */</i></td></tr>
<tr><th id="156">156</th><td>	<em>int</em> <dfn class="decl field" id="vm_amap::am_flags" title='vm_amap::am_flags' data-ref="vm_amap::am_flags" data-ref-filename="vm_amap..am_flags">am_flags</dfn>;		<i>/* flags */</i></td></tr>
<tr><th id="157">157</th><td>	<em>int</em> <dfn class="decl field" id="vm_amap::am_maxslot" title='vm_amap::am_maxslot' data-ref="vm_amap::am_maxslot" data-ref-filename="vm_amap..am_maxslot">am_maxslot</dfn>;		<i>/* max # of slots allocated */</i></td></tr>
<tr><th id="158">158</th><td>	<em>int</em> <dfn class="decl field" id="vm_amap::am_nslot" title='vm_amap::am_nslot' data-ref="vm_amap::am_nslot" data-ref-filename="vm_amap..am_nslot">am_nslot</dfn>;		<i>/* # of slots currently in map ( &lt;= maxslot) */</i></td></tr>
<tr><th id="159">159</th><td>	<em>int</em> <dfn class="decl field" id="vm_amap::am_nused" title='vm_amap::am_nused' data-ref="vm_amap::am_nused" data-ref-filename="vm_amap..am_nused">am_nused</dfn>;		<i>/* # of slots currently in use */</i></td></tr>
<tr><th id="160">160</th><td>	<em>int</em> *<dfn class="decl field" id="vm_amap::am_slots" title='vm_amap::am_slots' data-ref="vm_amap::am_slots" data-ref-filename="vm_amap..am_slots">am_slots</dfn>;		<i>/* contig array of active slots */</i></td></tr>
<tr><th id="161">161</th><td>	<em>int</em> *<dfn class="decl field" id="vm_amap::am_bckptr" title='vm_amap::am_bckptr' data-ref="vm_amap::am_bckptr" data-ref-filename="vm_amap..am_bckptr">am_bckptr</dfn>;		<i>/* back pointer array to am_slots */</i></td></tr>
<tr><th id="162">162</th><td>	<b>struct</b> <a class="type" href="uvm_anon.h.html#vm_anon" title='vm_anon' data-ref="vm_anon" data-ref-filename="vm_anon">vm_anon</a> **<dfn class="decl field" id="vm_amap::am_anon" title='vm_amap::am_anon' data-ref="vm_amap::am_anon" data-ref-filename="vm_amap..am_anon">am_anon</dfn>; <i>/* array of anonymous pages */</i></td></tr>
<tr><th id="163">163</th><td><u>#<span data-ppcond="163">ifdef</span> <a class="macro" href="#147" data-ref="_M/UVM_AMAP_PPREF">UVM_AMAP_PPREF</a></u></td></tr>
<tr><th id="164">164</th><td>	<em>int</em> *<dfn class="decl field" id="vm_amap::am_ppref" title='vm_amap::am_ppref' data-ref="vm_amap::am_ppref" data-ref-filename="vm_amap..am_ppref">am_ppref</dfn>;		<i>/* per page reference count (if !NULL) */</i></td></tr>
<tr><th id="165">165</th><td><u>#<span data-ppcond="163">endif</span></u></td></tr>
<tr><th id="166">166</th><td>	<a class="macro" href="../sys/queue.h.html#196" title="struct { struct vm_amap *le_next; struct vm_amap **le_prev; }" data-ref="_M/LIST_ENTRY">LIST_ENTRY</a>(<a class="type" href="#vm_amap" title='vm_amap' data-ref="vm_amap" data-ref-filename="vm_amap">vm_amap</a>) <dfn class="decl field" id="vm_amap::am_list" title='vm_amap::am_list' data-ref="vm_amap::am_list" data-ref-filename="vm_amap..am_list">am_list</dfn>;</td></tr>
<tr><th id="167">167</th><td>};</td></tr>
<tr><th id="168">168</th><td></td></tr>
<tr><th id="169">169</th><td><i>/*</i></td></tr>
<tr><th id="170">170</th><td><i> * note that am_slots, am_bckptr, and am_anon are arrays.   this allows</i></td></tr>
<tr><th id="171">171</th><td><i> * fast lookup of pages based on their virual address at the expense of</i></td></tr>
<tr><th id="172">172</th><td><i> * some extra memory.   in the future we should be smarter about memory</i></td></tr>
<tr><th id="173">173</th><td><i> * usage and fall back to a non-array based implementation on systems</i></td></tr>
<tr><th id="174">174</th><td><i> * that are short of memory (XXXCDC).</i></td></tr>
<tr><th id="175">175</th><td><i> *</i></td></tr>
<tr><th id="176">176</th><td><i> * the entries in the array are called slots... for example an amap that</i></td></tr>
<tr><th id="177">177</th><td><i> * covers four pages of virtual memory is said to have four slots.   here</i></td></tr>
<tr><th id="178">178</th><td><i> * is an example of the array usage for a four slot amap.   note that only</i></td></tr>
<tr><th id="179">179</th><td><i> * slots one and three have anons assigned to them.  "D/C" means that we</i></td></tr>
<tr><th id="180">180</th><td><i> * "don't care" about the value.</i></td></tr>
<tr><th id="181">181</th><td><i> *</i></td></tr>
<tr><th id="182">182</th><td><i> *            0     1      2     3</i></td></tr>
<tr><th id="183">183</th><td><i> * am_anon:   NULL, anon0, NULL, anon1		(actual pointers to anons)</i></td></tr>
<tr><th id="184">184</th><td><i> * am_bckptr: D/C,  1,     D/C,  0		(points to am_slots entry)</i></td></tr>
<tr><th id="185">185</th><td><i> *</i></td></tr>
<tr><th id="186">186</th><td><i> * am_slots:  3, 1, D/C, D/C    		(says slots 3 and 1 are in use)</i></td></tr>
<tr><th id="187">187</th><td><i> *</i></td></tr>
<tr><th id="188">188</th><td><i> * note that am_bckptr is D/C if the slot in am_anon is set to NULL.</i></td></tr>
<tr><th id="189">189</th><td><i> * to find the entry in am_slots for an anon, look at am_bckptr[slot],</i></td></tr>
<tr><th id="190">190</th><td><i> * thus the entry for slot 3 in am_slots[] is at am_slots[am_bckptr[3]].</i></td></tr>
<tr><th id="191">191</th><td><i> * in general, if am_anon[X] is non-NULL, then the following must be</i></td></tr>
<tr><th id="192">192</th><td><i> * true: am_slots[am_bckptr[X]] == X</i></td></tr>
<tr><th id="193">193</th><td><i> *</i></td></tr>
<tr><th id="194">194</th><td><i> * note that am_slots is always contig-packed.</i></td></tr>
<tr><th id="195">195</th><td><i> */</i></td></tr>
<tr><th id="196">196</th><td></td></tr>
<tr><th id="197">197</th><td><i>/*</i></td></tr>
<tr><th id="198">198</th><td><i> * defines for handling of large, sparse amaps:</i></td></tr>
<tr><th id="199">199</th><td><i> *</i></td></tr>
<tr><th id="200">200</th><td><i> * one of the problems of array-based amaps is that if you allocate a</i></td></tr>
<tr><th id="201">201</th><td><i> * large, sparsely-used area of virtual memory you end up allocating</i></td></tr>
<tr><th id="202">202</th><td><i> * large arrays that, for the most part, don't get used.  this is a</i></td></tr>
<tr><th id="203">203</th><td><i> * problem for BSD in that the kernel likes to make these types of</i></td></tr>
<tr><th id="204">204</th><td><i> * allocations to "reserve" memory for possible future use.</i></td></tr>
<tr><th id="205">205</th><td><i> *</i></td></tr>
<tr><th id="206">206</th><td><i> * for example, the kernel allocates (reserves) a large chunk of user</i></td></tr>
<tr><th id="207">207</th><td><i> * VM for possible stack growth.  most of the time only a page or two</i></td></tr>
<tr><th id="208">208</th><td><i> * of this VM is actually used.  since the stack is anonymous memory</i></td></tr>
<tr><th id="209">209</th><td><i> * it makes sense for it to live in an amap, but if we allocated an</i></td></tr>
<tr><th id="210">210</th><td><i> * amap for the entire stack range we could end up wasting a large</i></td></tr>
<tr><th id="211">211</th><td><i> * amount of allocated KVM.</i></td></tr>
<tr><th id="212">212</th><td><i> *</i></td></tr>
<tr><th id="213">213</th><td><i> * for example, on the i386 at boot time we allocate two amaps for the stack</i></td></tr>
<tr><th id="214">214</th><td><i> * of /sbin/init:</i></td></tr>
<tr><th id="215">215</th><td><i> *  1. a 7680 slot amap at protection 0 (reserve space for stack)</i></td></tr>
<tr><th id="216">216</th><td><i> *  2. a 512 slot amap at protection 7 (top of stack)</i></td></tr>
<tr><th id="217">217</th><td><i> *</i></td></tr>
<tr><th id="218">218</th><td><i> * most of the array allocated for the amaps for this is never used.</i></td></tr>
<tr><th id="219">219</th><td><i> * the amap interface provides a way for us to avoid this problem by</i></td></tr>
<tr><th id="220">220</th><td><i> * allowing amap_copy() to break larger amaps up into smaller sized</i></td></tr>
<tr><th id="221">221</th><td><i> * chunks (controlled by the "canchunk" option).   we use this feature</i></td></tr>
<tr><th id="222">222</th><td><i> * to reduce our memory usage with the BSD stack management.  if we</i></td></tr>
<tr><th id="223">223</th><td><i> * are asked to create an amap with more than UVM_AMAP_LARGE slots in it,</i></td></tr>
<tr><th id="224">224</th><td><i> * we attempt to break it up into a UVM_AMAP_CHUNK sized amap if the</i></td></tr>
<tr><th id="225">225</th><td><i> * "canchunk" flag is set.</i></td></tr>
<tr><th id="226">226</th><td><i> *</i></td></tr>
<tr><th id="227">227</th><td><i> * so, in the i386 example, the 7680 slot area is never referenced so</i></td></tr>
<tr><th id="228">228</th><td><i> * nothing gets allocated (amap_copy is never called because the protection</i></td></tr>
<tr><th id="229">229</th><td><i> * is zero).   the 512 slot area for the top of the stack is referenced.</i></td></tr>
<tr><th id="230">230</th><td><i> * the chunking code breaks it up into 16 slot chunks (hopefully a single</i></td></tr>
<tr><th id="231">231</th><td><i> * 16 slot chunk is enough to handle the whole stack).</i></td></tr>
<tr><th id="232">232</th><td><i> */</i></td></tr>
<tr><th id="233">233</th><td></td></tr>
<tr><th id="234">234</th><td><u>#define <dfn class="macro" id="_M/UVM_AMAP_LARGE" data-ref="_M/UVM_AMAP_LARGE">UVM_AMAP_LARGE</dfn>	256	/* # of slots in "large" amap */</u></td></tr>
<tr><th id="235">235</th><td><u>#define <dfn class="macro" id="_M/UVM_AMAP_CHUNK" data-ref="_M/UVM_AMAP_CHUNK">UVM_AMAP_CHUNK</dfn>	16	/* # of slots to chunk large amaps in */</u></td></tr>
<tr><th id="236">236</th><td></td></tr>
<tr><th id="237">237</th><td><u>#<span data-ppcond="237">ifdef</span> <span class="macro" data-ref="_M/_KERNEL">_KERNEL</span></u></td></tr>
<tr><th id="238">238</th><td></td></tr>
<tr><th id="239">239</th><td><i>/*</i></td></tr>
<tr><th id="240">240</th><td><i> * macros</i></td></tr>
<tr><th id="241">241</th><td><i> */</i></td></tr>
<tr><th id="242">242</th><td></td></tr>
<tr><th id="243">243</th><td><i>/* AMAP_B2SLOT: convert byte offset to slot */</i></td></tr>
<tr><th id="244">244</th><td><u>#define AMAP_B2SLOT(S,B) {						\</u></td></tr>
<tr><th id="245">245</th><td><u>	KASSERT(((B) &amp; (PAGE_SIZE - 1)) == 0);				\</u></td></tr>
<tr><th id="246">246</th><td><u>	(S) = (B) &gt;&gt; PAGE_SHIFT;					\</u></td></tr>
<tr><th id="247">247</th><td><u>}</u></td></tr>
<tr><th id="248">248</th><td></td></tr>
<tr><th id="249">249</th><td><i>/*</i></td></tr>
<tr><th id="250">250</th><td><i> * lock/unlock/refs/flags macros</i></td></tr>
<tr><th id="251">251</th><td><i> */</i></td></tr>
<tr><th id="252">252</th><td></td></tr>
<tr><th id="253">253</th><td><u>#define amap_flags(AMAP)	((AMAP)-&gt;am_flags)</u></td></tr>
<tr><th id="254">254</th><td><u>#define amap_lock(AMAP)		mutex_enter((AMAP)-&gt;am_lock)</u></td></tr>
<tr><th id="255">255</th><td><u>#define amap_lock_try(AMAP)	mutex_tryenter((AMAP)-&gt;am_lock)</u></td></tr>
<tr><th id="256">256</th><td><u>#define amap_refs(AMAP)		((AMAP)-&gt;am_ref)</u></td></tr>
<tr><th id="257">257</th><td><u>#define amap_unlock(AMAP)	mutex_exit((AMAP)-&gt;am_lock)</u></td></tr>
<tr><th id="258">258</th><td></td></tr>
<tr><th id="259">259</th><td><i>/*</i></td></tr>
<tr><th id="260">260</th><td><i> * if we enable PPREF, then we have a couple of extra functions that</i></td></tr>
<tr><th id="261">261</th><td><i> * we need to prototype here...</i></td></tr>
<tr><th id="262">262</th><td><i> */</i></td></tr>
<tr><th id="263">263</th><td></td></tr>
<tr><th id="264">264</th><td><u>#ifdef UVM_AMAP_PPREF</u></td></tr>
<tr><th id="265">265</th><td></td></tr>
<tr><th id="266">266</th><td><u>#define PPREF_NONE ((int *) -1)	/* not using ppref */</u></td></tr>
<tr><th id="267">267</th><td></td></tr>
<tr><th id="268">268</th><td><em>void</em>		amap_pp_adjref		<i>/* adjust references */</i></td></tr>
<tr><th id="269">269</th><td>			(<b>struct</b> vm_amap *, <em>int</em>, vsize_t, <em>int</em>,</td></tr>
<tr><th id="270">270</th><td>			<b>struct</b> vm_anon **);</td></tr>
<tr><th id="271">271</th><td><em>void</em>		amap_pp_establish	<i>/* establish ppref */</i></td></tr>
<tr><th id="272">272</th><td>			(<b>struct</b> vm_amap *, vaddr_t);</td></tr>
<tr><th id="273">273</th><td><em>void</em>		amap_wiperange		<i>/* wipe part of an amap */</i></td></tr>
<tr><th id="274">274</th><td>			(<b>struct</b> vm_amap *, <em>int</em>, <em>int</em>, <b>struct</b> vm_anon **);</td></tr>
<tr><th id="275">275</th><td><u>#endif	/* UVM_AMAP_PPREF */</u></td></tr>
<tr><th id="276">276</th><td></td></tr>
<tr><th id="277">277</th><td><u>#<span data-ppcond="237">endif</span> /* _KERNEL */</u></td></tr>
<tr><th id="278">278</th><td></td></tr>
<tr><th id="279">279</th><td><u>#<span data-ppcond="28">endif</span> /* _UVM_UVM_AMAP_H_ */</u></td></tr>
<tr><th id="280">280</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../lib/libkvm/kvm_proc.c.html'>netbsd/lib/libkvm/kvm_proc.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
