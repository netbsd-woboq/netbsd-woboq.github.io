<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>t_ro.c source code [netbsd/tests/fs/vfs/t_ro.c] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/tests/fs/vfs/t_ro.c'; var root_path = '../../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../..'>netbsd</a>/<a href='../..'>tests</a>/<a href='..'>fs</a>/<a href='./'>vfs</a>/<a href='t_ro.c.html'>t_ro.c</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*	$NetBSD: t_ro.c,v 1.7 2019/07/16 17:29:17 martin Exp $	*/</i></td></tr>
<tr><th id="2">2</th><td></td></tr>
<tr><th id="3">3</th><td><i>/*-</i></td></tr>
<tr><th id="4">4</th><td><i> * Copyright (c) 2010 The NetBSD Foundation, Inc.</i></td></tr>
<tr><th id="5">5</th><td><i> * All rights reserved.</i></td></tr>
<tr><th id="6">6</th><td><i> *</i></td></tr>
<tr><th id="7">7</th><td><i> * Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="8">8</th><td><i> * modification, are permitted provided that the following conditions</i></td></tr>
<tr><th id="9">9</th><td><i> * are met:</i></td></tr>
<tr><th id="10">10</th><td><i> * 1. Redistributions of source code must retain the above copyright</i></td></tr>
<tr><th id="11">11</th><td><i> *    notice, this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="12">12</th><td><i> * 2. Redistributions in binary form must reproduce the above copyright</i></td></tr>
<tr><th id="13">13</th><td><i> *    notice, this list of conditions and the following disclaimer in the</i></td></tr>
<tr><th id="14">14</th><td><i> *    documentation and/or other materials provided with the distribution.</i></td></tr>
<tr><th id="15">15</th><td><i> *</i></td></tr>
<tr><th id="16">16</th><td><i> * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS</i></td></tr>
<tr><th id="17">17</th><td><i> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</i></td></tr>
<tr><th id="18">18</th><td><i> * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</i></td></tr>
<tr><th id="19">19</th><td><i> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS</i></td></tr>
<tr><th id="20">20</th><td><i> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</i></td></tr>
<tr><th id="21">21</th><td><i> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</i></td></tr>
<tr><th id="22">22</th><td><i> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</i></td></tr>
<tr><th id="23">23</th><td><i> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</i></td></tr>
<tr><th id="24">24</th><td><i> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</i></td></tr>
<tr><th id="25">25</th><td><i> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</i></td></tr>
<tr><th id="26">26</th><td><i> * POSSIBILITY OF SUCH DAMAGE.</i></td></tr>
<tr><th id="27">27</th><td><i> */</i></td></tr>
<tr><th id="28">28</th><td></td></tr>
<tr><th id="29">29</th><td><u>#include <a href="../../../objdir.amd64/destdir.amd64/usr/include/sys/stat.h.html">&lt;sys/stat.h&gt;</a></u></td></tr>
<tr><th id="30">30</th><td><u>#include <a href="../../../objdir.amd64/destdir.amd64/usr/include/sys/statvfs.h.html">&lt;sys/statvfs.h&gt;</a></u></td></tr>
<tr><th id="31">31</th><td></td></tr>
<tr><th id="32">32</th><td><u>#include <a href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c.h.html">&lt;atf-c.h&gt;</a></u></td></tr>
<tr><th id="33">33</th><td><u>#include <a href="../../../objdir.amd64/destdir.amd64/usr/include/sys/fcntl.h.html">&lt;fcntl.h&gt;</a></u></td></tr>
<tr><th id="34">34</th><td><u>#include <a href="../../../objdir.amd64/destdir.amd64/usr/include/libgen.h.html">&lt;libgen.h&gt;</a></u></td></tr>
<tr><th id="35">35</th><td><u>#include <a href="../../../objdir.amd64/destdir.amd64/usr/include/stdlib.h.html">&lt;stdlib.h&gt;</a></u></td></tr>
<tr><th id="36">36</th><td><u>#include <a href="../../../objdir.amd64/destdir.amd64/usr/include/unistd.h.html">&lt;unistd.h&gt;</a></u></td></tr>
<tr><th id="37">37</th><td></td></tr>
<tr><th id="38">38</th><td><u>#include <a href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html">&lt;rump/rump_syscalls.h&gt;</a></u></td></tr>
<tr><th id="39">39</th><td><u>#include <a href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump.h.html">&lt;rump/rump.h&gt;</a></u></td></tr>
<tr><th id="40">40</th><td></td></tr>
<tr><th id="41">41</th><td><u>#include <a href="../common/h_fsmacros.h.html">"../common/h_fsmacros.h"</a></u></td></tr>
<tr><th id="42">42</th><td><u>#include <a href="../../h_macros.h.html">"h_macros.h"</a></u></td></tr>
<tr><th id="43">43</th><td></td></tr>
<tr><th id="44">44</th><td><u>#define <dfn class="macro" id="_M/AFILE" data-ref="_M/AFILE">AFILE</dfn> "testfile"</u></td></tr>
<tr><th id="45">45</th><td><u>#define <dfn class="macro" id="_M/ADIR" data-ref="_M/ADIR">ADIR</dfn> "testdir"</u></td></tr>
<tr><th id="46">46</th><td><u>#define <dfn class="macro" id="_M/AFIFO" data-ref="_M/AFIFO">AFIFO</dfn> "testfifo"</u></td></tr>
<tr><th id="47">47</th><td><u>#define <dfn class="macro" id="_M/ASYMLINK" data-ref="_M/ASYMLINK">ASYMLINK</dfn> "testsymlink"</u></td></tr>
<tr><th id="48">48</th><td><u>#define <dfn class="macro" id="_M/ALINK" data-ref="_M/ALINK">ALINK</dfn> "testlink"</u></td></tr>
<tr><th id="49">49</th><td><u>#define <dfn class="macro" id="_M/FUNTEXT" data-ref="_M/FUNTEXT">FUNTEXT</dfn> "this is some non-humppa text"</u></td></tr>
<tr><th id="50">50</th><td><u>#define <dfn class="macro" id="_M/FUNSIZE" data-ref="_M/FUNSIZE">FUNSIZE</dfn> (sizeof(FUNTEXT)-1)</u></td></tr>
<tr><th id="51">51</th><td></td></tr>
<tr><th id="52">52</th><td><em>static</em> <em>void</em></td></tr>
<tr><th id="53">53</th><td><dfn class="tu decl def fn" id="nullgen" title='nullgen' data-type='void nullgen(const atf_tc_t * tc, const char * mp)' data-ref="nullgen" data-ref-filename="nullgen">nullgen</dfn>(<em>const</em> <a class="typedef" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/tc.h.html#atf_tc_t" title='atf_tc_t' data-type='struct atf_tc' data-ref="atf_tc_t" data-ref-filename="atf_tc_t">atf_tc_t</a> *<dfn class="local col1 decl" id="1tc" title='tc' data-type='const atf_tc_t *' data-ref="1tc" data-ref-filename="1tc">tc</dfn>, <em>const</em> <em>char</em> *<dfn class="local col2 decl" id="2mp" title='mp' data-type='const char *' data-ref="2mp" data-ref-filename="2mp">mp</dfn>)</td></tr>
<tr><th id="54">54</th><td>{</td></tr>
<tr><th id="55">55</th><td></td></tr>
<tr><th id="56">56</th><td>	<b>return</b>;</td></tr>
<tr><th id="57">57</th><td>}</td></tr>
<tr><th id="58">58</th><td></td></tr>
<tr><th id="59">59</th><td><em>static</em> <em>void</em></td></tr>
<tr><th id="60">60</th><td><dfn class="tu decl def fn" id="filegen" title='filegen' data-type='void filegen(const atf_tc_t * tc, const char * mp)' data-ref="filegen" data-ref-filename="filegen">filegen</dfn>(<em>const</em> <a class="typedef" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/tc.h.html#atf_tc_t" title='atf_tc_t' data-type='struct atf_tc' data-ref="atf_tc_t" data-ref-filename="atf_tc_t">atf_tc_t</a> *<dfn class="local col3 decl" id="3tc" title='tc' data-type='const atf_tc_t *' data-ref="3tc" data-ref-filename="3tc">tc</dfn>, <em>const</em> <em>char</em> *<dfn class="local col4 decl" id="4mp" title='mp' data-type='const char *' data-ref="4mp" data-ref-filename="4mp">mp</dfn>)</td></tr>
<tr><th id="61">61</th><td>{</td></tr>
<tr><th id="62">62</th><td>	<em>int</em> <dfn class="local col5 decl" id="5fd" title='fd' data-type='int' data-ref="5fd" data-ref-filename="5fd">fd</dfn>;</td></tr>
<tr><th id="63">63</th><td></td></tr>
<tr><th id="64">64</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#293" title="if (rump_sys_chdir(&quot;/mnt&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd into test mount&quot;)" data-ref="_M/FSTEST_ENTER">FSTEST_ENTER</a>();</td></tr>
<tr><th id="65">65</th><td>	<a class="macro" href="../../h_macros.h.html#47" title="do { if (!((fd = rump_sys_open(&quot;testfile&quot;, 0x00000200 | 0x00000002, 0777)) != (-1))) atf_tc_fail_requirement(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 65, &quot;%s: %s&quot;, &quot;fd = rump_sys_open(\&quot;testfile\&quot;, 0x00000200 | 0x00000002, 0777)&quot;, strerror((*__errno()))); } while(0)" data-ref="_M/RL">RL</a>(<a class="local col5 ref" href="#5fd" title='fd' data-ref="5fd" data-ref-filename="5fd">fd</a> = <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_open" title='rump_sys_open' data-ref="rump___sysimpl_open" data-ref-filename="rump___sysimpl_open">rump_sys_open</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, <a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/fcntl.h.html#97" title="0x00000200" data-ref="_M/O_CREAT">O_CREAT</a> | <a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/fcntl.h.html#66" title="0x00000002" data-ref="_M/O_RDWR">O_RDWR</a>, <var>0777</var>));</td></tr>
<tr><th id="66">66</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#158" title="do { if (!((rump_sys_write(fd, &quot;this is some non-humppa text&quot;, (sizeof(&quot;this is some non-humppa text&quot;)-1))) == ((sizeof(&quot;this is some non-humppa text&quot;)-1)))) atf_tc_fail_requirement(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 66, &quot;%s != %s&quot;, &quot;rump_sys_write(fd, FUNTEXT, FUNSIZE)&quot;, &quot;FUNSIZE&quot;); } while(0)" data-ref="_M/ATF_REQUIRE_EQ">ATF_REQUIRE_EQ</a>(<a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_write" title='rump_sys_write' data-ref="rump___sysimpl_write" data-ref-filename="rump___sysimpl_write">rump_sys_write</a>(<a class="local col5 ref" href="#5fd" title='fd' data-ref="5fd" data-ref-filename="5fd">fd</a>, <a class="macro" href="#49" title="&quot;this is some non-humppa text&quot;" data-ref="_M/FUNTEXT">FUNTEXT</a>, <a class="macro" href="#50" title="(sizeof(&quot;this is some non-humppa text&quot;)-1)" data-ref="_M/FUNSIZE">FUNSIZE</a>), <a class="macro" href="#50" title="(sizeof(&quot;this is some non-humppa text&quot;)-1)" data-ref="_M/FUNSIZE">FUNSIZE</a>);</td></tr>
<tr><th id="67">67</th><td>	<a class="macro" href="../../h_macros.h.html#47" title="do { if (!((rump_sys_close(fd)) != (-1))) atf_tc_fail_requirement(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 67, &quot;%s: %s&quot;, &quot;rump_sys_close(fd)&quot;, strerror((*__errno()))); } while(0)" data-ref="_M/RL">RL</a>(<a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_close" title='rump_sys_close' data-ref="rump___sysimpl_close" data-ref-filename="rump___sysimpl_close">rump_sys_close</a>(<a class="local col5 ref" href="#5fd" title='fd' data-ref="5fd" data-ref-filename="5fd">fd</a>));</td></tr>
<tr><th id="68">68</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#297" title="if (rump_sys_chdir(&quot;/&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd out of test mount&quot;)" data-ref="_M/FSTEST_EXIT">FSTEST_EXIT</a>();</td></tr>
<tr><th id="69">69</th><td>}</td></tr>
<tr><th id="70">70</th><td></td></tr>
<tr><th id="71">71</th><td><i  data-doc="create">/*</i></td></tr>
<tr><th id="72">72</th><td><i  data-doc="create"> *</i></td></tr>
<tr><th id="73">73</th><td><i  data-doc="create"> * BEGIN tests</i></td></tr>
<tr><th id="74">74</th><td><i  data-doc="create"> *</i></td></tr>
<tr><th id="75">75</th><td><i  data-doc="create"> */</i></td></tr>
<tr><th id="76">76</th><td></td></tr>
<tr><th id="77">77</th><td><em>static</em> <em>void</em></td></tr>
<tr><th id="78">78</th><td><dfn class="tu decl def fn" id="create" title='create' data-type='void create(const atf_tc_t * tc, const char * mp)' data-ref="create" data-ref-filename="create">create</dfn>(<em>const</em> <a class="typedef" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/tc.h.html#atf_tc_t" title='atf_tc_t' data-type='struct atf_tc' data-ref="atf_tc_t" data-ref-filename="atf_tc_t">atf_tc_t</a> *<dfn class="local col6 decl" id="6tc" title='tc' data-type='const atf_tc_t *' data-ref="6tc" data-ref-filename="6tc">tc</dfn>, <em>const</em> <em>char</em> *<dfn class="local col7 decl" id="7mp" title='mp' data-type='const char *' data-ref="7mp" data-ref-filename="7mp">mp</dfn>)</td></tr>
<tr><th id="79">79</th><td>{</td></tr>
<tr><th id="80">80</th><td></td></tr>
<tr><th id="81">81</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#293" title="if (rump_sys_chdir(&quot;/mnt&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd into test mount&quot;)" data-ref="_M/FSTEST_ENTER">FSTEST_ENTER</a>();</td></tr>
<tr><th id="82">82</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 83, 30, &quot;rump_sys_open(AFILE, O_CREAT|O_RDONLY, 0600) == -1&quot;, rump_sys_open(&quot;testfile&quot;, 0x00000200|0x00000000, 0600) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_open" title='rump_sys_open' data-ref="rump___sysimpl_open" data-ref-filename="rump___sysimpl_open">rump_sys_open</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, <a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/fcntl.h.html#97" title="0x00000200" data-ref="_M/O_CREAT">O_CREAT</a>|<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/fcntl.h.html#64" title="0x00000000" data-ref="_M/O_RDONLY">O_RDONLY</a>,</td></tr>
<tr><th id="83">83</th><td>	    <var>0600</var>) == -<var>1</var>);</td></tr>
<tr><th id="84">84</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#297" title="if (rump_sys_chdir(&quot;/&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd out of test mount&quot;)" data-ref="_M/FSTEST_EXIT">FSTEST_EXIT</a>();</td></tr>
<tr><th id="85">85</th><td>}</td></tr>
<tr><th id="86">86</th><td></td></tr>
<tr><th id="87">87</th><td><em>static</em> <em>void</em></td></tr>
<tr><th id="88">88</th><td><dfn class="tu decl def fn" id="rmfile" title='rmfile' data-type='void rmfile(const atf_tc_t * tc, const char * mp)' data-ref="rmfile" data-ref-filename="rmfile">rmfile</dfn>(<em>const</em> <a class="typedef" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/tc.h.html#atf_tc_t" title='atf_tc_t' data-type='struct atf_tc' data-ref="atf_tc_t" data-ref-filename="atf_tc_t">atf_tc_t</a> *<dfn class="local col8 decl" id="8tc" title='tc' data-type='const atf_tc_t *' data-ref="8tc" data-ref-filename="8tc">tc</dfn>, <em>const</em> <em>char</em> *<dfn class="local col9 decl" id="9mp" title='mp' data-type='const char *' data-ref="9mp" data-ref-filename="9mp">mp</dfn>)</td></tr>
<tr><th id="89">89</th><td>{</td></tr>
<tr><th id="90">90</th><td></td></tr>
<tr><th id="91">91</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#293" title="if (rump_sys_chdir(&quot;/mnt&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd into test mount&quot;)" data-ref="_M/FSTEST_ENTER">FSTEST_ENTER</a>();</td></tr>
<tr><th id="92">92</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 92, 30, &quot;rump_sys_unlink(AFILE) == -1&quot;, rump_sys_unlink(&quot;testfile&quot;) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_unlink" title='rump_sys_unlink' data-ref="rump___sysimpl_unlink" data-ref-filename="rump___sysimpl_unlink">rump_sys_unlink</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>) == -<var>1</var>);</td></tr>
<tr><th id="93">93</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#297" title="if (rump_sys_chdir(&quot;/&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd out of test mount&quot;)" data-ref="_M/FSTEST_EXIT">FSTEST_EXIT</a>();</td></tr>
<tr><th id="94">94</th><td>}</td></tr>
<tr><th id="95">95</th><td></td></tr>
<tr><th id="96">96</th><td><em>static</em> <em>void</em></td></tr>
<tr><th id="97">97</th><td><dfn class="tu decl def fn" id="fileio" title='fileio' data-type='void fileio(const atf_tc_t * tc, const char * mp)' data-ref="fileio" data-ref-filename="fileio">fileio</dfn>(<em>const</em> <a class="typedef" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/tc.h.html#atf_tc_t" title='atf_tc_t' data-type='struct atf_tc' data-ref="atf_tc_t" data-ref-filename="atf_tc_t">atf_tc_t</a> *<dfn class="local col0 decl" id="10tc" title='tc' data-type='const atf_tc_t *' data-ref="10tc" data-ref-filename="10tc">tc</dfn>, <em>const</em> <em>char</em> *<dfn class="local col1 decl" id="11mp" title='mp' data-type='const char *' data-ref="11mp" data-ref-filename="11mp">mp</dfn>)</td></tr>
<tr><th id="98">98</th><td>{</td></tr>
<tr><th id="99">99</th><td>	<em>int</em> <dfn class="local col2 decl" id="12fd" title='fd' data-type='int' data-ref="12fd" data-ref-filename="12fd">fd</dfn>;</td></tr>
<tr><th id="100">100</th><td>	<em>char</em> <dfn class="local col3 decl" id="13buf" title='buf' data-type='char [29]' data-ref="13buf" data-ref-filename="13buf">buf</dfn>[<a class="macro" href="#50" title="(sizeof(&quot;this is some non-humppa text&quot;)-1)" data-ref="_M/FUNSIZE">FUNSIZE</a>+<var>1</var>];</td></tr>
<tr><th id="101">101</th><td>	<em>int</em> <dfn class="local col4 decl" id="14expected" title='expected' data-type='int' data-ref="14expected" data-ref-filename="14expected">expected</dfn>;</td></tr>
<tr><th id="102">102</th><td></td></tr>
<tr><th id="103">103</th><td>	<b>if</b> (<a class="macro" href="../common/h_fsmacros.h.html#274" title="(strcmp(atf_tc_get_md_var(tc, &quot;X-fs.type&quot;), &quot;nfsro&quot;) == 0)" data-ref="_M/FSTYPE_NFSRO">FSTYPE_NFSRO</a>(<a class="local col0 ref" href="#10tc" title='tc' data-ref="10tc" data-ref-filename="10tc">tc</a>))</td></tr>
<tr><th id="104">104</th><td>		<a class="local col4 ref" href="#14expected" title='expected' data-ref="14expected" data-ref-filename="14expected">expected</a> = <a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#55" title="13" data-ref="_M/EACCES">EACCES</a>;</td></tr>
<tr><th id="105">105</th><td>	<b>else</b></td></tr>
<tr><th id="106">106</th><td>		<a class="local col4 ref" href="#14expected" title='expected' data-ref="14expected" data-ref-filename="14expected">expected</a> = <a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>;</td></tr>
<tr><th id="107">107</th><td></td></tr>
<tr><th id="108">108</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#293" title="if (rump_sys_chdir(&quot;/mnt&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd into test mount&quot;)" data-ref="_M/FSTEST_ENTER">FSTEST_ENTER</a>();</td></tr>
<tr><th id="109">109</th><td>	<a class="macro" href="../../h_macros.h.html#47" title="do { if (!((fd = rump_sys_open(&quot;testfile&quot;, 0x00000000)) != (-1))) atf_tc_fail_requirement(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 109, &quot;%s: %s&quot;, &quot;fd = rump_sys_open(\&quot;testfile\&quot;, 0x00000000)&quot;, strerror((*__errno()))); } while(0)" data-ref="_M/RL">RL</a>(<a class="local col2 ref" href="#12fd" title='fd' data-ref="12fd" data-ref-filename="12fd">fd</a> = <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_open" title='rump_sys_open' data-ref="rump___sysimpl_open" data-ref-filename="rump___sysimpl_open">rump_sys_open</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, <a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/fcntl.h.html#64" title="0x00000000" data-ref="_M/O_RDONLY">O_RDONLY</a>));</td></tr>
<tr><th id="110">110</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#158" title="do { if (!((rump_sys_read(fd, buf, (sizeof(&quot;this is some non-humppa text&quot;)-1))) == ((sizeof(&quot;this is some non-humppa text&quot;)-1)))) atf_tc_fail_requirement(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 110, &quot;%s != %s&quot;, &quot;rump_sys_read(fd, buf, FUNSIZE)&quot;, &quot;FUNSIZE&quot;); } while(0)" data-ref="_M/ATF_REQUIRE_EQ">ATF_REQUIRE_EQ</a>(<a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_read" title='rump_sys_read' data-ref="rump___sysimpl_read" data-ref-filename="rump___sysimpl_read">rump_sys_read</a>(<a class="local col2 ref" href="#12fd" title='fd' data-ref="12fd" data-ref-filename="12fd">fd</a>, <a class="local col3 ref" href="#13buf" title='buf' data-ref="13buf" data-ref-filename="13buf">buf</a>, <a class="macro" href="#50" title="(sizeof(&quot;this is some non-humppa text&quot;)-1)" data-ref="_M/FUNSIZE">FUNSIZE</a>), <a class="macro" href="#50" title="(sizeof(&quot;this is some non-humppa text&quot;)-1)" data-ref="_M/FUNSIZE">FUNSIZE</a>);</td></tr>
<tr><th id="111">111</th><td>	<a class="local col3 ref" href="#13buf" title='buf' data-ref="13buf" data-ref-filename="13buf">buf</a>[<a class="macro" href="#50" title="(sizeof(&quot;this is some non-humppa text&quot;)-1)" data-ref="_M/FUNSIZE">FUNSIZE</a>] = <kbd>'\0'</kbd>;</td></tr>
<tr><th id="112">112</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#170" title="do { if (!(strcmp(buf, &quot;this is some non-humppa text&quot;) == 0)) atf_tc_fail_requirement(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 112, &quot;%s != %s (%s != %s)&quot;, &quot;buf&quot;, &quot;FUNTEXT&quot;, buf, &quot;this is some non-humppa text&quot;); } while(0)" data-ref="_M/ATF_REQUIRE_STREQ">ATF_REQUIRE_STREQ</a>(<a class="local col3 ref" href="#13buf" title='buf' data-ref="13buf" data-ref-filename="13buf">buf</a>, <a class="macro" href="#49" title="&quot;this is some non-humppa text&quot;" data-ref="_M/FUNTEXT">FUNTEXT</a>);</td></tr>
<tr><th id="113">113</th><td>	<a class="macro" href="../../h_macros.h.html#47" title="do { if (!((rump_sys_close(fd)) != (-1))) atf_tc_fail_requirement(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 113, &quot;%s: %s&quot;, &quot;rump_sys_close(fd)&quot;, strerror((*__errno()))); } while(0)" data-ref="_M/RL">RL</a>(<a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_close" title='rump_sys_close' data-ref="rump___sysimpl_close" data-ref-filename="rump___sysimpl_close">rump_sys_close</a>(<a class="local col2 ref" href="#12fd" title='fd' data-ref="12fd" data-ref-filename="12fd">fd</a>));</td></tr>
<tr><th id="114">114</th><td></td></tr>
<tr><th id="115">115</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 115, expected, &quot;rump_sys_open(AFILE, O_WRONLY) == -1&quot;, rump_sys_open(&quot;testfile&quot;, 0x00000001) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="local col4 ref" href="#14expected" title='expected' data-ref="14expected" data-ref-filename="14expected">expected</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_open" title='rump_sys_open' data-ref="rump___sysimpl_open" data-ref-filename="rump___sysimpl_open">rump_sys_open</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, <a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/fcntl.h.html#65" title="0x00000001" data-ref="_M/O_WRONLY">O_WRONLY</a>) == -<var>1</var>);</td></tr>
<tr><th id="116">116</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 116, expected, &quot;rump_sys_open(AFILE, O_RDWR) == -1&quot;, rump_sys_open(&quot;testfile&quot;, 0x00000002) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="local col4 ref" href="#14expected" title='expected' data-ref="14expected" data-ref-filename="14expected">expected</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_open" title='rump_sys_open' data-ref="rump___sysimpl_open" data-ref-filename="rump___sysimpl_open">rump_sys_open</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, <a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/fcntl.h.html#66" title="0x00000002" data-ref="_M/O_RDWR">O_RDWR</a>) == -<var>1</var>);</td></tr>
<tr><th id="117">117</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#297" title="if (rump_sys_chdir(&quot;/&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd out of test mount&quot;)" data-ref="_M/FSTEST_EXIT">FSTEST_EXIT</a>();</td></tr>
<tr><th id="118">118</th><td>}</td></tr>
<tr><th id="119">119</th><td></td></tr>
<tr><th id="120">120</th><td><em>static</em> <em>void</em></td></tr>
<tr><th id="121">121</th><td><dfn class="tu decl def fn" id="attrs" title='attrs' data-type='void attrs(const atf_tc_t * tc, const char * mp)' data-ref="attrs" data-ref-filename="attrs">attrs</dfn>(<em>const</em> <a class="typedef" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/tc.h.html#atf_tc_t" title='atf_tc_t' data-type='struct atf_tc' data-ref="atf_tc_t" data-ref-filename="atf_tc_t">atf_tc_t</a> *<dfn class="local col5 decl" id="15tc" title='tc' data-type='const atf_tc_t *' data-ref="15tc" data-ref-filename="15tc">tc</dfn>, <em>const</em> <em>char</em> *<dfn class="local col6 decl" id="16mp" title='mp' data-type='const char *' data-ref="16mp" data-ref-filename="16mp">mp</dfn>)</td></tr>
<tr><th id="122">122</th><td>{</td></tr>
<tr><th id="123">123</th><td>	<b>struct</b> <a class="type" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/time.h.html#timeval" title='timeval' data-ref="timeval" data-ref-filename="timeval">timeval</a> <dfn class="local col7 decl" id="17sometvs" title='sometvs' data-type='struct timeval [2]' data-ref="17sometvs" data-ref-filename="17sometvs">sometvs</dfn>[<var>2</var>];</td></tr>
<tr><th id="124">124</th><td>	<b>struct</b> <a class="type" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/stat.h.html#stat" title='stat' data-ref="stat" data-ref-filename="stat">stat</a> <dfn class="local col8 decl" id="18sb" title='sb' data-type='struct stat' data-ref="18sb" data-ref-filename="18sb">sb</dfn>;</td></tr>
<tr><th id="125">125</th><td>	<em>int</em> <dfn class="local col9 decl" id="19fd" title='fd' data-type='int' data-ref="19fd" data-ref-filename="19fd">fd</dfn>;</td></tr>
<tr><th id="126">126</th><td></td></tr>
<tr><th id="127">127</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#293" title="if (rump_sys_chdir(&quot;/mnt&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd into test mount&quot;)" data-ref="_M/FSTEST_ENTER">FSTEST_ENTER</a>();</td></tr>
<tr><th id="128">128</th><td></td></tr>
<tr><th id="129">129</th><td>	<a class="macro" href="../../h_macros.h.html#47" title="do { if (!((rump_sys_stat(&quot;testfile&quot;, &amp;sb)) != (-1))) atf_tc_fail_requirement(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 129, &quot;%s: %s&quot;, &quot;rump_sys_stat(\&quot;testfile\&quot;, &amp;sb)&quot;, strerror((*__errno()))); } while(0)" data-ref="_M/RL">RL</a>(<a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_stat50" title='rump_sys_stat' data-ref="rump___sysimpl_stat50" data-ref-filename="rump___sysimpl_stat50">rump_sys_stat</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, &amp;<a class="local col8 ref" href="#18sb" title='sb' data-ref="18sb" data-ref-filename="18sb">sb</a>));</td></tr>
<tr><th id="130">130</th><td></td></tr>
<tr><th id="131">131</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 131, 30, &quot;rump_sys_chmod(AFILE, 0775) == -1&quot;, rump_sys_chmod(&quot;testfile&quot;, 0775) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_chmod" title='rump_sys_chmod' data-ref="rump___sysimpl_chmod" data-ref-filename="rump___sysimpl_chmod">rump_sys_chmod</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, <var>0775</var>) == -<var>1</var>);</td></tr>
<tr><th id="132">132</th><td>	<b>if</b> (!<a class="macro" href="../common/h_fsmacros.h.html#270" title="(strcmp(atf_tc_get_md_var(tc, &quot;X-fs.type&quot;), &quot;msdosfs&quot;) == 0)" data-ref="_M/FSTYPE_MSDOS">FSTYPE_MSDOS</a>(<a class="local col5 ref" href="#15tc" title='tc' data-ref="15tc" data-ref-filename="15tc">tc</a>))</td></tr>
<tr><th id="133">133</th><td>		<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 133, 30, &quot;rump_sys_chown(AFILE, 1, 1) == -1&quot;, rump_sys_chown(&quot;testfile&quot;, 1, 1) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_chown" title='rump_sys_chown' data-ref="rump___sysimpl_chown" data-ref-filename="rump___sysimpl_chown">rump_sys_chown</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, <var>1</var>, <var>1</var>) == -<var>1</var>);</td></tr>
<tr><th id="134">134</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 134, 30, &quot;rump_sys_utimes(AFILE, sometvs) == -1&quot;, rump_sys_utimes(&quot;testfile&quot;, sometvs) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_utimes50" title='rump_sys_utimes' data-ref="rump___sysimpl_utimes50" data-ref-filename="rump___sysimpl_utimes50">rump_sys_utimes</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, <a class="local col7 ref" href="#17sometvs" title='sometvs' data-ref="17sometvs" data-ref-filename="17sometvs">sometvs</a>) == -<var>1</var>);</td></tr>
<tr><th id="135">135</th><td></td></tr>
<tr><th id="136">136</th><td>	<a class="macro" href="../../h_macros.h.html#47" title="do { if (!((fd = rump_sys_open(&quot;testfile&quot;, 0x00000000)) != (-1))) atf_tc_fail_requirement(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 136, &quot;%s: %s&quot;, &quot;fd = rump_sys_open(\&quot;testfile\&quot;, 0x00000000)&quot;, strerror((*__errno()))); } while(0)" data-ref="_M/RL">RL</a>(<a class="local col9 ref" href="#19fd" title='fd' data-ref="19fd" data-ref-filename="19fd">fd</a> = <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_open" title='rump_sys_open' data-ref="rump___sysimpl_open" data-ref-filename="rump___sysimpl_open">rump_sys_open</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, <a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/fcntl.h.html#64" title="0x00000000" data-ref="_M/O_RDONLY">O_RDONLY</a>));</td></tr>
<tr><th id="137">137</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 137, 30, &quot;rump_sys_fchmod(fd, 0775) == -1&quot;, rump_sys_fchmod(fd, 0775) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_fchmod" title='rump_sys_fchmod' data-ref="rump___sysimpl_fchmod" data-ref-filename="rump___sysimpl_fchmod">rump_sys_fchmod</a>(<a class="local col9 ref" href="#19fd" title='fd' data-ref="19fd" data-ref-filename="19fd">fd</a>, <var>0775</var>) == -<var>1</var>);</td></tr>
<tr><th id="138">138</th><td>	<b>if</b> (!<a class="macro" href="../common/h_fsmacros.h.html#270" title="(strcmp(atf_tc_get_md_var(tc, &quot;X-fs.type&quot;), &quot;msdosfs&quot;) == 0)" data-ref="_M/FSTYPE_MSDOS">FSTYPE_MSDOS</a>(<a class="local col5 ref" href="#15tc" title='tc' data-ref="15tc" data-ref-filename="15tc">tc</a>))</td></tr>
<tr><th id="139">139</th><td>		<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 139, 30, &quot;rump_sys_fchown(fd, 1, 1) == -1&quot;, rump_sys_fchown(fd, 1, 1) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_fchown" title='rump_sys_fchown' data-ref="rump___sysimpl_fchown" data-ref-filename="rump___sysimpl_fchown">rump_sys_fchown</a>(<a class="local col9 ref" href="#19fd" title='fd' data-ref="19fd" data-ref-filename="19fd">fd</a>, <var>1</var>, <var>1</var>) == -<var>1</var>);</td></tr>
<tr><th id="140">140</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 140, 30, &quot;rump_sys_futimes(fd, sometvs) == -1&quot;, rump_sys_futimes(fd, sometvs) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_futimes50" title='rump_sys_futimes' data-ref="rump___sysimpl_futimes50" data-ref-filename="rump___sysimpl_futimes50">rump_sys_futimes</a>(<a class="local col9 ref" href="#19fd" title='fd' data-ref="19fd" data-ref-filename="19fd">fd</a>, <a class="local col7 ref" href="#17sometvs" title='sometvs' data-ref="17sometvs" data-ref-filename="17sometvs">sometvs</a>) == -<var>1</var>);</td></tr>
<tr><th id="141">141</th><td>	<a class="macro" href="../../h_macros.h.html#47" title="do { if (!((rump_sys_close(fd)) != (-1))) atf_tc_fail_requirement(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 141, &quot;%s: %s&quot;, &quot;rump_sys_close(fd)&quot;, strerror((*__errno()))); } while(0)" data-ref="_M/RL">RL</a>(<a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_close" title='rump_sys_close' data-ref="rump___sysimpl_close" data-ref-filename="rump___sysimpl_close">rump_sys_close</a>(<a class="local col9 ref" href="#19fd" title='fd' data-ref="19fd" data-ref-filename="19fd">fd</a>));</td></tr>
<tr><th id="142">142</th><td></td></tr>
<tr><th id="143">143</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#297" title="if (rump_sys_chdir(&quot;/&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd out of test mount&quot;)" data-ref="_M/FSTEST_EXIT">FSTEST_EXIT</a>();</td></tr>
<tr><th id="144">144</th><td>}</td></tr>
<tr><th id="145">145</th><td></td></tr>
<tr><th id="146">146</th><td><em>static</em> <em>void</em></td></tr>
<tr><th id="147">147</th><td><dfn class="tu decl def fn" id="createdir" title='createdir' data-type='void createdir(const atf_tc_t * tc, const char * mp)' data-ref="createdir" data-ref-filename="createdir">createdir</dfn>(<em>const</em> <a class="typedef" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/tc.h.html#atf_tc_t" title='atf_tc_t' data-type='struct atf_tc' data-ref="atf_tc_t" data-ref-filename="atf_tc_t">atf_tc_t</a> *<dfn class="local col0 decl" id="20tc" title='tc' data-type='const atf_tc_t *' data-ref="20tc" data-ref-filename="20tc">tc</dfn>, <em>const</em> <em>char</em> *<dfn class="local col1 decl" id="21mp" title='mp' data-type='const char *' data-ref="21mp" data-ref-filename="21mp">mp</dfn>)</td></tr>
<tr><th id="148">148</th><td>{</td></tr>
<tr><th id="149">149</th><td></td></tr>
<tr><th id="150">150</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#293" title="if (rump_sys_chdir(&quot;/mnt&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd into test mount&quot;)" data-ref="_M/FSTEST_ENTER">FSTEST_ENTER</a>();</td></tr>
<tr><th id="151">151</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 151, 30, &quot;rump_sys_mkdir(ADIR, 0775) == -1&quot;, rump_sys_mkdir(&quot;testdir&quot;, 0775) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_mkdir" title='rump_sys_mkdir' data-ref="rump___sysimpl_mkdir" data-ref-filename="rump___sysimpl_mkdir">rump_sys_mkdir</a>(<a class="macro" href="#45" title="&quot;testdir&quot;" data-ref="_M/ADIR">ADIR</a>, <var>0775</var>) == -<var>1</var>);</td></tr>
<tr><th id="152">152</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#297" title="if (rump_sys_chdir(&quot;/&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd out of test mount&quot;)" data-ref="_M/FSTEST_EXIT">FSTEST_EXIT</a>();</td></tr>
<tr><th id="153">153</th><td>}</td></tr>
<tr><th id="154">154</th><td></td></tr>
<tr><th id="155">155</th><td><em>static</em> <em>void</em></td></tr>
<tr><th id="156">156</th><td><dfn class="tu decl def fn" id="createfifo" title='createfifo' data-type='void createfifo(const atf_tc_t * tc, const char * mp)' data-ref="createfifo" data-ref-filename="createfifo">createfifo</dfn>(<em>const</em> <a class="typedef" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/tc.h.html#atf_tc_t" title='atf_tc_t' data-type='struct atf_tc' data-ref="atf_tc_t" data-ref-filename="atf_tc_t">atf_tc_t</a> *<dfn class="local col2 decl" id="22tc" title='tc' data-type='const atf_tc_t *' data-ref="22tc" data-ref-filename="22tc">tc</dfn>, <em>const</em> <em>char</em> *<dfn class="local col3 decl" id="23mp" title='mp' data-type='const char *' data-ref="23mp" data-ref-filename="23mp">mp</dfn>)</td></tr>
<tr><th id="157">157</th><td>{</td></tr>
<tr><th id="158">158</th><td></td></tr>
<tr><th id="159">159</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#293" title="if (rump_sys_chdir(&quot;/mnt&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd into test mount&quot;)" data-ref="_M/FSTEST_ENTER">FSTEST_ENTER</a>();</td></tr>
<tr><th id="160">160</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 160, 30, &quot;rump_sys_mkfifo(AFIFO, 0775) == -1&quot;, rump_sys_mkfifo(&quot;testfifo&quot;, 0775) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_mkfifo" title='rump_sys_mkfifo' data-ref="rump___sysimpl_mkfifo" data-ref-filename="rump___sysimpl_mkfifo">rump_sys_mkfifo</a>(<a class="macro" href="#46" title="&quot;testfifo&quot;" data-ref="_M/AFIFO">AFIFO</a>, <var>0775</var>) == -<var>1</var>);</td></tr>
<tr><th id="161">161</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#297" title="if (rump_sys_chdir(&quot;/&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd out of test mount&quot;)" data-ref="_M/FSTEST_EXIT">FSTEST_EXIT</a>();</td></tr>
<tr><th id="162">162</th><td>}</td></tr>
<tr><th id="163">163</th><td></td></tr>
<tr><th id="164">164</th><td><em>static</em> <em>void</em></td></tr>
<tr><th id="165">165</th><td><dfn class="tu decl def fn" id="createsymlink" title='createsymlink' data-type='void createsymlink(const atf_tc_t * tc, const char * mp)' data-ref="createsymlink" data-ref-filename="createsymlink">createsymlink</dfn>(<em>const</em> <a class="typedef" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/tc.h.html#atf_tc_t" title='atf_tc_t' data-type='struct atf_tc' data-ref="atf_tc_t" data-ref-filename="atf_tc_t">atf_tc_t</a> *<dfn class="local col4 decl" id="24tc" title='tc' data-type='const atf_tc_t *' data-ref="24tc" data-ref-filename="24tc">tc</dfn>, <em>const</em> <em>char</em> *<dfn class="local col5 decl" id="25mp" title='mp' data-type='const char *' data-ref="25mp" data-ref-filename="25mp">mp</dfn>)</td></tr>
<tr><th id="166">166</th><td>{</td></tr>
<tr><th id="167">167</th><td></td></tr>
<tr><th id="168">168</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#293" title="if (rump_sys_chdir(&quot;/mnt&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd into test mount&quot;)" data-ref="_M/FSTEST_ENTER">FSTEST_ENTER</a>();</td></tr>
<tr><th id="169">169</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 169, 30, &quot;rump_sys_symlink(\&quot;hoge\&quot;, ASYMLINK) == -1&quot;, rump_sys_symlink(&quot;hoge&quot;, &quot;testsymlink&quot;) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_symlink" title='rump_sys_symlink' data-ref="rump___sysimpl_symlink" data-ref-filename="rump___sysimpl_symlink">rump_sys_symlink</a>(<q>"hoge"</q>, <a class="macro" href="#47" title="&quot;testsymlink&quot;" data-ref="_M/ASYMLINK">ASYMLINK</a>) == -<var>1</var>);</td></tr>
<tr><th id="170">170</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#297" title="if (rump_sys_chdir(&quot;/&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd out of test mount&quot;)" data-ref="_M/FSTEST_EXIT">FSTEST_EXIT</a>();</td></tr>
<tr><th id="171">171</th><td>}</td></tr>
<tr><th id="172">172</th><td></td></tr>
<tr><th id="173">173</th><td><em>static</em> <em>void</em></td></tr>
<tr><th id="174">174</th><td><dfn class="tu decl def fn" id="createlink" title='createlink' data-type='void createlink(const atf_tc_t * tc, const char * mp)' data-ref="createlink" data-ref-filename="createlink">createlink</dfn>(<em>const</em> <a class="typedef" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/tc.h.html#atf_tc_t" title='atf_tc_t' data-type='struct atf_tc' data-ref="atf_tc_t" data-ref-filename="atf_tc_t">atf_tc_t</a> *<dfn class="local col6 decl" id="26tc" title='tc' data-type='const atf_tc_t *' data-ref="26tc" data-ref-filename="26tc">tc</dfn>, <em>const</em> <em>char</em> *<dfn class="local col7 decl" id="27mp" title='mp' data-type='const char *' data-ref="27mp" data-ref-filename="27mp">mp</dfn>)</td></tr>
<tr><th id="175">175</th><td>{</td></tr>
<tr><th id="176">176</th><td></td></tr>
<tr><th id="177">177</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#293" title="if (rump_sys_chdir(&quot;/mnt&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd into test mount&quot;)" data-ref="_M/FSTEST_ENTER">FSTEST_ENTER</a>();</td></tr>
<tr><th id="178">178</th><td>	<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#205" title="atf_tc_require_errno(&quot;/___NETBSD_SRC___/objdir.amd64/tests/fs/vfs/../../../../tests/fs/vfs/t_ro.c&quot;, 178, 30, &quot;rump_sys_link(AFILE, ALINK) == -1&quot;, rump_sys_link(&quot;testfile&quot;, &quot;testlink&quot;) == -1)" data-ref="_M/ATF_REQUIRE_ERRNO">ATF_REQUIRE_ERRNO</a>(<a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/sys/errno.h.html#72" title="30" data-ref="_M/EROFS">EROFS</a>, <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/rump/rump_syscalls.h.html#rump___sysimpl_link" title='rump_sys_link' data-ref="rump___sysimpl_link" data-ref-filename="rump___sysimpl_link">rump_sys_link</a>(<a class="macro" href="#44" title="&quot;testfile&quot;" data-ref="_M/AFILE">AFILE</a>, <a class="macro" href="#48" title="&quot;testlink&quot;" data-ref="_M/ALINK">ALINK</a>) == -<var>1</var>);</td></tr>
<tr><th id="179">179</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#297" title="if (rump_sys_chdir(&quot;/&quot;) == -1) atf_tc_fail_errno(&quot;failed to cd out of test mount&quot;)" data-ref="_M/FSTEST_EXIT">FSTEST_EXIT</a>();</td></tr>
<tr><th id="180">180</th><td>}</td></tr>
<tr><th id="181">181</th><td></td></tr>
<tr><th id="182">182</th><td><a class="macro" href="../common/h_fsmacros.h.html#218" title="static void atfu_ext2fs_create_head(atf_tc_t *); static void atfu_ext2fs_create_body(const atf_tc_t *); static atf_tc_t atfu_ext2fs_create_tc; static atf_tc_pack_t atfu_ext2fs_create_tc_pack = { .m_ident = &quot;ext2fs_create&quot;, .m_head = atfu_ext2fs_create_head, .m_body = atfu_ext2fs_create_body, .m_cleanup = ((void*)0), }; static void atfu_ext2fs_create_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ext2fs&quot;&quot; test for &quot;&quot;create file on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ext2fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ext2fs&quot;); } void *ext2fscreatetmp; static void atfu_ext2fs_create_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ext2fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ext2fs_fstest_newfs(tc, &amp;ext2fscreatetmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ext2fs_fstest_mount(tc, ext2fscreatetmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ext2fs_fstest_mount(tc, ext2fscreatetmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); create(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffs_create_head(atf_tc_t *); static void atfu_ffs_create_body(const atf_tc_t *); static atf_tc_t atfu_ffs_create_tc; static atf_tc_pack_t atfu_ffs_create_tc_pack = { .m_ident = &quot;ffs_create&quot;, .m_head = atfu_ffs_create_head, .m_body = atfu_ffs_create_body, .m_cleanup = ((void*)0), }; static void atfu_ffs_create_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;create file on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffscreatetmp; static void atfu_ffs_create_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffs_fstest_newfs(tc, &amp;ffscreatetmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffs_fstest_mount(tc, ffscreatetmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffs_fstest_mount(tc, ffscreatetmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); create(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffslog_create_head(atf_tc_t *); static void atfu_ffslog_create_body(const atf_tc_t *); static atf_tc_t atfu_ffslog_create_tc; static atf_tc_pack_t atfu_ffslog_create_tc_pack = { .m_ident = &quot;ffslog_create&quot;, .m_head = atfu_ffslog_create_head, .m_body = atfu_ffslog_create_body, .m_cleanup = ((void*)0), }; static void atfu_ffslog_create_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;create file on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffslog&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffslogcreatetmp; static void atfu_ffslog_create_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffslog&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffslog_fstest_newfs(tc, &amp;ffslogcreatetmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffslog_fstest_mount(tc, ffslogcreatetmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffslog_fstest_mount(tc, ffslogcreatetmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); create(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_msdosfs_create_head(atf_tc_t *); static void atfu_msdosfs_create_body(const atf_tc_t *); static atf_tc_t atfu_msdosfs_create_tc; static atf_tc_pack_t atfu_msdosfs_create_tc_pack = { .m_ident = &quot;msdosfs_create&quot;, .m_head = atfu_msdosfs_create_head, .m_body = atfu_msdosfs_create_body, .m_cleanup = ((void*)0), }; static void atfu_msdosfs_create_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;msdos&quot;&quot; test for &quot;&quot;create file on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;msdosfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;msdos&quot;); } void *msdosfscreatetmp; static void atfu_msdosfs_create_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;msdosfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (msdosfs_fstest_newfs(tc, &amp;msdosfscreatetmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (msdosfs_fstest_mount(tc, msdosfscreatetmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (msdosfs_fstest_mount(tc, msdosfscreatetmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); create(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfs_create_head(atf_tc_t *); static void atfu_nfs_create_body(const atf_tc_t *); static atf_tc_t atfu_nfs_create_tc; static atf_tc_pack_t atfu_nfs_create_tc_pack = { .m_ident = &quot;nfs_create&quot;, .m_head = atfu_nfs_create_head, .m_body = atfu_nfs_create_body, .m_cleanup = ((void*)0), }; static void atfu_nfs_create_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;create file on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfscreatetmp; static void atfu_nfs_create_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfs_fstest_newfs(tc, &amp;nfscreatetmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfs_fstest_mount(tc, nfscreatetmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfs_fstest_mount(tc, nfscreatetmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); create(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfsro_create_head(atf_tc_t *); static void atfu_nfsro_create_body(const atf_tc_t *); static atf_tc_t atfu_nfsro_create_tc; static atf_tc_pack_t atfu_nfsro_create_tc_pack = { .m_ident = &quot;nfsro_create&quot;, .m_head = atfu_nfsro_create_head, .m_body = atfu_nfsro_create_body, .m_cleanup = ((void*)0), }; static void atfu_nfsro_create_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;create file on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfsro&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsrocreatetmp; static void atfu_nfsro_create_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfsro&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfsro_fstest_newfs(tc, &amp;nfsrocreatetmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfsro_fstest_mount(tc, nfsrocreatetmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfsro_fstest_mount(tc, nfsrocreatetmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); create(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_sysvbfs_create_head(atf_tc_t *); static void atfu_sysvbfs_create_body(const atf_tc_t *); static atf_tc_t atfu_sysvbfs_create_tc; static atf_tc_pack_t atfu_sysvbfs_create_tc_pack = { .m_ident = &quot;sysvbfs_create&quot;, .m_head = atfu_sysvbfs_create_head, .m_body = atfu_sysvbfs_create_body, .m_cleanup = ((void*)0), }; static void atfu_sysvbfs_create_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;sysvbfs&quot;&quot; test for &quot;&quot;create file on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;sysvbfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;sysvbfs&quot;); } void *sysvbfscreatetmp; static void atfu_sysvbfs_create_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;sysvbfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (sysvbfs_fstest_newfs(tc, &amp;sysvbfscreatetmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfscreatetmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfscreatetmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); create(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_udf_create_head(atf_tc_t *); static void atfu_udf_create_body(const atf_tc_t *); static atf_tc_t atfu_udf_create_tc; static atf_tc_pack_t atfu_udf_create_tc_pack = { .m_ident = &quot;udf_create&quot;, .m_head = atfu_udf_create_head, .m_body = atfu_udf_create_body, .m_cleanup = ((void*)0), }; static void atfu_udf_create_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;udf&quot;&quot; test for &quot;&quot;create file on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;udf&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;udf&quot;); } void *udfcreatetmp; static void atfu_udf_create_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;udf&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (udf_fstest_newfs(tc, &amp;udfcreatetmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (udf_fstest_mount(tc, udfcreatetmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (udf_fstest_mount(tc, udfcreatetmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); create(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_v7fs_create_head(atf_tc_t *); static void atfu_v7fs_create_body(const atf_tc_t *); static atf_tc_t atfu_v7fs_create_tc; static atf_tc_pack_t atfu_v7fs_create_tc_pack = { .m_ident = &quot;v7fs_create&quot;, .m_head = atfu_v7fs_create_head, .m_body = atfu_v7fs_create_body, .m_cleanup = ((void*)0), }; static void atfu_v7fs_create_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;v7fs&quot;&quot; test for &quot;&quot;create file on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;v7fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;v7fs&quot;); } void *v7fscreatetmp; static void atfu_v7fs_create_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;v7fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (v7fs_fstest_newfs(tc, &amp;v7fscreatetmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (v7fs_fstest_mount(tc, v7fscreatetmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (v7fs_fstest_mount(tc, v7fscreatetmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); create(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } }" data-ref="_M/ATF_TC_FSAPPLY_RO">ATF_TC_FSAPPLY_RO</a>(<a class="tu ref fn" href="#create" title='create' data-use='c' data-ref="create" data-ref-filename="create">create</a>, <q>"create file on r/o mount"</q>, <a class="tu ref fn" href="#nullgen" title='nullgen' data-use='c' data-ref="nullgen" data-ref-filename="nullgen">nullgen</a>);</td></tr>
<tr><th id="183">183</th><td><a class="macro" href="../common/h_fsmacros.h.html#218" title="static void atfu_ext2fs_rmfile_head(atf_tc_t *); static void atfu_ext2fs_rmfile_body(const atf_tc_t *); static atf_tc_t atfu_ext2fs_rmfile_tc; static atf_tc_pack_t atfu_ext2fs_rmfile_tc_pack = { .m_ident = &quot;ext2fs_rmfile&quot;, .m_head = atfu_ext2fs_rmfile_head, .m_body = atfu_ext2fs_rmfile_body, .m_cleanup = ((void*)0), }; static void atfu_ext2fs_rmfile_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ext2fs&quot;&quot; test for &quot;&quot;remove file from r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ext2fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ext2fs&quot;); } void *ext2fsrmfiletmp; static void atfu_ext2fs_rmfile_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ext2fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ext2fs_fstest_newfs(tc, &amp;ext2fsrmfiletmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ext2fs_fstest_mount(tc, ext2fsrmfiletmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ext2fs_fstest_mount(tc, ext2fsrmfiletmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); rmfile(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffs_rmfile_head(atf_tc_t *); static void atfu_ffs_rmfile_body(const atf_tc_t *); static atf_tc_t atfu_ffs_rmfile_tc; static atf_tc_pack_t atfu_ffs_rmfile_tc_pack = { .m_ident = &quot;ffs_rmfile&quot;, .m_head = atfu_ffs_rmfile_head, .m_body = atfu_ffs_rmfile_body, .m_cleanup = ((void*)0), }; static void atfu_ffs_rmfile_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;remove file from r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffsrmfiletmp; static void atfu_ffs_rmfile_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffs_fstest_newfs(tc, &amp;ffsrmfiletmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffs_fstest_mount(tc, ffsrmfiletmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffs_fstest_mount(tc, ffsrmfiletmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); rmfile(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffslog_rmfile_head(atf_tc_t *); static void atfu_ffslog_rmfile_body(const atf_tc_t *); static atf_tc_t atfu_ffslog_rmfile_tc; static atf_tc_pack_t atfu_ffslog_rmfile_tc_pack = { .m_ident = &quot;ffslog_rmfile&quot;, .m_head = atfu_ffslog_rmfile_head, .m_body = atfu_ffslog_rmfile_body, .m_cleanup = ((void*)0), }; static void atfu_ffslog_rmfile_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;remove file from r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffslog&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffslogrmfiletmp; static void atfu_ffslog_rmfile_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffslog&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffslog_fstest_newfs(tc, &amp;ffslogrmfiletmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffslog_fstest_mount(tc, ffslogrmfiletmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffslog_fstest_mount(tc, ffslogrmfiletmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); rmfile(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_msdosfs_rmfile_head(atf_tc_t *); static void atfu_msdosfs_rmfile_body(const atf_tc_t *); static atf_tc_t atfu_msdosfs_rmfile_tc; static atf_tc_pack_t atfu_msdosfs_rmfile_tc_pack = { .m_ident = &quot;msdosfs_rmfile&quot;, .m_head = atfu_msdosfs_rmfile_head, .m_body = atfu_msdosfs_rmfile_body, .m_cleanup = ((void*)0), }; static void atfu_msdosfs_rmfile_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;msdos&quot;&quot; test for &quot;&quot;remove file from r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;msdosfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;msdos&quot;); } void *msdosfsrmfiletmp; static void atfu_msdosfs_rmfile_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;msdosfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (msdosfs_fstest_newfs(tc, &amp;msdosfsrmfiletmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (msdosfs_fstest_mount(tc, msdosfsrmfiletmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (msdosfs_fstest_mount(tc, msdosfsrmfiletmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); rmfile(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfs_rmfile_head(atf_tc_t *); static void atfu_nfs_rmfile_body(const atf_tc_t *); static atf_tc_t atfu_nfs_rmfile_tc; static atf_tc_pack_t atfu_nfs_rmfile_tc_pack = { .m_ident = &quot;nfs_rmfile&quot;, .m_head = atfu_nfs_rmfile_head, .m_body = atfu_nfs_rmfile_body, .m_cleanup = ((void*)0), }; static void atfu_nfs_rmfile_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;remove file from r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsrmfiletmp; static void atfu_nfs_rmfile_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfs_fstest_newfs(tc, &amp;nfsrmfiletmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfs_fstest_mount(tc, nfsrmfiletmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfs_fstest_mount(tc, nfsrmfiletmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); rmfile(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfsro_rmfile_head(atf_tc_t *); static void atfu_nfsro_rmfile_body(const atf_tc_t *); static atf_tc_t atfu_nfsro_rmfile_tc; static atf_tc_pack_t atfu_nfsro_rmfile_tc_pack = { .m_ident = &quot;nfsro_rmfile&quot;, .m_head = atfu_nfsro_rmfile_head, .m_body = atfu_nfsro_rmfile_body, .m_cleanup = ((void*)0), }; static void atfu_nfsro_rmfile_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;remove file from r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfsro&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsrormfiletmp; static void atfu_nfsro_rmfile_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfsro&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfsro_fstest_newfs(tc, &amp;nfsrormfiletmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfsro_fstest_mount(tc, nfsrormfiletmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfsro_fstest_mount(tc, nfsrormfiletmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); rmfile(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_sysvbfs_rmfile_head(atf_tc_t *); static void atfu_sysvbfs_rmfile_body(const atf_tc_t *); static atf_tc_t atfu_sysvbfs_rmfile_tc; static atf_tc_pack_t atfu_sysvbfs_rmfile_tc_pack = { .m_ident = &quot;sysvbfs_rmfile&quot;, .m_head = atfu_sysvbfs_rmfile_head, .m_body = atfu_sysvbfs_rmfile_body, .m_cleanup = ((void*)0), }; static void atfu_sysvbfs_rmfile_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;sysvbfs&quot;&quot; test for &quot;&quot;remove file from r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;sysvbfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;sysvbfs&quot;); } void *sysvbfsrmfiletmp; static void atfu_sysvbfs_rmfile_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;sysvbfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (sysvbfs_fstest_newfs(tc, &amp;sysvbfsrmfiletmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfsrmfiletmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfsrmfiletmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); rmfile(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_udf_rmfile_head(atf_tc_t *); static void atfu_udf_rmfile_body(const atf_tc_t *); static atf_tc_t atfu_udf_rmfile_tc; static atf_tc_pack_t atfu_udf_rmfile_tc_pack = { .m_ident = &quot;udf_rmfile&quot;, .m_head = atfu_udf_rmfile_head, .m_body = atfu_udf_rmfile_body, .m_cleanup = ((void*)0), }; static void atfu_udf_rmfile_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;udf&quot;&quot; test for &quot;&quot;remove file from r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;udf&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;udf&quot;); } void *udfrmfiletmp; static void atfu_udf_rmfile_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;udf&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (udf_fstest_newfs(tc, &amp;udfrmfiletmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (udf_fstest_mount(tc, udfrmfiletmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (udf_fstest_mount(tc, udfrmfiletmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); rmfile(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_v7fs_rmfile_head(atf_tc_t *); static void atfu_v7fs_rmfile_body(const atf_tc_t *); static atf_tc_t atfu_v7fs_rmfile_tc; static atf_tc_pack_t atfu_v7fs_rmfile_tc_pack = { .m_ident = &quot;v7fs_rmfile&quot;, .m_head = atfu_v7fs_rmfile_head, .m_body = atfu_v7fs_rmfile_body, .m_cleanup = ((void*)0), }; static void atfu_v7fs_rmfile_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;v7fs&quot;&quot; test for &quot;&quot;remove file from r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;v7fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;v7fs&quot;); } void *v7fsrmfiletmp; static void atfu_v7fs_rmfile_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;v7fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (v7fs_fstest_newfs(tc, &amp;v7fsrmfiletmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (v7fs_fstest_mount(tc, v7fsrmfiletmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (v7fs_fstest_mount(tc, v7fsrmfiletmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); rmfile(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } }" data-ref="_M/ATF_TC_FSAPPLY_RO">ATF_TC_FSAPPLY_RO</a>(<a class="tu ref fn" href="#rmfile" title='rmfile' data-use='c' data-ref="rmfile" data-ref-filename="rmfile">rmfile</a>, <q>"remove file from r/o mount"</q>, <a class="tu ref fn" href="#filegen" title='filegen' data-use='c' data-ref="filegen" data-ref-filename="filegen">filegen</a>);</td></tr>
<tr><th id="184">184</th><td><a class="macro" href="../common/h_fsmacros.h.html#218" title="static void atfu_ext2fs_fileio_head(atf_tc_t *); static void atfu_ext2fs_fileio_body(const atf_tc_t *); static atf_tc_t atfu_ext2fs_fileio_tc; static atf_tc_pack_t atfu_ext2fs_fileio_tc_pack = { .m_ident = &quot;ext2fs_fileio&quot;, .m_head = atfu_ext2fs_fileio_head, .m_body = atfu_ext2fs_fileio_body, .m_cleanup = ((void*)0), }; static void atfu_ext2fs_fileio_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ext2fs&quot;&quot; test for &quot;&quot;can read a file but not write it&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ext2fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ext2fs&quot;); } void *ext2fsfileiotmp; static void atfu_ext2fs_fileio_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ext2fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ext2fs_fstest_newfs(tc, &amp;ext2fsfileiotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ext2fs_fstest_mount(tc, ext2fsfileiotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ext2fs_fstest_mount(tc, ext2fsfileiotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); fileio(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffs_fileio_head(atf_tc_t *); static void atfu_ffs_fileio_body(const atf_tc_t *); static atf_tc_t atfu_ffs_fileio_tc; static atf_tc_pack_t atfu_ffs_fileio_tc_pack = { .m_ident = &quot;ffs_fileio&quot;, .m_head = atfu_ffs_fileio_head, .m_body = atfu_ffs_fileio_body, .m_cleanup = ((void*)0), }; static void atfu_ffs_fileio_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;can read a file but not write it&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffsfileiotmp; static void atfu_ffs_fileio_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffs_fstest_newfs(tc, &amp;ffsfileiotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffs_fstest_mount(tc, ffsfileiotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffs_fstest_mount(tc, ffsfileiotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); fileio(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffslog_fileio_head(atf_tc_t *); static void atfu_ffslog_fileio_body(const atf_tc_t *); static atf_tc_t atfu_ffslog_fileio_tc; static atf_tc_pack_t atfu_ffslog_fileio_tc_pack = { .m_ident = &quot;ffslog_fileio&quot;, .m_head = atfu_ffslog_fileio_head, .m_body = atfu_ffslog_fileio_body, .m_cleanup = ((void*)0), }; static void atfu_ffslog_fileio_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;can read a file but not write it&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffslog&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffslogfileiotmp; static void atfu_ffslog_fileio_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffslog&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffslog_fstest_newfs(tc, &amp;ffslogfileiotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffslog_fstest_mount(tc, ffslogfileiotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffslog_fstest_mount(tc, ffslogfileiotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); fileio(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_msdosfs_fileio_head(atf_tc_t *); static void atfu_msdosfs_fileio_body(const atf_tc_t *); static atf_tc_t atfu_msdosfs_fileio_tc; static atf_tc_pack_t atfu_msdosfs_fileio_tc_pack = { .m_ident = &quot;msdosfs_fileio&quot;, .m_head = atfu_msdosfs_fileio_head, .m_body = atfu_msdosfs_fileio_body, .m_cleanup = ((void*)0), }; static void atfu_msdosfs_fileio_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;msdos&quot;&quot; test for &quot;&quot;can read a file but not write it&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;msdosfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;msdos&quot;); } void *msdosfsfileiotmp; static void atfu_msdosfs_fileio_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;msdosfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (msdosfs_fstest_newfs(tc, &amp;msdosfsfileiotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (msdosfs_fstest_mount(tc, msdosfsfileiotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (msdosfs_fstest_mount(tc, msdosfsfileiotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); fileio(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfs_fileio_head(atf_tc_t *); static void atfu_nfs_fileio_body(const atf_tc_t *); static atf_tc_t atfu_nfs_fileio_tc; static atf_tc_pack_t atfu_nfs_fileio_tc_pack = { .m_ident = &quot;nfs_fileio&quot;, .m_head = atfu_nfs_fileio_head, .m_body = atfu_nfs_fileio_body, .m_cleanup = ((void*)0), }; static void atfu_nfs_fileio_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;can read a file but not write it&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsfileiotmp; static void atfu_nfs_fileio_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfs_fstest_newfs(tc, &amp;nfsfileiotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfs_fstest_mount(tc, nfsfileiotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfs_fstest_mount(tc, nfsfileiotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); fileio(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfsro_fileio_head(atf_tc_t *); static void atfu_nfsro_fileio_body(const atf_tc_t *); static atf_tc_t atfu_nfsro_fileio_tc; static atf_tc_pack_t atfu_nfsro_fileio_tc_pack = { .m_ident = &quot;nfsro_fileio&quot;, .m_head = atfu_nfsro_fileio_head, .m_body = atfu_nfsro_fileio_body, .m_cleanup = ((void*)0), }; static void atfu_nfsro_fileio_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;can read a file but not write it&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfsro&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsrofileiotmp; static void atfu_nfsro_fileio_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfsro&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfsro_fstest_newfs(tc, &amp;nfsrofileiotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfsro_fstest_mount(tc, nfsrofileiotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfsro_fstest_mount(tc, nfsrofileiotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); fileio(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_sysvbfs_fileio_head(atf_tc_t *); static void atfu_sysvbfs_fileio_body(const atf_tc_t *); static atf_tc_t atfu_sysvbfs_fileio_tc; static atf_tc_pack_t atfu_sysvbfs_fileio_tc_pack = { .m_ident = &quot;sysvbfs_fileio&quot;, .m_head = atfu_sysvbfs_fileio_head, .m_body = atfu_sysvbfs_fileio_body, .m_cleanup = ((void*)0), }; static void atfu_sysvbfs_fileio_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;sysvbfs&quot;&quot; test for &quot;&quot;can read a file but not write it&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;sysvbfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;sysvbfs&quot;); } void *sysvbfsfileiotmp; static void atfu_sysvbfs_fileio_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;sysvbfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (sysvbfs_fstest_newfs(tc, &amp;sysvbfsfileiotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfsfileiotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfsfileiotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); fileio(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_udf_fileio_head(atf_tc_t *); static void atfu_udf_fileio_body(const atf_tc_t *); static atf_tc_t atfu_udf_fileio_tc; static atf_tc_pack_t atfu_udf_fileio_tc_pack = { .m_ident = &quot;udf_fileio&quot;, .m_head = atfu_udf_fileio_head, .m_body = atfu_udf_fileio_body, .m_cleanup = ((void*)0), }; static void atfu_udf_fileio_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;udf&quot;&quot; test for &quot;&quot;can read a file but not write it&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;udf&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;udf&quot;); } void *udffileiotmp; static void atfu_udf_fileio_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;udf&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (udf_fstest_newfs(tc, &amp;udffileiotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (udf_fstest_mount(tc, udffileiotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (udf_fstest_mount(tc, udffileiotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); fileio(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_v7fs_fileio_head(atf_tc_t *); static void atfu_v7fs_fileio_body(const atf_tc_t *); static atf_tc_t atfu_v7fs_fileio_tc; static atf_tc_pack_t atfu_v7fs_fileio_tc_pack = { .m_ident = &quot;v7fs_fileio&quot;, .m_head = atfu_v7fs_fileio_head, .m_body = atfu_v7fs_fileio_body, .m_cleanup = ((void*)0), }; static void atfu_v7fs_fileio_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;v7fs&quot;&quot; test for &quot;&quot;can read a file but not write it&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;v7fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;v7fs&quot;); } void *v7fsfileiotmp; static void atfu_v7fs_fileio_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;v7fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (v7fs_fstest_newfs(tc, &amp;v7fsfileiotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (v7fs_fstest_mount(tc, v7fsfileiotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (v7fs_fstest_mount(tc, v7fsfileiotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); fileio(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } }" data-ref="_M/ATF_TC_FSAPPLY_RO">ATF_TC_FSAPPLY_RO</a>(<a class="tu ref fn" href="#fileio" title='fileio' data-use='c' data-ref="fileio" data-ref-filename="fileio">fileio</a>, <q>"can read a file but not write it"</q>, <a class="tu ref fn" href="#filegen" title='filegen' data-use='c' data-ref="filegen" data-ref-filename="filegen">filegen</a>);</td></tr>
<tr><th id="185">185</th><td><a class="macro" href="../common/h_fsmacros.h.html#218" title="static void atfu_ext2fs_attrs_head(atf_tc_t *); static void atfu_ext2fs_attrs_body(const atf_tc_t *); static atf_tc_t atfu_ext2fs_attrs_tc; static atf_tc_pack_t atfu_ext2fs_attrs_tc_pack = { .m_ident = &quot;ext2fs_attrs&quot;, .m_head = atfu_ext2fs_attrs_head, .m_body = atfu_ext2fs_attrs_body, .m_cleanup = ((void*)0), }; static void atfu_ext2fs_attrs_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ext2fs&quot;&quot; test for &quot;&quot;can query but not change attributes&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ext2fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ext2fs&quot;); } void *ext2fsattrstmp; static void atfu_ext2fs_attrs_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ext2fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ext2fs_fstest_newfs(tc, &amp;ext2fsattrstmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ext2fs_fstest_mount(tc, ext2fsattrstmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ext2fs_fstest_mount(tc, ext2fsattrstmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); attrs(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffs_attrs_head(atf_tc_t *); static void atfu_ffs_attrs_body(const atf_tc_t *); static atf_tc_t atfu_ffs_attrs_tc; static atf_tc_pack_t atfu_ffs_attrs_tc_pack = { .m_ident = &quot;ffs_attrs&quot;, .m_head = atfu_ffs_attrs_head, .m_body = atfu_ffs_attrs_body, .m_cleanup = ((void*)0), }; static void atfu_ffs_attrs_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;can query but not change attributes&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffsattrstmp; static void atfu_ffs_attrs_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffs_fstest_newfs(tc, &amp;ffsattrstmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffs_fstest_mount(tc, ffsattrstmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffs_fstest_mount(tc, ffsattrstmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); attrs(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffslog_attrs_head(atf_tc_t *); static void atfu_ffslog_attrs_body(const atf_tc_t *); static atf_tc_t atfu_ffslog_attrs_tc; static atf_tc_pack_t atfu_ffslog_attrs_tc_pack = { .m_ident = &quot;ffslog_attrs&quot;, .m_head = atfu_ffslog_attrs_head, .m_body = atfu_ffslog_attrs_body, .m_cleanup = ((void*)0), }; static void atfu_ffslog_attrs_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;can query but not change attributes&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffslog&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffslogattrstmp; static void atfu_ffslog_attrs_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffslog&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffslog_fstest_newfs(tc, &amp;ffslogattrstmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffslog_fstest_mount(tc, ffslogattrstmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffslog_fstest_mount(tc, ffslogattrstmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); attrs(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_msdosfs_attrs_head(atf_tc_t *); static void atfu_msdosfs_attrs_body(const atf_tc_t *); static atf_tc_t atfu_msdosfs_attrs_tc; static atf_tc_pack_t atfu_msdosfs_attrs_tc_pack = { .m_ident = &quot;msdosfs_attrs&quot;, .m_head = atfu_msdosfs_attrs_head, .m_body = atfu_msdosfs_attrs_body, .m_cleanup = ((void*)0), }; static void atfu_msdosfs_attrs_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;msdos&quot;&quot; test for &quot;&quot;can query but not change attributes&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;msdosfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;msdos&quot;); } void *msdosfsattrstmp; static void atfu_msdosfs_attrs_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;msdosfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (msdosfs_fstest_newfs(tc, &amp;msdosfsattrstmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (msdosfs_fstest_mount(tc, msdosfsattrstmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (msdosfs_fstest_mount(tc, msdosfsattrstmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); attrs(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfs_attrs_head(atf_tc_t *); static void atfu_nfs_attrs_body(const atf_tc_t *); static atf_tc_t atfu_nfs_attrs_tc; static atf_tc_pack_t atfu_nfs_attrs_tc_pack = { .m_ident = &quot;nfs_attrs&quot;, .m_head = atfu_nfs_attrs_head, .m_body = atfu_nfs_attrs_body, .m_cleanup = ((void*)0), }; static void atfu_nfs_attrs_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;can query but not change attributes&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsattrstmp; static void atfu_nfs_attrs_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfs_fstest_newfs(tc, &amp;nfsattrstmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfs_fstest_mount(tc, nfsattrstmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfs_fstest_mount(tc, nfsattrstmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); attrs(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfsro_attrs_head(atf_tc_t *); static void atfu_nfsro_attrs_body(const atf_tc_t *); static atf_tc_t atfu_nfsro_attrs_tc; static atf_tc_pack_t atfu_nfsro_attrs_tc_pack = { .m_ident = &quot;nfsro_attrs&quot;, .m_head = atfu_nfsro_attrs_head, .m_body = atfu_nfsro_attrs_body, .m_cleanup = ((void*)0), }; static void atfu_nfsro_attrs_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;can query but not change attributes&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfsro&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsroattrstmp; static void atfu_nfsro_attrs_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfsro&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfsro_fstest_newfs(tc, &amp;nfsroattrstmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfsro_fstest_mount(tc, nfsroattrstmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfsro_fstest_mount(tc, nfsroattrstmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); attrs(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_sysvbfs_attrs_head(atf_tc_t *); static void atfu_sysvbfs_attrs_body(const atf_tc_t *); static atf_tc_t atfu_sysvbfs_attrs_tc; static atf_tc_pack_t atfu_sysvbfs_attrs_tc_pack = { .m_ident = &quot;sysvbfs_attrs&quot;, .m_head = atfu_sysvbfs_attrs_head, .m_body = atfu_sysvbfs_attrs_body, .m_cleanup = ((void*)0), }; static void atfu_sysvbfs_attrs_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;sysvbfs&quot;&quot; test for &quot;&quot;can query but not change attributes&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;sysvbfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;sysvbfs&quot;); } void *sysvbfsattrstmp; static void atfu_sysvbfs_attrs_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;sysvbfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (sysvbfs_fstest_newfs(tc, &amp;sysvbfsattrstmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfsattrstmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfsattrstmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); attrs(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_udf_attrs_head(atf_tc_t *); static void atfu_udf_attrs_body(const atf_tc_t *); static atf_tc_t atfu_udf_attrs_tc; static atf_tc_pack_t atfu_udf_attrs_tc_pack = { .m_ident = &quot;udf_attrs&quot;, .m_head = atfu_udf_attrs_head, .m_body = atfu_udf_attrs_body, .m_cleanup = ((void*)0), }; static void atfu_udf_attrs_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;udf&quot;&quot; test for &quot;&quot;can query but not change attributes&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;udf&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;udf&quot;); } void *udfattrstmp; static void atfu_udf_attrs_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;udf&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (udf_fstest_newfs(tc, &amp;udfattrstmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (udf_fstest_mount(tc, udfattrstmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (udf_fstest_mount(tc, udfattrstmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); attrs(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_v7fs_attrs_head(atf_tc_t *); static void atfu_v7fs_attrs_body(const atf_tc_t *); static atf_tc_t atfu_v7fs_attrs_tc; static atf_tc_pack_t atfu_v7fs_attrs_tc_pack = { .m_ident = &quot;v7fs_attrs&quot;, .m_head = atfu_v7fs_attrs_head, .m_body = atfu_v7fs_attrs_body, .m_cleanup = ((void*)0), }; static void atfu_v7fs_attrs_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;v7fs&quot;&quot; test for &quot;&quot;can query but not change attributes&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;v7fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;v7fs&quot;); } void *v7fsattrstmp; static void atfu_v7fs_attrs_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;v7fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (v7fs_fstest_newfs(tc, &amp;v7fsattrstmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (v7fs_fstest_mount(tc, v7fsattrstmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (v7fs_fstest_mount(tc, v7fsattrstmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); attrs(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } }" data-ref="_M/ATF_TC_FSAPPLY_RO">ATF_TC_FSAPPLY_RO</a>(<a class="tu ref fn" href="#attrs" title='attrs' data-use='c' data-ref="attrs" data-ref-filename="attrs">attrs</a>, <q>"can query but not change attributes"</q>, <a class="tu ref fn" href="#filegen" title='filegen' data-use='c' data-ref="filegen" data-ref-filename="filegen">filegen</a>);</td></tr>
<tr><th id="186">186</th><td><a class="macro" href="../common/h_fsmacros.h.html#218" title="static void atfu_ext2fs_createdir_head(atf_tc_t *); static void atfu_ext2fs_createdir_body(const atf_tc_t *); static atf_tc_t atfu_ext2fs_createdir_tc; static atf_tc_pack_t atfu_ext2fs_createdir_tc_pack = { .m_ident = &quot;ext2fs_createdir&quot;, .m_head = atfu_ext2fs_createdir_head, .m_body = atfu_ext2fs_createdir_body, .m_cleanup = ((void*)0), }; static void atfu_ext2fs_createdir_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ext2fs&quot;&quot; test for &quot;&quot;create directory on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ext2fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ext2fs&quot;); } void *ext2fscreatedirtmp; static void atfu_ext2fs_createdir_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ext2fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ext2fs_fstest_newfs(tc, &amp;ext2fscreatedirtmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ext2fs_fstest_mount(tc, ext2fscreatedirtmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ext2fs_fstest_mount(tc, ext2fscreatedirtmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createdir(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffs_createdir_head(atf_tc_t *); static void atfu_ffs_createdir_body(const atf_tc_t *); static atf_tc_t atfu_ffs_createdir_tc; static atf_tc_pack_t atfu_ffs_createdir_tc_pack = { .m_ident = &quot;ffs_createdir&quot;, .m_head = atfu_ffs_createdir_head, .m_body = atfu_ffs_createdir_body, .m_cleanup = ((void*)0), }; static void atfu_ffs_createdir_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;create directory on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffscreatedirtmp; static void atfu_ffs_createdir_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffs_fstest_newfs(tc, &amp;ffscreatedirtmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffs_fstest_mount(tc, ffscreatedirtmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffs_fstest_mount(tc, ffscreatedirtmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createdir(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffslog_createdir_head(atf_tc_t *); static void atfu_ffslog_createdir_body(const atf_tc_t *); static atf_tc_t atfu_ffslog_createdir_tc; static atf_tc_pack_t atfu_ffslog_createdir_tc_pack = { .m_ident = &quot;ffslog_createdir&quot;, .m_head = atfu_ffslog_createdir_head, .m_body = atfu_ffslog_createdir_body, .m_cleanup = ((void*)0), }; static void atfu_ffslog_createdir_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;create directory on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffslog&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffslogcreatedirtmp; static void atfu_ffslog_createdir_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffslog&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffslog_fstest_newfs(tc, &amp;ffslogcreatedirtmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffslog_fstest_mount(tc, ffslogcreatedirtmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffslog_fstest_mount(tc, ffslogcreatedirtmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createdir(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_msdosfs_createdir_head(atf_tc_t *); static void atfu_msdosfs_createdir_body(const atf_tc_t *); static atf_tc_t atfu_msdosfs_createdir_tc; static atf_tc_pack_t atfu_msdosfs_createdir_tc_pack = { .m_ident = &quot;msdosfs_createdir&quot;, .m_head = atfu_msdosfs_createdir_head, .m_body = atfu_msdosfs_createdir_body, .m_cleanup = ((void*)0), }; static void atfu_msdosfs_createdir_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;msdos&quot;&quot; test for &quot;&quot;create directory on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;msdosfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;msdos&quot;); } void *msdosfscreatedirtmp; static void atfu_msdosfs_createdir_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;msdosfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (msdosfs_fstest_newfs(tc, &amp;msdosfscreatedirtmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (msdosfs_fstest_mount(tc, msdosfscreatedirtmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (msdosfs_fstest_mount(tc, msdosfscreatedirtmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createdir(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfs_createdir_head(atf_tc_t *); static void atfu_nfs_createdir_body(const atf_tc_t *); static atf_tc_t atfu_nfs_createdir_tc; static atf_tc_pack_t atfu_nfs_createdir_tc_pack = { .m_ident = &quot;nfs_createdir&quot;, .m_head = atfu_nfs_createdir_head, .m_body = atfu_nfs_createdir_body, .m_cleanup = ((void*)0), }; static void atfu_nfs_createdir_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;create directory on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfscreatedirtmp; static void atfu_nfs_createdir_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfs_fstest_newfs(tc, &amp;nfscreatedirtmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfs_fstest_mount(tc, nfscreatedirtmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfs_fstest_mount(tc, nfscreatedirtmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createdir(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfsro_createdir_head(atf_tc_t *); static void atfu_nfsro_createdir_body(const atf_tc_t *); static atf_tc_t atfu_nfsro_createdir_tc; static atf_tc_pack_t atfu_nfsro_createdir_tc_pack = { .m_ident = &quot;nfsro_createdir&quot;, .m_head = atfu_nfsro_createdir_head, .m_body = atfu_nfsro_createdir_body, .m_cleanup = ((void*)0), }; static void atfu_nfsro_createdir_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;create directory on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfsro&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsrocreatedirtmp; static void atfu_nfsro_createdir_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfsro&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfsro_fstest_newfs(tc, &amp;nfsrocreatedirtmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfsro_fstest_mount(tc, nfsrocreatedirtmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfsro_fstest_mount(tc, nfsrocreatedirtmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createdir(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_sysvbfs_createdir_head(atf_tc_t *); static void atfu_sysvbfs_createdir_body(const atf_tc_t *); static atf_tc_t atfu_sysvbfs_createdir_tc; static atf_tc_pack_t atfu_sysvbfs_createdir_tc_pack = { .m_ident = &quot;sysvbfs_createdir&quot;, .m_head = atfu_sysvbfs_createdir_head, .m_body = atfu_sysvbfs_createdir_body, .m_cleanup = ((void*)0), }; static void atfu_sysvbfs_createdir_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;sysvbfs&quot;&quot; test for &quot;&quot;create directory on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;sysvbfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;sysvbfs&quot;); } void *sysvbfscreatedirtmp; static void atfu_sysvbfs_createdir_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;sysvbfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (sysvbfs_fstest_newfs(tc, &amp;sysvbfscreatedirtmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfscreatedirtmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfscreatedirtmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createdir(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_udf_createdir_head(atf_tc_t *); static void atfu_udf_createdir_body(const atf_tc_t *); static atf_tc_t atfu_udf_createdir_tc; static atf_tc_pack_t atfu_udf_createdir_tc_pack = { .m_ident = &quot;udf_createdir&quot;, .m_head = atfu_udf_createdir_head, .m_body = atfu_udf_createdir_body, .m_cleanup = ((void*)0), }; static void atfu_udf_createdir_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;udf&quot;&quot; test for &quot;&quot;create directory on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;udf&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;udf&quot;); } void *udfcreatedirtmp; static void atfu_udf_createdir_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;udf&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (udf_fstest_newfs(tc, &amp;udfcreatedirtmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (udf_fstest_mount(tc, udfcreatedirtmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (udf_fstest_mount(tc, udfcreatedirtmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createdir(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_v7fs_createdir_head(atf_tc_t *); static void atfu_v7fs_createdir_body(const atf_tc_t *); static atf_tc_t atfu_v7fs_createdir_tc; static atf_tc_pack_t atfu_v7fs_createdir_tc_pack = { .m_ident = &quot;v7fs_createdir&quot;, .m_head = atfu_v7fs_createdir_head, .m_body = atfu_v7fs_createdir_body, .m_cleanup = ((void*)0), }; static void atfu_v7fs_createdir_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;v7fs&quot;&quot; test for &quot;&quot;create directory on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;v7fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;v7fs&quot;); } void *v7fscreatedirtmp; static void atfu_v7fs_createdir_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;v7fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (v7fs_fstest_newfs(tc, &amp;v7fscreatedirtmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (v7fs_fstest_mount(tc, v7fscreatedirtmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (v7fs_fstest_mount(tc, v7fscreatedirtmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createdir(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } }" data-ref="_M/ATF_TC_FSAPPLY_RO">ATF_TC_FSAPPLY_RO</a>(<a class="tu ref fn" href="#createdir" title='createdir' data-use='c' data-ref="createdir" data-ref-filename="createdir">createdir</a>, <q>"create directory on r/o mount"</q>, <a class="tu ref fn" href="#nullgen" title='nullgen' data-use='c' data-ref="nullgen" data-ref-filename="nullgen">nullgen</a>);</td></tr>
<tr><th id="187">187</th><td><a class="macro" href="../common/h_fsmacros.h.html#218" title="static void atfu_ext2fs_createfifo_head(atf_tc_t *); static void atfu_ext2fs_createfifo_body(const atf_tc_t *); static atf_tc_t atfu_ext2fs_createfifo_tc; static atf_tc_pack_t atfu_ext2fs_createfifo_tc_pack = { .m_ident = &quot;ext2fs_createfifo&quot;, .m_head = atfu_ext2fs_createfifo_head, .m_body = atfu_ext2fs_createfifo_body, .m_cleanup = ((void*)0), }; static void atfu_ext2fs_createfifo_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ext2fs&quot;&quot; test for &quot;&quot;create fifo on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ext2fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ext2fs&quot;); } void *ext2fscreatefifotmp; static void atfu_ext2fs_createfifo_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ext2fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ext2fs_fstest_newfs(tc, &amp;ext2fscreatefifotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ext2fs_fstest_mount(tc, ext2fscreatefifotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ext2fs_fstest_mount(tc, ext2fscreatefifotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createfifo(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffs_createfifo_head(atf_tc_t *); static void atfu_ffs_createfifo_body(const atf_tc_t *); static atf_tc_t atfu_ffs_createfifo_tc; static atf_tc_pack_t atfu_ffs_createfifo_tc_pack = { .m_ident = &quot;ffs_createfifo&quot;, .m_head = atfu_ffs_createfifo_head, .m_body = atfu_ffs_createfifo_body, .m_cleanup = ((void*)0), }; static void atfu_ffs_createfifo_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;create fifo on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffscreatefifotmp; static void atfu_ffs_createfifo_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffs_fstest_newfs(tc, &amp;ffscreatefifotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffs_fstest_mount(tc, ffscreatefifotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffs_fstest_mount(tc, ffscreatefifotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createfifo(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffslog_createfifo_head(atf_tc_t *); static void atfu_ffslog_createfifo_body(const atf_tc_t *); static atf_tc_t atfu_ffslog_createfifo_tc; static atf_tc_pack_t atfu_ffslog_createfifo_tc_pack = { .m_ident = &quot;ffslog_createfifo&quot;, .m_head = atfu_ffslog_createfifo_head, .m_body = atfu_ffslog_createfifo_body, .m_cleanup = ((void*)0), }; static void atfu_ffslog_createfifo_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;create fifo on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffslog&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffslogcreatefifotmp; static void atfu_ffslog_createfifo_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffslog&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffslog_fstest_newfs(tc, &amp;ffslogcreatefifotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffslog_fstest_mount(tc, ffslogcreatefifotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffslog_fstest_mount(tc, ffslogcreatefifotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createfifo(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_msdosfs_createfifo_head(atf_tc_t *); static void atfu_msdosfs_createfifo_body(const atf_tc_t *); static atf_tc_t atfu_msdosfs_createfifo_tc; static atf_tc_pack_t atfu_msdosfs_createfifo_tc_pack = { .m_ident = &quot;msdosfs_createfifo&quot;, .m_head = atfu_msdosfs_createfifo_head, .m_body = atfu_msdosfs_createfifo_body, .m_cleanup = ((void*)0), }; static void atfu_msdosfs_createfifo_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;msdos&quot;&quot; test for &quot;&quot;create fifo on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;msdosfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;msdos&quot;); } void *msdosfscreatefifotmp; static void atfu_msdosfs_createfifo_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;msdosfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (msdosfs_fstest_newfs(tc, &amp;msdosfscreatefifotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (msdosfs_fstest_mount(tc, msdosfscreatefifotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (msdosfs_fstest_mount(tc, msdosfscreatefifotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createfifo(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfs_createfifo_head(atf_tc_t *); static void atfu_nfs_createfifo_body(const atf_tc_t *); static atf_tc_t atfu_nfs_createfifo_tc; static atf_tc_pack_t atfu_nfs_createfifo_tc_pack = { .m_ident = &quot;nfs_createfifo&quot;, .m_head = atfu_nfs_createfifo_head, .m_body = atfu_nfs_createfifo_body, .m_cleanup = ((void*)0), }; static void atfu_nfs_createfifo_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;create fifo on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfscreatefifotmp; static void atfu_nfs_createfifo_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfs_fstest_newfs(tc, &amp;nfscreatefifotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfs_fstest_mount(tc, nfscreatefifotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfs_fstest_mount(tc, nfscreatefifotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createfifo(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfsro_createfifo_head(atf_tc_t *); static void atfu_nfsro_createfifo_body(const atf_tc_t *); static atf_tc_t atfu_nfsro_createfifo_tc; static atf_tc_pack_t atfu_nfsro_createfifo_tc_pack = { .m_ident = &quot;nfsro_createfifo&quot;, .m_head = atfu_nfsro_createfifo_head, .m_body = atfu_nfsro_createfifo_body, .m_cleanup = ((void*)0), }; static void atfu_nfsro_createfifo_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;create fifo on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfsro&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsrocreatefifotmp; static void atfu_nfsro_createfifo_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfsro&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfsro_fstest_newfs(tc, &amp;nfsrocreatefifotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfsro_fstest_mount(tc, nfsrocreatefifotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfsro_fstest_mount(tc, nfsrocreatefifotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createfifo(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_sysvbfs_createfifo_head(atf_tc_t *); static void atfu_sysvbfs_createfifo_body(const atf_tc_t *); static atf_tc_t atfu_sysvbfs_createfifo_tc; static atf_tc_pack_t atfu_sysvbfs_createfifo_tc_pack = { .m_ident = &quot;sysvbfs_createfifo&quot;, .m_head = atfu_sysvbfs_createfifo_head, .m_body = atfu_sysvbfs_createfifo_body, .m_cleanup = ((void*)0), }; static void atfu_sysvbfs_createfifo_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;sysvbfs&quot;&quot; test for &quot;&quot;create fifo on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;sysvbfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;sysvbfs&quot;); } void *sysvbfscreatefifotmp; static void atfu_sysvbfs_createfifo_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;sysvbfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (sysvbfs_fstest_newfs(tc, &amp;sysvbfscreatefifotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfscreatefifotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfscreatefifotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createfifo(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_udf_createfifo_head(atf_tc_t *); static void atfu_udf_createfifo_body(const atf_tc_t *); static atf_tc_t atfu_udf_createfifo_tc; static atf_tc_pack_t atfu_udf_createfifo_tc_pack = { .m_ident = &quot;udf_createfifo&quot;, .m_head = atfu_udf_createfifo_head, .m_body = atfu_udf_createfifo_body, .m_cleanup = ((void*)0), }; static void atfu_udf_createfifo_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;udf&quot;&quot; test for &quot;&quot;create fifo on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;udf&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;udf&quot;); } void *udfcreatefifotmp; static void atfu_udf_createfifo_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;udf&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (udf_fstest_newfs(tc, &amp;udfcreatefifotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (udf_fstest_mount(tc, udfcreatefifotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (udf_fstest_mount(tc, udfcreatefifotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createfifo(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_v7fs_createfifo_head(atf_tc_t *); static void atfu_v7fs_createfifo_body(const atf_tc_t *); static atf_tc_t atfu_v7fs_createfifo_tc; static atf_tc_pack_t atfu_v7fs_createfifo_tc_pack = { .m_ident = &quot;v7fs_createfifo&quot;, .m_head = atfu_v7fs_createfifo_head, .m_body = atfu_v7fs_createfifo_body, .m_cleanup = ((void*)0), }; static void atfu_v7fs_createfifo_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;v7fs&quot;&quot; test for &quot;&quot;create fifo on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;v7fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;v7fs&quot;); } void *v7fscreatefifotmp; static void atfu_v7fs_createfifo_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;v7fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (v7fs_fstest_newfs(tc, &amp;v7fscreatefifotmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (v7fs_fstest_mount(tc, v7fscreatefifotmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (v7fs_fstest_mount(tc, v7fscreatefifotmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createfifo(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } }" data-ref="_M/ATF_TC_FSAPPLY_RO">ATF_TC_FSAPPLY_RO</a>(<a class="tu ref fn" href="#createfifo" title='createfifo' data-use='c' data-ref="createfifo" data-ref-filename="createfifo">createfifo</a>, <q>"create fifo on r/o mount"</q>, <a class="tu ref fn" href="#nullgen" title='nullgen' data-use='c' data-ref="nullgen" data-ref-filename="nullgen">nullgen</a>);</td></tr>
<tr><th id="188">188</th><td><a class="macro" href="../common/h_fsmacros.h.html#218" title="static void atfu_ext2fs_createsymlink_head(atf_tc_t *); static void atfu_ext2fs_createsymlink_body(const atf_tc_t *); static atf_tc_t atfu_ext2fs_createsymlink_tc; static atf_tc_pack_t atfu_ext2fs_createsymlink_tc_pack = { .m_ident = &quot;ext2fs_createsymlink&quot;, .m_head = atfu_ext2fs_createsymlink_head, .m_body = atfu_ext2fs_createsymlink_body, .m_cleanup = ((void*)0), }; static void atfu_ext2fs_createsymlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ext2fs&quot;&quot; test for &quot;&quot;create symlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ext2fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ext2fs&quot;); } void *ext2fscreatesymlinktmp; static void atfu_ext2fs_createsymlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ext2fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ext2fs_fstest_newfs(tc, &amp;ext2fscreatesymlinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ext2fs_fstest_mount(tc, ext2fscreatesymlinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ext2fs_fstest_mount(tc, ext2fscreatesymlinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createsymlink(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffs_createsymlink_head(atf_tc_t *); static void atfu_ffs_createsymlink_body(const atf_tc_t *); static atf_tc_t atfu_ffs_createsymlink_tc; static atf_tc_pack_t atfu_ffs_createsymlink_tc_pack = { .m_ident = &quot;ffs_createsymlink&quot;, .m_head = atfu_ffs_createsymlink_head, .m_body = atfu_ffs_createsymlink_body, .m_cleanup = ((void*)0), }; static void atfu_ffs_createsymlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;create symlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffscreatesymlinktmp; static void atfu_ffs_createsymlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffs_fstest_newfs(tc, &amp;ffscreatesymlinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffs_fstest_mount(tc, ffscreatesymlinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffs_fstest_mount(tc, ffscreatesymlinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createsymlink(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffslog_createsymlink_head(atf_tc_t *); static void atfu_ffslog_createsymlink_body(const atf_tc_t *); static atf_tc_t atfu_ffslog_createsymlink_tc; static atf_tc_pack_t atfu_ffslog_createsymlink_tc_pack = { .m_ident = &quot;ffslog_createsymlink&quot;, .m_head = atfu_ffslog_createsymlink_head, .m_body = atfu_ffslog_createsymlink_body, .m_cleanup = ((void*)0), }; static void atfu_ffslog_createsymlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;create symlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffslog&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffslogcreatesymlinktmp; static void atfu_ffslog_createsymlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffslog&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffslog_fstest_newfs(tc, &amp;ffslogcreatesymlinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffslog_fstest_mount(tc, ffslogcreatesymlinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffslog_fstest_mount(tc, ffslogcreatesymlinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createsymlink(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_msdosfs_createsymlink_head(atf_tc_t *); static void atfu_msdosfs_createsymlink_body(const atf_tc_t *); static atf_tc_t atfu_msdosfs_createsymlink_tc; static atf_tc_pack_t atfu_msdosfs_createsymlink_tc_pack = { .m_ident = &quot;msdosfs_createsymlink&quot;, .m_head = atfu_msdosfs_createsymlink_head, .m_body = atfu_msdosfs_createsymlink_body, .m_cleanup = ((void*)0), }; static void atfu_msdosfs_createsymlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;msdos&quot;&quot; test for &quot;&quot;create symlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;msdosfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;msdos&quot;); } void *msdosfscreatesymlinktmp; static void atfu_msdosfs_createsymlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;msdosfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (msdosfs_fstest_newfs(tc, &amp;msdosfscreatesymlinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (msdosfs_fstest_mount(tc, msdosfscreatesymlinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (msdosfs_fstest_mount(tc, msdosfscreatesymlinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createsymlink(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfs_createsymlink_head(atf_tc_t *); static void atfu_nfs_createsymlink_body(const atf_tc_t *); static atf_tc_t atfu_nfs_createsymlink_tc; static atf_tc_pack_t atfu_nfs_createsymlink_tc_pack = { .m_ident = &quot;nfs_createsymlink&quot;, .m_head = atfu_nfs_createsymlink_head, .m_body = atfu_nfs_createsymlink_body, .m_cleanup = ((void*)0), }; static void atfu_nfs_createsymlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;create symlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfscreatesymlinktmp; static void atfu_nfs_createsymlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfs_fstest_newfs(tc, &amp;nfscreatesymlinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfs_fstest_mount(tc, nfscreatesymlinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfs_fstest_mount(tc, nfscreatesymlinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createsymlink(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfsro_createsymlink_head(atf_tc_t *); static void atfu_nfsro_createsymlink_body(const atf_tc_t *); static atf_tc_t atfu_nfsro_createsymlink_tc; static atf_tc_pack_t atfu_nfsro_createsymlink_tc_pack = { .m_ident = &quot;nfsro_createsymlink&quot;, .m_head = atfu_nfsro_createsymlink_head, .m_body = atfu_nfsro_createsymlink_body, .m_cleanup = ((void*)0), }; static void atfu_nfsro_createsymlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;create symlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfsro&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsrocreatesymlinktmp; static void atfu_nfsro_createsymlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfsro&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfsro_fstest_newfs(tc, &amp;nfsrocreatesymlinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfsro_fstest_mount(tc, nfsrocreatesymlinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfsro_fstest_mount(tc, nfsrocreatesymlinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createsymlink(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_sysvbfs_createsymlink_head(atf_tc_t *); static void atfu_sysvbfs_createsymlink_body(const atf_tc_t *); static atf_tc_t atfu_sysvbfs_createsymlink_tc; static atf_tc_pack_t atfu_sysvbfs_createsymlink_tc_pack = { .m_ident = &quot;sysvbfs_createsymlink&quot;, .m_head = atfu_sysvbfs_createsymlink_head, .m_body = atfu_sysvbfs_createsymlink_body, .m_cleanup = ((void*)0), }; static void atfu_sysvbfs_createsymlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;sysvbfs&quot;&quot; test for &quot;&quot;create symlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;sysvbfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;sysvbfs&quot;); } void *sysvbfscreatesymlinktmp; static void atfu_sysvbfs_createsymlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;sysvbfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (sysvbfs_fstest_newfs(tc, &amp;sysvbfscreatesymlinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfscreatesymlinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfscreatesymlinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createsymlink(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_udf_createsymlink_head(atf_tc_t *); static void atfu_udf_createsymlink_body(const atf_tc_t *); static atf_tc_t atfu_udf_createsymlink_tc; static atf_tc_pack_t atfu_udf_createsymlink_tc_pack = { .m_ident = &quot;udf_createsymlink&quot;, .m_head = atfu_udf_createsymlink_head, .m_body = atfu_udf_createsymlink_body, .m_cleanup = ((void*)0), }; static void atfu_udf_createsymlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;udf&quot;&quot; test for &quot;&quot;create symlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;udf&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;udf&quot;); } void *udfcreatesymlinktmp; static void atfu_udf_createsymlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;udf&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (udf_fstest_newfs(tc, &amp;udfcreatesymlinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (udf_fstest_mount(tc, udfcreatesymlinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (udf_fstest_mount(tc, udfcreatesymlinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createsymlink(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_v7fs_createsymlink_head(atf_tc_t *); static void atfu_v7fs_createsymlink_body(const atf_tc_t *); static atf_tc_t atfu_v7fs_createsymlink_tc; static atf_tc_pack_t atfu_v7fs_createsymlink_tc_pack = { .m_ident = &quot;v7fs_createsymlink&quot;, .m_head = atfu_v7fs_createsymlink_head, .m_body = atfu_v7fs_createsymlink_body, .m_cleanup = ((void*)0), }; static void atfu_v7fs_createsymlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;v7fs&quot;&quot; test for &quot;&quot;create symlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;v7fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;v7fs&quot;); } void *v7fscreatesymlinktmp; static void atfu_v7fs_createsymlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;v7fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (v7fs_fstest_newfs(tc, &amp;v7fscreatesymlinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (v7fs_fstest_mount(tc, v7fscreatesymlinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); nullgen(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (v7fs_fstest_mount(tc, v7fscreatesymlinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createsymlink(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } }" data-ref="_M/ATF_TC_FSAPPLY_RO">ATF_TC_FSAPPLY_RO</a>(<a class="tu ref fn" href="#createsymlink" title='createsymlink' data-use='c' data-ref="createsymlink" data-ref-filename="createsymlink">createsymlink</a>, <q>"create symlink on r/o mount"</q>, <a class="tu ref fn" href="#nullgen" title='nullgen' data-use='c' data-ref="nullgen" data-ref-filename="nullgen">nullgen</a>);</td></tr>
<tr><th id="189">189</th><td><a class="macro" href="../common/h_fsmacros.h.html#218" title="static void atfu_ext2fs_createlink_head(atf_tc_t *); static void atfu_ext2fs_createlink_body(const atf_tc_t *); static atf_tc_t atfu_ext2fs_createlink_tc; static atf_tc_pack_t atfu_ext2fs_createlink_tc_pack = { .m_ident = &quot;ext2fs_createlink&quot;, .m_head = atfu_ext2fs_createlink_head, .m_body = atfu_ext2fs_createlink_body, .m_cleanup = ((void*)0), }; static void atfu_ext2fs_createlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ext2fs&quot;&quot; test for &quot;&quot;create hardlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ext2fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ext2fs&quot;); } void *ext2fscreatelinktmp; static void atfu_ext2fs_createlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ext2fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ext2fs_fstest_newfs(tc, &amp;ext2fscreatelinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ext2fs_fstest_mount(tc, ext2fscreatelinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ext2fs_fstest_mount(tc, ext2fscreatelinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createlink(tc,&quot;/mnt&quot;); if (ext2fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffs_createlink_head(atf_tc_t *); static void atfu_ffs_createlink_body(const atf_tc_t *); static atf_tc_t atfu_ffs_createlink_tc; static atf_tc_pack_t atfu_ffs_createlink_tc_pack = { .m_ident = &quot;ffs_createlink&quot;, .m_head = atfu_ffs_createlink_head, .m_body = atfu_ffs_createlink_body, .m_cleanup = ((void*)0), }; static void atfu_ffs_createlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;create hardlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffscreatelinktmp; static void atfu_ffs_createlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffs_fstest_newfs(tc, &amp;ffscreatelinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffs_fstest_mount(tc, ffscreatelinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffs_fstest_mount(tc, ffscreatelinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createlink(tc,&quot;/mnt&quot;); if (ffs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_ffslog_createlink_head(atf_tc_t *); static void atfu_ffslog_createlink_body(const atf_tc_t *); static atf_tc_t atfu_ffslog_createlink_tc; static atf_tc_pack_t atfu_ffslog_createlink_tc_pack = { .m_ident = &quot;ffslog_createlink&quot;, .m_head = atfu_ffslog_createlink_head, .m_body = atfu_ffslog_createlink_body, .m_cleanup = ((void*)0), }; static void atfu_ffslog_createlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;ffs&quot;&quot; test for &quot;&quot;create hardlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;ffslog&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;ffs&quot;); } void *ffslogcreatelinktmp; static void atfu_ffslog_createlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;ffslog&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (ffslog_fstest_newfs(tc, &amp;ffslogcreatelinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (ffslog_fstest_mount(tc, ffslogcreatelinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (ffslog_fstest_mount(tc, ffslogcreatelinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createlink(tc,&quot;/mnt&quot;); if (ffslog_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_msdosfs_createlink_head(atf_tc_t *); static void atfu_msdosfs_createlink_body(const atf_tc_t *); static atf_tc_t atfu_msdosfs_createlink_tc; static atf_tc_pack_t atfu_msdosfs_createlink_tc_pack = { .m_ident = &quot;msdosfs_createlink&quot;, .m_head = atfu_msdosfs_createlink_head, .m_body = atfu_msdosfs_createlink_body, .m_cleanup = ((void*)0), }; static void atfu_msdosfs_createlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;msdos&quot;&quot; test for &quot;&quot;create hardlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;msdosfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;msdos&quot;); } void *msdosfscreatelinktmp; static void atfu_msdosfs_createlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;msdosfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (msdosfs_fstest_newfs(tc, &amp;msdosfscreatelinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (msdosfs_fstest_mount(tc, msdosfscreatelinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (msdosfs_fstest_mount(tc, msdosfscreatelinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createlink(tc,&quot;/mnt&quot;); if (msdosfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfs_createlink_head(atf_tc_t *); static void atfu_nfs_createlink_body(const atf_tc_t *); static atf_tc_t atfu_nfs_createlink_tc; static atf_tc_pack_t atfu_nfs_createlink_tc_pack = { .m_ident = &quot;nfs_createlink&quot;, .m_head = atfu_nfs_createlink_head, .m_body = atfu_nfs_createlink_body, .m_cleanup = ((void*)0), }; static void atfu_nfs_createlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;create hardlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfscreatelinktmp; static void atfu_nfs_createlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfs_fstest_newfs(tc, &amp;nfscreatelinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfs_fstest_mount(tc, nfscreatelinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfs_fstest_mount(tc, nfscreatelinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createlink(tc,&quot;/mnt&quot;); if (nfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_nfsro_createlink_head(atf_tc_t *); static void atfu_nfsro_createlink_body(const atf_tc_t *); static atf_tc_t atfu_nfsro_createlink_tc; static atf_tc_pack_t atfu_nfsro_createlink_tc_pack = { .m_ident = &quot;nfsro_createlink&quot;, .m_head = atfu_nfsro_createlink_head, .m_body = atfu_nfsro_createlink_body, .m_cleanup = ((void*)0), }; static void atfu_nfsro_createlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;nfs&quot;&quot; test for &quot;&quot;create hardlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;nfsro&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;nfs&quot;); } void *nfsrocreatelinktmp; static void atfu_nfsro_createlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;nfsro&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (nfsro_fstest_newfs(tc, &amp;nfsrocreatelinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (nfsro_fstest_mount(tc, nfsrocreatelinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (nfsro_fstest_mount(tc, nfsrocreatelinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createlink(tc,&quot;/mnt&quot;); if (nfsro_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_sysvbfs_createlink_head(atf_tc_t *); static void atfu_sysvbfs_createlink_body(const atf_tc_t *); static atf_tc_t atfu_sysvbfs_createlink_tc; static atf_tc_pack_t atfu_sysvbfs_createlink_tc_pack = { .m_ident = &quot;sysvbfs_createlink&quot;, .m_head = atfu_sysvbfs_createlink_head, .m_body = atfu_sysvbfs_createlink_body, .m_cleanup = ((void*)0), }; static void atfu_sysvbfs_createlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;sysvbfs&quot;&quot; test for &quot;&quot;create hardlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;sysvbfs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;sysvbfs&quot;); } void *sysvbfscreatelinktmp; static void atfu_sysvbfs_createlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;sysvbfs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (sysvbfs_fstest_newfs(tc, &amp;sysvbfscreatelinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfscreatelinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (sysvbfs_fstest_mount(tc, sysvbfscreatelinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createlink(tc,&quot;/mnt&quot;); if (sysvbfs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_udf_createlink_head(atf_tc_t *); static void atfu_udf_createlink_body(const atf_tc_t *); static atf_tc_t atfu_udf_createlink_tc; static atf_tc_pack_t atfu_udf_createlink_tc_pack = { .m_ident = &quot;udf_createlink&quot;, .m_head = atfu_udf_createlink_head, .m_body = atfu_udf_createlink_body, .m_cleanup = ((void*)0), }; static void atfu_udf_createlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;udf&quot;&quot; test for &quot;&quot;create hardlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;udf&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;udf&quot;); } void *udfcreatelinktmp; static void atfu_udf_createlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;udf&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (udf_fstest_newfs(tc, &amp;udfcreatelinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (udf_fstest_mount(tc, udfcreatelinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (udf_fstest_mount(tc, udfcreatelinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createlink(tc,&quot;/mnt&quot;); if (udf_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } } static void atfu_v7fs_createlink_head(atf_tc_t *); static void atfu_v7fs_createlink_body(const atf_tc_t *); static atf_tc_t atfu_v7fs_createlink_tc; static atf_tc_pack_t atfu_v7fs_createlink_tc_pack = { .m_ident = &quot;v7fs_createlink&quot;, .m_head = atfu_v7fs_createlink_head, .m_body = atfu_v7fs_createlink_body, .m_cleanup = ((void*)0), }; static void atfu_v7fs_createlink_head(atf_tc_t *tc __attribute__((__unused__))) { atf_tc_set_md_var(tc, &quot;descr&quot;,&quot;v7fs&quot;&quot; test for &quot;&quot;create hardlink on r/o mount&quot;); atf_tc_set_md_var(tc, &quot;X-fs.type&quot;, &quot;v7fs&quot;); atf_tc_set_md_var(tc, &quot;X-fs.mntname&quot;, &quot;v7fs&quot;); } void *v7fscreatelinktmp; static void atfu_v7fs_createlink_body(const atf_tc_t *tc __attribute__((__unused__))) { if (!atf_check_fstype(tc, &quot;v7fs&quot;)) atf_tc_skip(&quot;filesystem not selected&quot;); do { if (v7fs_fstest_newfs(tc, &amp;v7fscreatelinktmp, &quot;image.fs&quot;, (10000 * 512), ((void*)0)) != 0) atf_tc_fail_errno(&quot;newfs failed&quot;); if (v7fs_fstest_mount(tc, v7fscreatelinktmp, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;mount failed&quot;); } while ( 0); filegen(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) atf_tc_fail_errno(&quot;unmount r/w failed&quot;); if (v7fs_fstest_mount(tc, v7fscreatelinktmp, &quot;/mnt&quot;, 0x00000001) != 0) atf_tc_fail_errno(&quot;mount ro failed&quot;); createlink(tc,&quot;/mnt&quot;); if (v7fs_fstest_unmount(tc, &quot;/mnt&quot;, 0) != 0) { rump_pub_vfs_mount_print(&quot;/mnt&quot;, 1); atf_tc_fail_errno(&quot;unmount failed&quot;); } }" data-ref="_M/ATF_TC_FSAPPLY_RO">ATF_TC_FSAPPLY_RO</a>(<a class="tu ref fn" href="#createlink" title='createlink' data-use='c' data-ref="createlink" data-ref-filename="createlink">createlink</a>, <q>"create hardlink on r/o mount"</q>, <a class="tu ref fn" href="#filegen" title='filegen' data-use='c' data-ref="filegen" data-ref-filename="filegen">filegen</a>);</td></tr>
<tr><th id="190">190</th><td></td></tr>
<tr><th id="191">191</th><td><a class="macro" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/macros.h.html#104" title="static atf_error_t atfu_tp_add_tcs(atf_tp_t *); int atf_tp_main(int, char **, atf_error_t (*)(atf_tp_t *)); int main(int argc, char **argv) { return atf_tp_main(argc, argv, atfu_tp_add_tcs); } static atf_error_t atfu_tp_add_tcs(atf_tp_t *tp)" data-ref="_M/ATF_TP_ADD_TCS">ATF_TP_ADD_TCS</a>(<dfn class="local col8 decl" id="28tp" title='tp' data-type='atf_tp_t *' data-ref="28tp" data-ref-filename="28tp">tp</dfn>)</td></tr>
<tr><th id="192">192</th><td>{</td></tr>
<tr><th id="193">193</th><td></td></tr>
<tr><th id="194">194</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#229" title="do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ext2fs_create_tc, &amp;atfu_ext2fs_create_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ext2fs_create_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffs_create_tc, &amp;atfu_ffs_create_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffs_create_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffslog_create_tc, &amp;atfu_ffslog_create_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffslog_create_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_msdosfs_create_tc, &amp;atfu_msdosfs_create_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_msdosfs_create_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfs_create_tc, &amp;atfu_nfs_create_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfs_create_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfsro_create_tc, &amp;atfu_nfsro_create_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfsro_create_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_sysvbfs_create_tc, &amp;atfu_sysvbfs_create_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_sysvbfs_create_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_udf_create_tc, &amp;atfu_udf_create_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_udf_create_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_v7fs_create_tc, &amp;atfu_v7fs_create_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_v7fs_create_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0);" data-ref="_M/ATF_TP_FSAPPLY_RO">ATF_TP_FSAPPLY_RO</a>(create);</td></tr>
<tr><th id="195">195</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#229" title="do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ext2fs_rmfile_tc, &amp;atfu_ext2fs_rmfile_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ext2fs_rmfile_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffs_rmfile_tc, &amp;atfu_ffs_rmfile_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffs_rmfile_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffslog_rmfile_tc, &amp;atfu_ffslog_rmfile_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffslog_rmfile_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_msdosfs_rmfile_tc, &amp;atfu_msdosfs_rmfile_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_msdosfs_rmfile_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfs_rmfile_tc, &amp;atfu_nfs_rmfile_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfs_rmfile_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfsro_rmfile_tc, &amp;atfu_nfsro_rmfile_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfsro_rmfile_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_sysvbfs_rmfile_tc, &amp;atfu_sysvbfs_rmfile_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_sysvbfs_rmfile_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_udf_rmfile_tc, &amp;atfu_udf_rmfile_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_udf_rmfile_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_v7fs_rmfile_tc, &amp;atfu_v7fs_rmfile_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_v7fs_rmfile_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0);" data-ref="_M/ATF_TP_FSAPPLY_RO">ATF_TP_FSAPPLY_RO</a>(rmfile);</td></tr>
<tr><th id="196">196</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#229" title="do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ext2fs_fileio_tc, &amp;atfu_ext2fs_fileio_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ext2fs_fileio_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffs_fileio_tc, &amp;atfu_ffs_fileio_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffs_fileio_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffslog_fileio_tc, &amp;atfu_ffslog_fileio_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffslog_fileio_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_msdosfs_fileio_tc, &amp;atfu_msdosfs_fileio_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_msdosfs_fileio_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfs_fileio_tc, &amp;atfu_nfs_fileio_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfs_fileio_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfsro_fileio_tc, &amp;atfu_nfsro_fileio_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfsro_fileio_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_sysvbfs_fileio_tc, &amp;atfu_sysvbfs_fileio_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_sysvbfs_fileio_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_udf_fileio_tc, &amp;atfu_udf_fileio_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_udf_fileio_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_v7fs_fileio_tc, &amp;atfu_v7fs_fileio_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_v7fs_fileio_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0);" data-ref="_M/ATF_TP_FSAPPLY_RO">ATF_TP_FSAPPLY_RO</a>(fileio);</td></tr>
<tr><th id="197">197</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#229" title="do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ext2fs_attrs_tc, &amp;atfu_ext2fs_attrs_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ext2fs_attrs_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffs_attrs_tc, &amp;atfu_ffs_attrs_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffs_attrs_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffslog_attrs_tc, &amp;atfu_ffslog_attrs_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffslog_attrs_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_msdosfs_attrs_tc, &amp;atfu_msdosfs_attrs_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_msdosfs_attrs_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfs_attrs_tc, &amp;atfu_nfs_attrs_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfs_attrs_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfsro_attrs_tc, &amp;atfu_nfsro_attrs_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfsro_attrs_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_sysvbfs_attrs_tc, &amp;atfu_sysvbfs_attrs_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_sysvbfs_attrs_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_udf_attrs_tc, &amp;atfu_udf_attrs_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_udf_attrs_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_v7fs_attrs_tc, &amp;atfu_v7fs_attrs_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_v7fs_attrs_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0);" data-ref="_M/ATF_TP_FSAPPLY_RO">ATF_TP_FSAPPLY_RO</a>(attrs);</td></tr>
<tr><th id="198">198</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#229" title="do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ext2fs_createdir_tc, &amp;atfu_ext2fs_createdir_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ext2fs_createdir_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffs_createdir_tc, &amp;atfu_ffs_createdir_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffs_createdir_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffslog_createdir_tc, &amp;atfu_ffslog_createdir_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffslog_createdir_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_msdosfs_createdir_tc, &amp;atfu_msdosfs_createdir_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_msdosfs_createdir_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfs_createdir_tc, &amp;atfu_nfs_createdir_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfs_createdir_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfsro_createdir_tc, &amp;atfu_nfsro_createdir_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfsro_createdir_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_sysvbfs_createdir_tc, &amp;atfu_sysvbfs_createdir_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_sysvbfs_createdir_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_udf_createdir_tc, &amp;atfu_udf_createdir_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_udf_createdir_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_v7fs_createdir_tc, &amp;atfu_v7fs_createdir_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_v7fs_createdir_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0);" data-ref="_M/ATF_TP_FSAPPLY_RO">ATF_TP_FSAPPLY_RO</a>(createdir);</td></tr>
<tr><th id="199">199</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#229" title="do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ext2fs_createfifo_tc, &amp;atfu_ext2fs_createfifo_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ext2fs_createfifo_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffs_createfifo_tc, &amp;atfu_ffs_createfifo_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffs_createfifo_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffslog_createfifo_tc, &amp;atfu_ffslog_createfifo_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffslog_createfifo_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_msdosfs_createfifo_tc, &amp;atfu_msdosfs_createfifo_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_msdosfs_createfifo_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfs_createfifo_tc, &amp;atfu_nfs_createfifo_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfs_createfifo_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfsro_createfifo_tc, &amp;atfu_nfsro_createfifo_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfsro_createfifo_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_sysvbfs_createfifo_tc, &amp;atfu_sysvbfs_createfifo_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_sysvbfs_createfifo_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_udf_createfifo_tc, &amp;atfu_udf_createfifo_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_udf_createfifo_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_v7fs_createfifo_tc, &amp;atfu_v7fs_createfifo_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_v7fs_createfifo_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0);" data-ref="_M/ATF_TP_FSAPPLY_RO">ATF_TP_FSAPPLY_RO</a>(createfifo);</td></tr>
<tr><th id="200">200</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#229" title="do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ext2fs_createsymlink_tc, &amp;atfu_ext2fs_createsymlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ext2fs_createsymlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffs_createsymlink_tc, &amp;atfu_ffs_createsymlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffs_createsymlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffslog_createsymlink_tc, &amp;atfu_ffslog_createsymlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffslog_createsymlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_msdosfs_createsymlink_tc, &amp;atfu_msdosfs_createsymlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_msdosfs_createsymlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfs_createsymlink_tc, &amp;atfu_nfs_createsymlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfs_createsymlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfsro_createsymlink_tc, &amp;atfu_nfsro_createsymlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfsro_createsymlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_sysvbfs_createsymlink_tc, &amp;atfu_sysvbfs_createsymlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_sysvbfs_createsymlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_udf_createsymlink_tc, &amp;atfu_udf_createsymlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_udf_createsymlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_v7fs_createsymlink_tc, &amp;atfu_v7fs_createsymlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_v7fs_createsymlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0);" data-ref="_M/ATF_TP_FSAPPLY_RO">ATF_TP_FSAPPLY_RO</a>(createsymlink);</td></tr>
<tr><th id="201">201</th><td>	<a class="macro" href="../common/h_fsmacros.h.html#229" title="do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ext2fs_createlink_tc, &amp;atfu_ext2fs_createlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ext2fs_createlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffs_createlink_tc, &amp;atfu_ffs_createlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffs_createlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_ffslog_createlink_tc, &amp;atfu_ffslog_createlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_ffslog_createlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_msdosfs_createlink_tc, &amp;atfu_msdosfs_createlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_msdosfs_createlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfs_createlink_tc, &amp;atfu_nfs_createlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfs_createlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_nfsro_createlink_tc, &amp;atfu_nfsro_createlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_nfsro_createlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_sysvbfs_createlink_tc, &amp;atfu_sysvbfs_createlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_sysvbfs_createlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_udf_createlink_tc, &amp;atfu_udf_createlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_udf_createlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0); do { atf_error_t atfu_err; char **atfu_config = atf_tp_get_config(tp); if (atfu_config == ((void*)0)) return atf_no_memory_error(); atfu_err = atf_tc_init_pack(&amp;atfu_v7fs_createlink_tc, &amp;atfu_v7fs_createlink_tc_pack, (const char *const *)atfu_config); atf_utils_free_charpp(atfu_config); if (atf_is_error(atfu_err)) return atfu_err; atfu_err = atf_tp_add_tc(tp, &amp;atfu_v7fs_createlink_tc); if (atf_is_error(atfu_err)) return atfu_err; } while (0);" data-ref="_M/ATF_TP_FSAPPLY_RO">ATF_TP_FSAPPLY_RO</a>(createlink);</td></tr>
<tr><th id="202">202</th><td></td></tr>
<tr><th id="203">203</th><td>	<b>return</b> <a class="ref fn" href="../../../objdir.amd64/destdir.amd64/usr/include/atf-c/error.h.html#atf_no_error" title='atf_no_error' data-ref="atf_no_error" data-ref-filename="atf_no_error">atf_no_error</a>();</td></tr>
<tr><th id="204">204</th><td>}</td></tr>
<tr><th id="205">205</th><td></td></tr>
</table><hr/><p id='footer'>
Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
