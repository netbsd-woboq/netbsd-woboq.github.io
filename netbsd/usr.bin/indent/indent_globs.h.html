<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>indent_globs.h source code [netbsd/usr.bin/indent/indent_globs.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="options,parser_state "/>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'netbsd/usr.bin/indent/indent_globs.h'; var root_path = '../../..'; var data_path = 'https://code.woboq.org/data'; var ecma_script_api_version = 2;</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../..'>netbsd</a>/<a href='..'>usr.bin</a>/<a href='./'>indent</a>/<a href='indent_globs.h.html'>indent_globs.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*	$NetBSD: indent_globs.h,v 1.11 2019/04/04 15:22:13 kamil Exp $	*/</i></td></tr>
<tr><th id="2">2</th><td></td></tr>
<tr><th id="3">3</th><td><i>/*-</i></td></tr>
<tr><th id="4">4</th><td><i> * SPDX-License-Identifier: BSD-4-Clause</i></td></tr>
<tr><th id="5">5</th><td><i> *</i></td></tr>
<tr><th id="6">6</th><td><i> * Copyright (c) 1985 Sun Microsystems, Inc.</i></td></tr>
<tr><th id="7">7</th><td><i> * Copyright (c) 1980, 1993</i></td></tr>
<tr><th id="8">8</th><td><i> *	The Regents of the University of California.  All rights reserved.</i></td></tr>
<tr><th id="9">9</th><td><i> * All rights reserved.</i></td></tr>
<tr><th id="10">10</th><td><i> *</i></td></tr>
<tr><th id="11">11</th><td><i> * Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="12">12</th><td><i> * modification, are permitted provided that the following conditions</i></td></tr>
<tr><th id="13">13</th><td><i> * are met:</i></td></tr>
<tr><th id="14">14</th><td><i> * 1. Redistributions of source code must retain the above copyright</i></td></tr>
<tr><th id="15">15</th><td><i> *    notice, this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="16">16</th><td><i> * 2. Redistributions in binary form must reproduce the above copyright</i></td></tr>
<tr><th id="17">17</th><td><i> *    notice, this list of conditions and the following disclaimer in the</i></td></tr>
<tr><th id="18">18</th><td><i> *    documentation and/or other materials provided with the distribution.</i></td></tr>
<tr><th id="19">19</th><td><i> * 3. All advertising materials mentioning features or use of this software</i></td></tr>
<tr><th id="20">20</th><td><i> *    must display the following acknowledgement:</i></td></tr>
<tr><th id="21">21</th><td><i> *	This product includes software developed by the University of</i></td></tr>
<tr><th id="22">22</th><td><i> *	California, Berkeley and its contributors.</i></td></tr>
<tr><th id="23">23</th><td><i> * 4. Neither the name of the University nor the names of its contributors</i></td></tr>
<tr><th id="24">24</th><td><i> *    may be used to endorse or promote products derived from this software</i></td></tr>
<tr><th id="25">25</th><td><i> *    without specific prior written permission.</i></td></tr>
<tr><th id="26">26</th><td><i> *</i></td></tr>
<tr><th id="27">27</th><td><i> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</i></td></tr>
<tr><th id="28">28</th><td><i> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</i></td></tr>
<tr><th id="29">29</th><td><i> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</i></td></tr>
<tr><th id="30">30</th><td><i> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</i></td></tr>
<tr><th id="31">31</th><td><i> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</i></td></tr>
<tr><th id="32">32</th><td><i> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</i></td></tr>
<tr><th id="33">33</th><td><i> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</i></td></tr>
<tr><th id="34">34</th><td><i> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</i></td></tr>
<tr><th id="35">35</th><td><i> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</i></td></tr>
<tr><th id="36">36</th><td><i> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</i></td></tr>
<tr><th id="37">37</th><td><i> * SUCH DAMAGE.</i></td></tr>
<tr><th id="38">38</th><td><i> *</i></td></tr>
<tr><th id="39">39</th><td><i> *	@(#)indent_globs.h	8.1 (Berkeley) 6/6/93</i></td></tr>
<tr><th id="40">40</th><td><i> * $FreeBSD: head/usr.bin/indent/indent_globs.h 337651 2018-08-11 19:20:06Z pstef $</i></td></tr>
<tr><th id="41">41</th><td><i> */</i></td></tr>
<tr><th id="42">42</th><td></td></tr>
<tr><th id="43">43</th><td><u>#define <dfn class="macro" id="_M/BACKSLASH" data-ref="_M/BACKSLASH">BACKSLASH</dfn> '\\'</u></td></tr>
<tr><th id="44">44</th><td><u>#define <dfn class="macro" id="_M/bufsize" data-ref="_M/bufsize">bufsize</dfn> 200		/* size of internal buffers */</u></td></tr>
<tr><th id="45">45</th><td><u>#define <dfn class="macro" id="_M/sc_size" data-ref="_M/sc_size">sc_size</dfn> 5000		/* size of save_com buffer */</u></td></tr>
<tr><th id="46">46</th><td><u>#define <dfn class="macro" id="_M/label_offset" data-ref="_M/label_offset">label_offset</dfn> 2		/* number of levels a label is placed to left</u></td></tr>
<tr><th id="47">47</th><td><u>				 * of code */</u></td></tr>
<tr><th id="48">48</th><td></td></tr>
<tr><th id="49">49</th><td></td></tr>
<tr><th id="50">50</th><td><u>#define <dfn class="macro" id="_M/false" data-ref="_M/false">false</dfn> 0</u></td></tr>
<tr><th id="51">51</th><td><u>#define <dfn class="macro" id="_M/true" data-ref="_M/true">true</dfn>  1</u></td></tr>
<tr><th id="52">52</th><td></td></tr>
<tr><th id="53">53</th><td></td></tr>
<tr><th id="54">54</th><td><a class="typedef" href="../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#FILE" title='FILE' data-type='struct __sFILE' data-ref="FILE" data-ref-filename="FILE">FILE</a>       *<dfn class="decl def" id="input" title='input' data-ref="input" data-ref-filename="input">input</dfn>;		<i>/* the fid for the input file */</i></td></tr>
<tr><th id="55">55</th><td><a class="typedef" href="../../objdir.amd64/destdir.amd64/usr/include/stdio.h.html#FILE" title='FILE' data-type='struct __sFILE' data-ref="FILE" data-ref-filename="FILE">FILE</a>       *<dfn class="decl def" id="output" title='output' data-ref="output" data-ref-filename="output">output</dfn>;		<i>/* the output file */</i></td></tr>
<tr><th id="56">56</th><td></td></tr>
<tr><th id="57">57</th><td><u>#define <dfn class="macro" id="_M/CHECK_SIZE_CODE" data-ref="_M/CHECK_SIZE_CODE">CHECK_SIZE_CODE</dfn>(desired_size) \</u></td></tr>
<tr><th id="58">58</th><td><u>	if (e_code + (desired_size) &gt;= l_code) { \</u></td></tr>
<tr><th id="59">59</th><td><u>	    int nsize = l_code-s_code + 400 + desired_size; \</u></td></tr>
<tr><th id="60">60</th><td><u>	    int code_len = e_code-s_code; \</u></td></tr>
<tr><th id="61">61</th><td><u>	    codebuf = (char *) realloc(codebuf, nsize); \</u></td></tr>
<tr><th id="62">62</th><td><u>	    if (codebuf == NULL) \</u></td></tr>
<tr><th id="63">63</th><td><u>		err(1, NULL); \</u></td></tr>
<tr><th id="64">64</th><td><u>	    e_code = codebuf + code_len + 1; \</u></td></tr>
<tr><th id="65">65</th><td><u>	    l_code = codebuf + nsize - 5; \</u></td></tr>
<tr><th id="66">66</th><td><u>	    s_code = codebuf + 1; \</u></td></tr>
<tr><th id="67">67</th><td><u>	}</u></td></tr>
<tr><th id="68">68</th><td><u>#define <dfn class="macro" id="_M/CHECK_SIZE_COM" data-ref="_M/CHECK_SIZE_COM">CHECK_SIZE_COM</dfn>(desired_size) \</u></td></tr>
<tr><th id="69">69</th><td><u>	if (e_com + (desired_size) &gt;= l_com) { \</u></td></tr>
<tr><th id="70">70</th><td><u>	    int nsize = l_com-s_com + 400 + desired_size; \</u></td></tr>
<tr><th id="71">71</th><td><u>	    int com_len = e_com - s_com; \</u></td></tr>
<tr><th id="72">72</th><td><u>	    int blank_pos; \</u></td></tr>
<tr><th id="73">73</th><td><u>	    if (last_bl != NULL) \</u></td></tr>
<tr><th id="74">74</th><td><u>		blank_pos = last_bl - combuf; \</u></td></tr>
<tr><th id="75">75</th><td><u>	    else \</u></td></tr>
<tr><th id="76">76</th><td><u>		blank_pos = -1; \</u></td></tr>
<tr><th id="77">77</th><td><u>	    combuf = (char *) realloc(combuf, nsize); \</u></td></tr>
<tr><th id="78">78</th><td><u>	    if (combuf == NULL) \</u></td></tr>
<tr><th id="79">79</th><td><u>		err(1, NULL); \</u></td></tr>
<tr><th id="80">80</th><td><u>	    e_com = combuf + com_len + 1; \</u></td></tr>
<tr><th id="81">81</th><td><u>	    if (blank_pos &gt; 0) \</u></td></tr>
<tr><th id="82">82</th><td><u>		last_bl = combuf + blank_pos; \</u></td></tr>
<tr><th id="83">83</th><td><u>	    l_com = combuf + nsize - 5; \</u></td></tr>
<tr><th id="84">84</th><td><u>	    s_com = combuf + 1; \</u></td></tr>
<tr><th id="85">85</th><td><u>	}</u></td></tr>
<tr><th id="86">86</th><td><u>#define <dfn class="macro" id="_M/CHECK_SIZE_LAB" data-ref="_M/CHECK_SIZE_LAB">CHECK_SIZE_LAB</dfn>(desired_size) \</u></td></tr>
<tr><th id="87">87</th><td><u>	if (e_lab + (desired_size) &gt;= l_lab) { \</u></td></tr>
<tr><th id="88">88</th><td><u>	    int nsize = l_lab-s_lab + 400 + desired_size; \</u></td></tr>
<tr><th id="89">89</th><td><u>	    int label_len = e_lab - s_lab; \</u></td></tr>
<tr><th id="90">90</th><td><u>	    labbuf = (char *) realloc(labbuf, nsize); \</u></td></tr>
<tr><th id="91">91</th><td><u>	    if (labbuf == NULL) \</u></td></tr>
<tr><th id="92">92</th><td><u>		err(1, NULL); \</u></td></tr>
<tr><th id="93">93</th><td><u>	    e_lab = labbuf + label_len + 1; \</u></td></tr>
<tr><th id="94">94</th><td><u>	    l_lab = labbuf + nsize - 5; \</u></td></tr>
<tr><th id="95">95</th><td><u>	    s_lab = labbuf + 1; \</u></td></tr>
<tr><th id="96">96</th><td><u>	}</u></td></tr>
<tr><th id="97">97</th><td><u>#define <dfn class="macro" id="_M/CHECK_SIZE_TOKEN" data-ref="_M/CHECK_SIZE_TOKEN">CHECK_SIZE_TOKEN</dfn>(desired_size) \</u></td></tr>
<tr><th id="98">98</th><td><u>	if (e_token + (desired_size) &gt;= l_token) { \</u></td></tr>
<tr><th id="99">99</th><td><u>	    int nsize = l_token-s_token + 400 + desired_size; \</u></td></tr>
<tr><th id="100">100</th><td><u>	    int token_len = e_token - s_token; \</u></td></tr>
<tr><th id="101">101</th><td><u>	    tokenbuf = (char *) realloc(tokenbuf, nsize); \</u></td></tr>
<tr><th id="102">102</th><td><u>	    if (tokenbuf == NULL) \</u></td></tr>
<tr><th id="103">103</th><td><u>		err(1, NULL); \</u></td></tr>
<tr><th id="104">104</th><td><u>	    e_token = tokenbuf + token_len + 1; \</u></td></tr>
<tr><th id="105">105</th><td><u>	    l_token = tokenbuf + nsize - 5; \</u></td></tr>
<tr><th id="106">106</th><td><u>	    s_token = tokenbuf + 1; \</u></td></tr>
<tr><th id="107">107</th><td><u>	}</u></td></tr>
<tr><th id="108">108</th><td></td></tr>
<tr><th id="109">109</th><td><em>char</em>       *<dfn class="decl def" id="labbuf" title='labbuf' data-ref="labbuf" data-ref-filename="labbuf">labbuf</dfn>;		<i>/* buffer for label */</i></td></tr>
<tr><th id="110">110</th><td><em>char</em>       *<dfn class="decl def" id="s_lab" title='s_lab' data-ref="s_lab" data-ref-filename="s_lab">s_lab</dfn>;		<i>/* start ... */</i></td></tr>
<tr><th id="111">111</th><td><em>char</em>       *<dfn class="decl def" id="e_lab" title='e_lab' data-ref="e_lab" data-ref-filename="e_lab">e_lab</dfn>;		<i>/* .. and end of stored label */</i></td></tr>
<tr><th id="112">112</th><td><em>char</em>       *<dfn class="decl def" id="l_lab" title='l_lab' data-ref="l_lab" data-ref-filename="l_lab">l_lab</dfn>;		<i>/* limit of label buffer */</i></td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td><em>char</em>       *<dfn class="decl def" id="codebuf" title='codebuf' data-ref="codebuf" data-ref-filename="codebuf">codebuf</dfn>;		<i>/* buffer for code section */</i></td></tr>
<tr><th id="115">115</th><td><em>char</em>       *<dfn class="decl def" id="s_code" title='s_code' data-ref="s_code" data-ref-filename="s_code">s_code</dfn>;		<i>/* start ... */</i></td></tr>
<tr><th id="116">116</th><td><em>char</em>       *<dfn class="decl def" id="e_code" title='e_code' data-ref="e_code" data-ref-filename="e_code">e_code</dfn>;		<i>/* .. and end of stored code */</i></td></tr>
<tr><th id="117">117</th><td><em>char</em>       *<dfn class="decl def" id="l_code" title='l_code' data-ref="l_code" data-ref-filename="l_code">l_code</dfn>;		<i>/* limit of code section */</i></td></tr>
<tr><th id="118">118</th><td></td></tr>
<tr><th id="119">119</th><td><em>char</em>       *<dfn class="decl def" id="combuf" title='combuf' data-ref="combuf" data-ref-filename="combuf">combuf</dfn>;		<i>/* buffer for comments */</i></td></tr>
<tr><th id="120">120</th><td><em>char</em>       *<dfn class="decl def" id="s_com" title='s_com' data-ref="s_com" data-ref-filename="s_com">s_com</dfn>;		<i>/* start ... */</i></td></tr>
<tr><th id="121">121</th><td><em>char</em>       *<dfn class="decl def" id="e_com" title='e_com' data-ref="e_com" data-ref-filename="e_com">e_com</dfn>;		<i>/* ... and end of stored comments */</i></td></tr>
<tr><th id="122">122</th><td><em>char</em>       *<dfn class="decl def" id="l_com" title='l_com' data-ref="l_com" data-ref-filename="l_com">l_com</dfn>;		<i>/* limit of comment buffer */</i></td></tr>
<tr><th id="123">123</th><td></td></tr>
<tr><th id="124">124</th><td><u>#define <dfn class="macro" id="_M/token" data-ref="_M/token">token</dfn> s_token</u></td></tr>
<tr><th id="125">125</th><td><em>char</em>       *<dfn class="decl def" id="tokenbuf" title='tokenbuf' data-ref="tokenbuf" data-ref-filename="tokenbuf">tokenbuf</dfn>;		<i>/* the last token scanned */</i></td></tr>
<tr><th id="126">126</th><td><em>char</em>	   *<dfn class="decl def" id="s_token" title='s_token' data-ref="s_token" data-ref-filename="s_token">s_token</dfn>;</td></tr>
<tr><th id="127">127</th><td><em>char</em>       *<dfn class="decl def" id="e_token" title='e_token' data-ref="e_token" data-ref-filename="e_token">e_token</dfn>;</td></tr>
<tr><th id="128">128</th><td><em>char</em>	   *<dfn class="decl def" id="l_token" title='l_token' data-ref="l_token" data-ref-filename="l_token">l_token</dfn>;</td></tr>
<tr><th id="129">129</th><td></td></tr>
<tr><th id="130">130</th><td><em>char</em>       *<dfn class="decl def" id="in_buffer" title='in_buffer' data-ref="in_buffer" data-ref-filename="in_buffer">in_buffer</dfn>;		<i>/* input buffer */</i></td></tr>
<tr><th id="131">131</th><td><em>char</em>	   *<dfn class="decl def" id="in_buffer_limit" title='in_buffer_limit' data-ref="in_buffer_limit" data-ref-filename="in_buffer_limit">in_buffer_limit</dfn>;	<i>/* the end of the input buffer */</i></td></tr>
<tr><th id="132">132</th><td><em>char</em>       *<dfn class="decl def" id="buf_ptr" title='buf_ptr' data-ref="buf_ptr" data-ref-filename="buf_ptr">buf_ptr</dfn>;		<i>/* ptr to next character to be taken from</i></td></tr>
<tr><th id="133">133</th><td><i>				 * in_buffer */</i></td></tr>
<tr><th id="134">134</th><td><em>char</em>       *<dfn class="decl def" id="buf_end" title='buf_end' data-ref="buf_end" data-ref-filename="buf_end">buf_end</dfn>;		<i>/* ptr to first after last char in in_buffer */</i></td></tr>
<tr><th id="135">135</th><td></td></tr>
<tr><th id="136">136</th><td><em>char</em>        <dfn class="decl def" id="sc_buf" title='sc_buf' data-ref="sc_buf" data-ref-filename="sc_buf">sc_buf</dfn>[<a class="macro" href="#45" title="5000" data-ref="_M/sc_size">sc_size</a>];	<i>/* input text is saved here when looking for</i></td></tr>
<tr><th id="137">137</th><td><i>				 * the brace after an if, while, etc */</i></td></tr>
<tr><th id="138">138</th><td><em>char</em>       *<dfn class="decl def" id="save_com" title='save_com' data-ref="save_com" data-ref-filename="save_com">save_com</dfn>;		<i>/* start of the comment stored in sc_buf */</i></td></tr>
<tr><th id="139">139</th><td><em>char</em>       *<dfn class="decl def" id="sc_end" title='sc_end' data-ref="sc_end" data-ref-filename="sc_end">sc_end</dfn>;		<i>/* pointer into save_com buffer */</i></td></tr>
<tr><th id="140">140</th><td></td></tr>
<tr><th id="141">141</th><td><em>char</em>       *<dfn class="decl def" id="bp_save" title='bp_save' data-ref="bp_save" data-ref-filename="bp_save">bp_save</dfn>;		<i>/* saved value of buf_ptr when taking input</i></td></tr>
<tr><th id="142">142</th><td><i>				 * from save_com */</i></td></tr>
<tr><th id="143">143</th><td><em>char</em>       *<dfn class="decl def" id="be_save" title='be_save' data-ref="be_save" data-ref-filename="be_save">be_save</dfn>;		<i>/* similarly saved value of buf_end */</i></td></tr>
<tr><th id="144">144</th><td></td></tr>
<tr><th id="145">145</th><td></td></tr>
<tr><th id="146">146</th><td><b>struct</b> <dfn class="type def" id="options" title='options' data-ref="options" data-ref-filename="options"><a class="type" href="#options" title='options' data-ref="options" data-ref-filename="options">options</a></dfn> {</td></tr>
<tr><th id="147">147</th><td>    <em>int</em>         <dfn class="decl field" id="options::blanklines_around_conditional_compilation" title='options::blanklines_around_conditional_compilation' data-ref="options::blanklines_around_conditional_compilation" data-ref-filename="options..blanklines_around_conditional_compilation">blanklines_around_conditional_compilation</dfn>;</td></tr>
<tr><th id="148">148</th><td>    <em>int</em>         <dfn class="decl field" id="options::blanklines_after_declarations_at_proctop" title='options::blanklines_after_declarations_at_proctop' data-ref="options::blanklines_after_declarations_at_proctop" data-ref-filename="options..blanklines_after_declarations_at_proctop">blanklines_after_declarations_at_proctop</dfn>; <i>/* this is vaguely</i></td></tr>
<tr><th id="149">149</th><td><i>				 * similar to blanklines_after_decla except</i></td></tr>
<tr><th id="150">150</th><td><i>				 * that in only applies to the first set of</i></td></tr>
<tr><th id="151">151</th><td><i>				 * declarations in a procedure (just after</i></td></tr>
<tr><th id="152">152</th><td><i>				 * the first '{') and it causes a blank line</i></td></tr>
<tr><th id="153">153</th><td><i>				 * to be generated even if there are no</i></td></tr>
<tr><th id="154">154</th><td><i>				 * declarations */</i></td></tr>
<tr><th id="155">155</th><td>    <em>int</em>         <dfn class="decl field" id="options::blanklines_after_declarations" title='options::blanklines_after_declarations' data-ref="options::blanklines_after_declarations" data-ref-filename="options..blanklines_after_declarations">blanklines_after_declarations</dfn>;</td></tr>
<tr><th id="156">156</th><td>    <em>int</em>         <dfn class="decl field" id="options::blanklines_after_procs" title='options::blanklines_after_procs' data-ref="options::blanklines_after_procs" data-ref-filename="options..blanklines_after_procs">blanklines_after_procs</dfn>;</td></tr>
<tr><th id="157">157</th><td>    <em>int</em>         <dfn class="decl field" id="options::blanklines_before_blockcomments" title='options::blanklines_before_blockcomments' data-ref="options::blanklines_before_blockcomments" data-ref-filename="options..blanklines_before_blockcomments">blanklines_before_blockcomments</dfn>;</td></tr>
<tr><th id="158">158</th><td>    <em>int</em>         <dfn class="decl field" id="options::leave_comma" title='options::leave_comma' data-ref="options::leave_comma" data-ref-filename="options..leave_comma">leave_comma</dfn>;	<i>/* if true, never break declarations after</i></td></tr>
<tr><th id="159">159</th><td><i>				 * commas */</i></td></tr>
<tr><th id="160">160</th><td>    <em>int</em>         <dfn class="decl field" id="options::btype_2" title='options::btype_2' data-ref="options::btype_2" data-ref-filename="options..btype_2">btype_2</dfn>;	<i>/* when true, brace should be on same line</i></td></tr>
<tr><th id="161">161</th><td><i>				 * as if, while, etc */</i></td></tr>
<tr><th id="162">162</th><td>    <em>int</em>         <dfn class="decl field" id="options::Bill_Shannon" title='options::Bill_Shannon' data-ref="options::Bill_Shannon" data-ref-filename="options..Bill_Shannon">Bill_Shannon</dfn>;	<i>/* true iff a blank should always be</i></td></tr>
<tr><th id="163">163</th><td><i>				 * inserted after sizeof */</i></td></tr>
<tr><th id="164">164</th><td>    <em>int</em>         <dfn class="decl field" id="options::comment_delimiter_on_blankline" title='options::comment_delimiter_on_blankline' data-ref="options::comment_delimiter_on_blankline" data-ref-filename="options..comment_delimiter_on_blankline">comment_delimiter_on_blankline</dfn>;</td></tr>
<tr><th id="165">165</th><td>    <em>int</em>         <dfn class="decl field" id="options::decl_com_ind" title='options::decl_com_ind' data-ref="options::decl_com_ind" data-ref-filename="options..decl_com_ind">decl_com_ind</dfn>;	<i>/* the column in which comments after</i></td></tr>
<tr><th id="166">166</th><td><i>				 * declarations should be put */</i></td></tr>
<tr><th id="167">167</th><td>    <em>int</em>         <dfn class="decl field" id="options::cuddle_else" title='options::cuddle_else' data-ref="options::cuddle_else" data-ref-filename="options..cuddle_else">cuddle_else</dfn>;	<i>/* true if else should cuddle up to '}' */</i></td></tr>
<tr><th id="168">168</th><td>    <em>int</em>         <dfn class="decl field" id="options::continuation_indent" title='options::continuation_indent' data-ref="options::continuation_indent" data-ref-filename="options..continuation_indent">continuation_indent</dfn>; <i>/* set to the indentation between the</i></td></tr>
<tr><th id="169">169</th><td><i>				 * edge of code and continuation lines */</i></td></tr>
<tr><th id="170">170</th><td>    <em>float</em>       <dfn class="decl field" id="options::case_indent" title='options::case_indent' data-ref="options::case_indent" data-ref-filename="options..case_indent">case_indent</dfn>;	<i>/* The distance to indent case labels from the</i></td></tr>
<tr><th id="171">171</th><td><i>				 * switch statement */</i></td></tr>
<tr><th id="172">172</th><td>    <em>int</em>         <dfn class="decl field" id="options::com_ind" title='options::com_ind' data-ref="options::com_ind" data-ref-filename="options..com_ind">com_ind</dfn>;	<i>/* the column in which comments to the right</i></td></tr>
<tr><th id="173">173</th><td><i>				 * of code should start */</i></td></tr>
<tr><th id="174">174</th><td>    <em>int</em>         <dfn class="decl field" id="options::decl_indent" title='options::decl_indent' data-ref="options::decl_indent" data-ref-filename="options..decl_indent">decl_indent</dfn>;	<i>/* column to indent declared identifiers to */</i></td></tr>
<tr><th id="175">175</th><td>    <em>int</em>         <dfn class="decl field" id="options::ljust_decl" title='options::ljust_decl' data-ref="options::ljust_decl" data-ref-filename="options..ljust_decl">ljust_decl</dfn>;	<i>/* true if declarations should be left</i></td></tr>
<tr><th id="176">176</th><td><i>				 * justified */</i></td></tr>
<tr><th id="177">177</th><td>    <em>int</em>         <dfn class="decl field" id="options::unindent_displace" title='options::unindent_displace' data-ref="options::unindent_displace" data-ref-filename="options..unindent_displace">unindent_displace</dfn>; <i>/* comments not to the right of code</i></td></tr>
<tr><th id="178">178</th><td><i>				 * will be placed this many</i></td></tr>
<tr><th id="179">179</th><td><i>				 * indentation levels to the left of</i></td></tr>
<tr><th id="180">180</th><td><i>				 * code */</i></td></tr>
<tr><th id="181">181</th><td>    <em>int</em>         <dfn class="decl field" id="options::extra_expression_indent" title='options::extra_expression_indent' data-ref="options::extra_expression_indent" data-ref-filename="options..extra_expression_indent">extra_expression_indent</dfn>; <i>/* true if continuation lines from</i></td></tr>
<tr><th id="182">182</th><td><i>				 * the expression part of "if(e)",</i></td></tr>
<tr><th id="183">183</th><td><i>				 * "while(e)", "for(e;e;e)" should be</i></td></tr>
<tr><th id="184">184</th><td><i>				 * indented an extra tab stop so that they</i></td></tr>
<tr><th id="185">185</th><td><i>				 * don't conflict with the code that follows */</i></td></tr>
<tr><th id="186">186</th><td>    <em>int</em>         <dfn class="decl field" id="options::else_if" title='options::else_if' data-ref="options::else_if" data-ref-filename="options..else_if">else_if</dfn>;	<i>/* True iff else if pairs should be handled</i></td></tr>
<tr><th id="187">187</th><td><i>				 * specially */</i></td></tr>
<tr><th id="188">188</th><td>    <em>int</em>         <dfn class="decl field" id="options::function_brace_split" title='options::function_brace_split' data-ref="options::function_brace_split" data-ref-filename="options..function_brace_split">function_brace_split</dfn>; <i>/* split function declaration and</i></td></tr>
<tr><th id="189">189</th><td><i>				 * brace onto separate lines */</i></td></tr>
<tr><th id="190">190</th><td>    <em>int</em>         <dfn class="decl field" id="options::format_col1_comments" title='options::format_col1_comments' data-ref="options::format_col1_comments" data-ref-filename="options..format_col1_comments">format_col1_comments</dfn>; <i>/* If comments which start in column 1</i></td></tr>
<tr><th id="191">191</th><td><i>				 * are to be magically reformatted (just</i></td></tr>
<tr><th id="192">192</th><td><i>				 * like comments that begin in later columns) */</i></td></tr>
<tr><th id="193">193</th><td>    <em>int</em>         <dfn class="decl field" id="options::format_block_comments" title='options::format_block_comments' data-ref="options::format_block_comments" data-ref-filename="options..format_block_comments">format_block_comments</dfn>; <i>/* true if comments beginning with</i></td></tr>
<tr><th id="194">194</th><td><i>				 * `/ * \n' are to be reformatted */</i></td></tr>
<tr><th id="195">195</th><td>    <em>int</em>         <dfn class="decl field" id="options::indent_parameters" title='options::indent_parameters' data-ref="options::indent_parameters" data-ref-filename="options..indent_parameters">indent_parameters</dfn>;</td></tr>
<tr><th id="196">196</th><td>    <em>int</em>         <dfn class="decl field" id="options::ind_size" title='options::ind_size' data-ref="options::ind_size" data-ref-filename="options..ind_size">ind_size</dfn>;	<i>/* the size of one indentation level */</i></td></tr>
<tr><th id="197">197</th><td>    <em>int</em>         <dfn class="decl field" id="options::block_comment_max_col" title='options::block_comment_max_col' data-ref="options::block_comment_max_col" data-ref-filename="options..block_comment_max_col">block_comment_max_col</dfn>;</td></tr>
<tr><th id="198">198</th><td>    <em>int</em>         <dfn class="decl field" id="options::local_decl_indent" title='options::local_decl_indent' data-ref="options::local_decl_indent" data-ref-filename="options..local_decl_indent">local_decl_indent</dfn>; <i>/* like decl_indent but for locals */</i></td></tr>
<tr><th id="199">199</th><td>    <em>int</em>         <dfn class="decl field" id="options::lineup_to_parens_always" title='options::lineup_to_parens_always' data-ref="options::lineup_to_parens_always" data-ref-filename="options..lineup_to_parens_always">lineup_to_parens_always</dfn>; <i>/* if true, do not attempt to keep</i></td></tr>
<tr><th id="200">200</th><td><i>				 * lined-up code within the margin */</i></td></tr>
<tr><th id="201">201</th><td>    <em>int</em>         <dfn class="decl field" id="options::lineup_to_parens" title='options::lineup_to_parens' data-ref="options::lineup_to_parens" data-ref-filename="options..lineup_to_parens">lineup_to_parens</dfn>; <i>/* if true, continued code within parens</i></td></tr>
<tr><th id="202">202</th><td><i>				 * will be lined up to the open paren */</i></td></tr>
<tr><th id="203">203</th><td>    <em>int</em>         <dfn class="decl field" id="options::proc_calls_space" title='options::proc_calls_space' data-ref="options::proc_calls_space" data-ref-filename="options..proc_calls_space">proc_calls_space</dfn>; <i>/* If true, procedure calls look like:</i></td></tr>
<tr><th id="204">204</th><td><i>				 * foo (bar) rather than foo(bar) */</i></td></tr>
<tr><th id="205">205</th><td>    <em>int</em>         <dfn class="decl field" id="options::procnames_start_line" title='options::procnames_start_line' data-ref="options::procnames_start_line" data-ref-filename="options..procnames_start_line">procnames_start_line</dfn>; <i>/* if true, the names of procedures</i></td></tr>
<tr><th id="206">206</th><td><i>				 * being defined get placed in column 1 (ie.</i></td></tr>
<tr><th id="207">207</th><td><i>				 * a newline is placed between the type of</i></td></tr>
<tr><th id="208">208</th><td><i>				 * the procedure and its name) */</i></td></tr>
<tr><th id="209">209</th><td>    <em>int</em>         <dfn class="decl field" id="options::space_after_cast" title='options::space_after_cast' data-ref="options::space_after_cast" data-ref-filename="options..space_after_cast">space_after_cast</dfn>; <i>/* "b = (int) a" vs "b = (int)a" */</i></td></tr>
<tr><th id="210">210</th><td>    <em>int</em>         <dfn class="decl field" id="options::star_comment_cont" title='options::star_comment_cont' data-ref="options::star_comment_cont" data-ref-filename="options..star_comment_cont">star_comment_cont</dfn>; <i>/* true iff comment continuation lines</i></td></tr>
<tr><th id="211">211</th><td><i>				 * should have stars at the beginning of</i></td></tr>
<tr><th id="212">212</th><td><i>				 * each line. */</i></td></tr>
<tr><th id="213">213</th><td>    <em>int</em>         <dfn class="decl field" id="options::swallow_optional_blanklines" title='options::swallow_optional_blanklines' data-ref="options::swallow_optional_blanklines" data-ref-filename="options..swallow_optional_blanklines">swallow_optional_blanklines</dfn>;</td></tr>
<tr><th id="214">214</th><td>    <em>int</em>         <dfn class="decl field" id="options::auto_typedefs" title='options::auto_typedefs' data-ref="options::auto_typedefs" data-ref-filename="options..auto_typedefs">auto_typedefs</dfn>;	<i>/* set true to recognize identifiers</i></td></tr>
<tr><th id="215">215</th><td><i>				 * ending in "_t" like typedefs */</i></td></tr>
<tr><th id="216">216</th><td>    <em>int</em>         <dfn class="decl field" id="options::tabsize" title='options::tabsize' data-ref="options::tabsize" data-ref-filename="options..tabsize">tabsize</dfn>;	<i>/* the size of a tab */</i></td></tr>
<tr><th id="217">217</th><td>    <em>int</em>         <dfn class="decl field" id="options::max_col" title='options::max_col' data-ref="options::max_col" data-ref-filename="options..max_col">max_col</dfn>;	<i>/* the maximum allowable line length */</i></td></tr>
<tr><th id="218">218</th><td>    <em>int</em>         <dfn class="decl field" id="options::use_tabs" title='options::use_tabs' data-ref="options::use_tabs" data-ref-filename="options..use_tabs">use_tabs</dfn>;	<i>/* set true to use tabs for spacing, false</i></td></tr>
<tr><th id="219">219</th><td><i>				 * uses all spaces */</i></td></tr>
<tr><th id="220">220</th><td>    <em>int</em>         <dfn class="decl field" id="options::verbose" title='options::verbose' data-ref="options::verbose" data-ref-filename="options..verbose">verbose</dfn>;	<i>/* when true, non-essential error messages</i></td></tr>
<tr><th id="221">221</th><td><i>				 * are printed */</i></td></tr>
<tr><th id="222">222</th><td>} <dfn class="decl def" id="opt" title='opt' data-ref="opt" data-ref-filename="opt">opt</dfn>;</td></tr>
<tr><th id="223">223</th><td></td></tr>
<tr><th id="224">224</th><td><em>int</em>         <dfn class="decl def" id="found_err" title='found_err' data-ref="found_err" data-ref-filename="found_err">found_err</dfn>;</td></tr>
<tr><th id="225">225</th><td><em>int</em>         <dfn class="decl def" id="n_real_blanklines" title='n_real_blanklines' data-ref="n_real_blanklines" data-ref-filename="n_real_blanklines">n_real_blanklines</dfn>;</td></tr>
<tr><th id="226">226</th><td><em>int</em>         <dfn class="decl def" id="prefix_blankline_requested" title='prefix_blankline_requested' data-ref="prefix_blankline_requested" data-ref-filename="prefix_blankline_requested">prefix_blankline_requested</dfn>;</td></tr>
<tr><th id="227">227</th><td><em>int</em>         <dfn class="decl def" id="postfix_blankline_requested" title='postfix_blankline_requested' data-ref="postfix_blankline_requested" data-ref-filename="postfix_blankline_requested">postfix_blankline_requested</dfn>;</td></tr>
<tr><th id="228">228</th><td><em>int</em>         <dfn class="decl def" id="break_comma" title='break_comma' data-ref="break_comma" data-ref-filename="break_comma">break_comma</dfn>;	<i>/* when true and not in parens, break after a</i></td></tr>
<tr><th id="229">229</th><td><i>				 * comma */</i></td></tr>
<tr><th id="230">230</th><td><em>float</em>       <dfn class="decl def" id="case_ind" title='case_ind' data-ref="case_ind" data-ref-filename="case_ind">case_ind</dfn>;		<i>/* indentation level to be used for a "case</i></td></tr>
<tr><th id="231">231</th><td><i>				 * n:" */</i></td></tr>
<tr><th id="232">232</th><td><em>int</em>         <dfn class="decl def" id="code_lines" title='code_lines' data-ref="code_lines" data-ref-filename="code_lines">code_lines</dfn>;		<i>/* count of lines with code */</i></td></tr>
<tr><th id="233">233</th><td><em>int</em>         <dfn class="decl def" id="had_eof" title='had_eof' data-ref="had_eof" data-ref-filename="had_eof">had_eof</dfn>;		<i>/* set to true when input is exhausted */</i></td></tr>
<tr><th id="234">234</th><td><em>int</em>         <dfn class="decl def" id="line_no" title='line_no' data-ref="line_no" data-ref-filename="line_no">line_no</dfn>;		<i>/* the current line number. */</i></td></tr>
<tr><th id="235">235</th><td><em>int</em>         <dfn class="decl def" id="inhibit_formatting" title='inhibit_formatting' data-ref="inhibit_formatting" data-ref-filename="inhibit_formatting">inhibit_formatting</dfn>;	<i>/* true if INDENT OFF is in effect */</i></td></tr>
<tr><th id="236">236</th><td><em>int</em>         <dfn class="decl def" id="suppress_blanklines" title='suppress_blanklines' data-ref="suppress_blanklines" data-ref-filename="suppress_blanklines">suppress_blanklines</dfn>;<i>/* set iff following blanklines should be</i></td></tr>
<tr><th id="237">237</th><td><i>				 * suppressed */</i></td></tr>
<tr><th id="238">238</th><td></td></tr>
<tr><th id="239">239</th><td><u>#define	<dfn class="macro" id="_M/STACKSIZE" data-ref="_M/STACKSIZE">STACKSIZE</dfn> 256</u></td></tr>
<tr><th id="240">240</th><td></td></tr>
<tr><th id="241">241</th><td><b>struct</b> <dfn class="type def" id="parser_state" title='parser_state' data-ref="parser_state" data-ref-filename="parser_state"><a class="type" href="#parser_state" title='parser_state' data-ref="parser_state" data-ref-filename="parser_state">parser_state</a></dfn> {</td></tr>
<tr><th id="242">242</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::last_token" title='parser_state::last_token' data-ref="parser_state::last_token" data-ref-filename="parser_state..last_token">last_token</dfn>;</td></tr>
<tr><th id="243">243</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::p_stack" title='parser_state::p_stack' data-ref="parser_state::p_stack" data-ref-filename="parser_state..p_stack">p_stack</dfn>[<a class="macro" href="#239" title="256" data-ref="_M/STACKSIZE">STACKSIZE</a>];	<i>/* this is the parsers stack */</i></td></tr>
<tr><th id="244">244</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::il" title='parser_state::il' data-ref="parser_state::il" data-ref-filename="parser_state..il">il</dfn>[<a class="macro" href="#239" title="256" data-ref="_M/STACKSIZE">STACKSIZE</a>];	<i>/* this stack stores indentation levels */</i></td></tr>
<tr><th id="245">245</th><td>    <em>float</em>       <dfn class="decl field" id="parser_state::cstk" title='parser_state::cstk' data-ref="parser_state::cstk" data-ref-filename="parser_state..cstk">cstk</dfn>[<a class="macro" href="#239" title="256" data-ref="_M/STACKSIZE">STACKSIZE</a>];<i>/* used to store case stmt indentation levels */</i></td></tr>
<tr><th id="246">246</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::box_com" title='parser_state::box_com' data-ref="parser_state::box_com" data-ref-filename="parser_state..box_com">box_com</dfn>;	<i>/* set to true when we are in a "boxed"</i></td></tr>
<tr><th id="247">247</th><td><i>				 * comment. In that case, the first non-blank</i></td></tr>
<tr><th id="248">248</th><td><i>				 * char should be lined up with the / in / followed by * */</i></td></tr>
<tr><th id="249">249</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::comment_delta" title='parser_state::comment_delta' data-ref="parser_state::comment_delta" data-ref-filename="parser_state..comment_delta">comment_delta</dfn>;	<i>/* used to set up indentation for all lines</i></td></tr>
<tr><th id="250">250</th><td><i>				 * of a boxed comment after the first one */</i></td></tr>
<tr><th id="251">251</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::n_comment_delta" title='parser_state::n_comment_delta' data-ref="parser_state::n_comment_delta" data-ref-filename="parser_state..n_comment_delta">n_comment_delta</dfn>;<i>/* remembers how many columns there were</i></td></tr>
<tr><th id="252">252</th><td><i>				 * before the start of a box comment so that</i></td></tr>
<tr><th id="253">253</th><td><i>				 * forthcoming lines of the comment are</i></td></tr>
<tr><th id="254">254</th><td><i>				 * indented properly */</i></td></tr>
<tr><th id="255">255</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::cast_mask" title='parser_state::cast_mask' data-ref="parser_state::cast_mask" data-ref-filename="parser_state..cast_mask">cast_mask</dfn>;	<i>/* indicates which close parens potentially</i></td></tr>
<tr><th id="256">256</th><td><i>				 * close off casts */</i></td></tr>
<tr><th id="257">257</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::not_cast_mask" title='parser_state::not_cast_mask' data-ref="parser_state::not_cast_mask" data-ref-filename="parser_state..not_cast_mask">not_cast_mask</dfn>;	<i>/* indicates which close parens definitely</i></td></tr>
<tr><th id="258">258</th><td><i>				 * close off something else than casts */</i></td></tr>
<tr><th id="259">259</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::block_init" title='parser_state::block_init' data-ref="parser_state::block_init" data-ref-filename="parser_state..block_init">block_init</dfn>;	<i>/* true iff inside a block initialization */</i></td></tr>
<tr><th id="260">260</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::block_init_level" title='parser_state::block_init_level' data-ref="parser_state::block_init_level" data-ref-filename="parser_state..block_init_level">block_init_level</dfn>;	<i>/* The level of brace nesting in an</i></td></tr>
<tr><th id="261">261</th><td><i>					 * initialization */</i></td></tr>
<tr><th id="262">262</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::last_nl" title='parser_state::last_nl' data-ref="parser_state::last_nl" data-ref-filename="parser_state..last_nl">last_nl</dfn>;	<i>/* this is true if the last thing scanned was</i></td></tr>
<tr><th id="263">263</th><td><i>				 * a newline */</i></td></tr>
<tr><th id="264">264</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::in_or_st" title='parser_state::in_or_st' data-ref="parser_state::in_or_st" data-ref-filename="parser_state..in_or_st">in_or_st</dfn>;	<i>/* Will be true iff there has been a</i></td></tr>
<tr><th id="265">265</th><td><i>				 * declarator (e.g. int or char) and no left</i></td></tr>
<tr><th id="266">266</th><td><i>				 * paren since the last semicolon. When true,</i></td></tr>
<tr><th id="267">267</th><td><i>				 * a '{' is starting a structure definition or</i></td></tr>
<tr><th id="268">268</th><td><i>				 * an initialization list */</i></td></tr>
<tr><th id="269">269</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::bl_line" title='parser_state::bl_line' data-ref="parser_state::bl_line" data-ref-filename="parser_state..bl_line">bl_line</dfn>;	<i>/* set to 1 by dump_line if the line is blank */</i></td></tr>
<tr><th id="270">270</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::col_1" title='parser_state::col_1' data-ref="parser_state::col_1" data-ref-filename="parser_state..col_1">col_1</dfn>;		<i>/* set to true if the last token started in</i></td></tr>
<tr><th id="271">271</th><td><i>				 * column 1 */</i></td></tr>
<tr><th id="272">272</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::com_col" title='parser_state::com_col' data-ref="parser_state::com_col" data-ref-filename="parser_state..com_col">com_col</dfn>;	<i>/* this is the column in which the current</i></td></tr>
<tr><th id="273">273</th><td><i>				 * comment should start */</i></td></tr>
<tr><th id="274">274</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::com_lines" title='parser_state::com_lines' data-ref="parser_state::com_lines" data-ref-filename="parser_state..com_lines">com_lines</dfn>;	<i>/* the number of lines with comments, set by</i></td></tr>
<tr><th id="275">275</th><td><i>				 * dump_line */</i></td></tr>
<tr><th id="276">276</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::dec_nest" title='parser_state::dec_nest' data-ref="parser_state::dec_nest" data-ref-filename="parser_state..dec_nest">dec_nest</dfn>;	<i>/* current nesting level for structure or init */</i></td></tr>
<tr><th id="277">277</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::decl_on_line" title='parser_state::decl_on_line' data-ref="parser_state::decl_on_line" data-ref-filename="parser_state..decl_on_line">decl_on_line</dfn>;	<i>/* set to true if this line of code has part</i></td></tr>
<tr><th id="278">278</th><td><i>				 * of a declaration on it */</i></td></tr>
<tr><th id="279">279</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::i_l_follow" title='parser_state::i_l_follow' data-ref="parser_state::i_l_follow" data-ref-filename="parser_state..i_l_follow">i_l_follow</dfn>;	<i>/* the level to which ind_level should be set</i></td></tr>
<tr><th id="280">280</th><td><i>				 * after the current line is printed */</i></td></tr>
<tr><th id="281">281</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::in_decl" title='parser_state::in_decl' data-ref="parser_state::in_decl" data-ref-filename="parser_state..in_decl">in_decl</dfn>;	<i>/* set to true when we are in a declaration</i></td></tr>
<tr><th id="282">282</th><td><i>				 * stmt.  The processing of braces is then</i></td></tr>
<tr><th id="283">283</th><td><i>				 * slightly different */</i></td></tr>
<tr><th id="284">284</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::in_stmt" title='parser_state::in_stmt' data-ref="parser_state::in_stmt" data-ref-filename="parser_state..in_stmt">in_stmt</dfn>;	<i>/* set to 1 while in a stmt */</i></td></tr>
<tr><th id="285">285</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::ind_level" title='parser_state::ind_level' data-ref="parser_state::ind_level" data-ref-filename="parser_state..ind_level">ind_level</dfn>;	<i>/* the current indentation level */</i></td></tr>
<tr><th id="286">286</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::ind_stmt" title='parser_state::ind_stmt' data-ref="parser_state::ind_stmt" data-ref-filename="parser_state..ind_stmt">ind_stmt</dfn>;	<i>/* set to 1 if next line should have an extra</i></td></tr>
<tr><th id="287">287</th><td><i>				 * indentation level because we are in the</i></td></tr>
<tr><th id="288">288</th><td><i>				 * middle of a stmt */</i></td></tr>
<tr><th id="289">289</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::last_u_d" title='parser_state::last_u_d' data-ref="parser_state::last_u_d" data-ref-filename="parser_state..last_u_d">last_u_d</dfn>;	<i>/* set to true after scanning a token which</i></td></tr>
<tr><th id="290">290</th><td><i>				 * forces a following operator to be unary */</i></td></tr>
<tr><th id="291">291</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::out_coms" title='parser_state::out_coms' data-ref="parser_state::out_coms" data-ref-filename="parser_state..out_coms">out_coms</dfn>;	<i>/* the number of comments processed, set by</i></td></tr>
<tr><th id="292">292</th><td><i>				 * pr_comment */</i></td></tr>
<tr><th id="293">293</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::out_lines" title='parser_state::out_lines' data-ref="parser_state::out_lines" data-ref-filename="parser_state..out_lines">out_lines</dfn>;	<i>/* the number of lines written, set by</i></td></tr>
<tr><th id="294">294</th><td><i>				 * dump_line */</i></td></tr>
<tr><th id="295">295</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::p_l_follow" title='parser_state::p_l_follow' data-ref="parser_state::p_l_follow" data-ref-filename="parser_state..p_l_follow">p_l_follow</dfn>;	<i>/* used to remember how to indent following</i></td></tr>
<tr><th id="296">296</th><td><i>				 * statement */</i></td></tr>
<tr><th id="297">297</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::paren_level" title='parser_state::paren_level' data-ref="parser_state::paren_level" data-ref-filename="parser_state..paren_level">paren_level</dfn>;	<i>/* parenthesization level. used to indent</i></td></tr>
<tr><th id="298">298</th><td><i>				 * within statements */</i></td></tr>
<tr><th id="299">299</th><td>    <em>short</em>       <dfn class="decl field" id="parser_state::paren_indents" title='parser_state::paren_indents' data-ref="parser_state::paren_indents" data-ref-filename="parser_state..paren_indents">paren_indents</dfn>[<var>20</var>];	<i>/* column positions of each paren */</i></td></tr>
<tr><th id="300">300</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::pcase" title='parser_state::pcase' data-ref="parser_state::pcase" data-ref-filename="parser_state..pcase">pcase</dfn>;		<i>/* set to 1 if the current line label is a</i></td></tr>
<tr><th id="301">301</th><td><i>				 * case.  It is printed differently from a</i></td></tr>
<tr><th id="302">302</th><td><i>				 * regular label */</i></td></tr>
<tr><th id="303">303</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::search_brace" title='parser_state::search_brace' data-ref="parser_state::search_brace" data-ref-filename="parser_state..search_brace">search_brace</dfn>;	<i>/* set to true by parse when it is necessary</i></td></tr>
<tr><th id="304">304</th><td><i>				 * to buffer up all info up to the start of a</i></td></tr>
<tr><th id="305">305</th><td><i>				 * stmt after an if, while, etc */</i></td></tr>
<tr><th id="306">306</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::use_ff" title='parser_state::use_ff' data-ref="parser_state::use_ff" data-ref-filename="parser_state..use_ff">use_ff</dfn>;		<i>/* set to one if the current line should be</i></td></tr>
<tr><th id="307">307</th><td><i>				 * terminated with a form feed */</i></td></tr>
<tr><th id="308">308</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::want_blank" title='parser_state::want_blank' data-ref="parser_state::want_blank" data-ref-filename="parser_state..want_blank">want_blank</dfn>;	<i>/* set to true when the following token should</i></td></tr>
<tr><th id="309">309</th><td><i>				 * be prefixed by a blank. (Said prefixing is</i></td></tr>
<tr><th id="310">310</th><td><i>				 * ignored in some cases.) */</i></td></tr>
<tr><th id="311">311</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::keyword" title='parser_state::keyword' data-ref="parser_state::keyword" data-ref-filename="parser_state..keyword">keyword</dfn>;	<i>/* the type of a keyword or 0 */</i></td></tr>
<tr><th id="312">312</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::dumped_decl_indent" title='parser_state::dumped_decl_indent' data-ref="parser_state::dumped_decl_indent" data-ref-filename="parser_state..dumped_decl_indent">dumped_decl_indent</dfn>;</td></tr>
<tr><th id="313">313</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::in_parameter_declaration" title='parser_state::in_parameter_declaration' data-ref="parser_state::in_parameter_declaration" data-ref-filename="parser_state..in_parameter_declaration">in_parameter_declaration</dfn>;</td></tr>
<tr><th id="314">314</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::tos" title='parser_state::tos' data-ref="parser_state::tos" data-ref-filename="parser_state..tos">tos</dfn>;		<i>/* pointer to top of stack */</i></td></tr>
<tr><th id="315">315</th><td>    <em>char</em>        <dfn class="decl field" id="parser_state::procname" title='parser_state::procname' data-ref="parser_state::procname" data-ref-filename="parser_state..procname">procname</dfn>[<var>100</var>];	<i>/* The name of the current procedure */</i></td></tr>
<tr><th id="316">316</th><td>    <em>int</em>         <dfn class="decl field" id="parser_state::just_saw_decl" title='parser_state::just_saw_decl' data-ref="parser_state::just_saw_decl" data-ref-filename="parser_state..just_saw_decl">just_saw_decl</dfn>;</td></tr>
<tr><th id="317">317</th><td>}           <dfn class="decl def" id="ps" title='ps' data-ref="ps" data-ref-filename="ps">ps</dfn>;</td></tr>
<tr><th id="318">318</th><td></td></tr>
<tr><th id="319">319</th><td><em>int</em>         <dfn class="decl def" id="ifdef_level" title='ifdef_level' data-ref="ifdef_level" data-ref-filename="ifdef_level">ifdef_level</dfn>;</td></tr>
<tr><th id="320">320</th><td><b>struct</b> <a class="type" href="#parser_state" title='parser_state' data-ref="parser_state" data-ref-filename="parser_state">parser_state</a> <dfn class="decl def" id="state_stack" title='state_stack' data-ref="state_stack" data-ref-filename="state_stack">state_stack</dfn>[<var>5</var>];</td></tr>
<tr><th id="321">321</th><td><b>struct</b> <a class="type" href="#parser_state" title='parser_state' data-ref="parser_state" data-ref-filename="parser_state">parser_state</a> <dfn class="decl def" id="match_state" title='match_state' data-ref="match_state" data-ref-filename="match_state">match_state</dfn>[<var>5</var>];</td></tr>
<tr><th id="322">322</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='args.c.html'>netbsd/usr.bin/indent/args.c</a><br/>Generated on <em>2019-Jul-19</em> from project netbsd revision <em>f9da89e0d</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
